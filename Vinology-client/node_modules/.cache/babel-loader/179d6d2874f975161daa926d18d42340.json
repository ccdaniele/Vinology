{"ast":null,"code":"'use strict';\n\nconst tx = {\n  // Set the outgoing host.\n  setHost(span, hostname, port) {\n    hostname && span.setTag('out.host', hostname);\n    port && span.setTag('out.port', port);\n  },\n\n  // Wrap a promise or a callback to also finish the span.\n  wrap(span, done) {\n    if (typeof done === 'function' || !done) {\n      return wrapCallback(span, done);\n    } else if (isPromise(done)) {\n      return wrapPromise(span, done);\n    } else if (done && done.length) {\n      return wrapArguments(span, done);\n    }\n  }\n\n};\n\nfunction wrapCallback(span, callback) {\n  const scope = span.tracer().scope();\n  const previous = scope.active();\n  return function (err) {\n    finish(span, err);\n\n    if (callback) {\n      return scope.activate(previous, () => callback.apply(this, arguments));\n    }\n  };\n}\n\nfunction wrapPromise(span, promise) {\n  promise.then(() => finish(span), err => finish(span, err));\n  return promise;\n}\n\nfunction wrapArguments(span, args) {\n  const lastIndex = args.length - 1;\n  const callback = args[lastIndex];\n\n  if (typeof callback === 'function') {\n    args[lastIndex] = wrapCallback(span, args[lastIndex]);\n  }\n\n  return args;\n}\n\nfunction finish(span, error) {\n  if (error) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    });\n  }\n\n  span.finish();\n}\n\nfunction isPromise(obj) {\n  return isObject(obj) && typeof obj.then === 'function';\n}\n\nfunction isObject(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n\nmodule.exports = tx;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/plugins/util/tx.js"],"names":["tx","setHost","span","hostname","port","setTag","wrap","done","wrapCallback","isPromise","wrapPromise","length","wrapArguments","callback","scope","tracer","previous","active","err","finish","activate","apply","arguments","promise","then","args","lastIndex","error","addTags","name","message","stack","obj","isObject","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAG;AACT;AACAC,EAAAA,OAAO,CAAEC,IAAF,EAAQC,QAAR,EAAkBC,IAAlB,EAAwB;AAC7BD,IAAAA,QAAQ,IAAID,IAAI,CAACG,MAAL,CAAY,UAAZ,EAAwBF,QAAxB,CAAZ;AACAC,IAAAA,IAAI,IAAIF,IAAI,CAACG,MAAL,CAAY,UAAZ,EAAwBD,IAAxB,CAAR;AACD,GALQ;;AAOT;AACAE,EAAAA,IAAI,CAAEJ,IAAF,EAAQK,IAAR,EAAc;AAChB,QAAI,OAAOA,IAAP,KAAgB,UAAhB,IAA8B,CAACA,IAAnC,EAAyC;AACvC,aAAOC,YAAY,CAACN,IAAD,EAAOK,IAAP,CAAnB;AACD,KAFD,MAEO,IAAIE,SAAS,CAACF,IAAD,CAAb,EAAqB;AAC1B,aAAOG,WAAW,CAACR,IAAD,EAAOK,IAAP,CAAlB;AACD,KAFM,MAEA,IAAIA,IAAI,IAAIA,IAAI,CAACI,MAAjB,EAAyB;AAC9B,aAAOC,aAAa,CAACV,IAAD,EAAOK,IAAP,CAApB;AACD;AACF;;AAhBQ,CAAX;;AAmBA,SAASC,YAAT,CAAuBN,IAAvB,EAA6BW,QAA7B,EAAuC;AACrC,QAAMC,KAAK,GAAGZ,IAAI,CAACa,MAAL,GAAcD,KAAd,EAAd;AACA,QAAME,QAAQ,GAAGF,KAAK,CAACG,MAAN,EAAjB;AAEA,SAAO,UAAUC,GAAV,EAAe;AACpBC,IAAAA,MAAM,CAACjB,IAAD,EAAOgB,GAAP,CAAN;;AAEA,QAAIL,QAAJ,EAAc;AACZ,aAAOC,KAAK,CAACM,QAAN,CAAeJ,QAAf,EAAyB,MAAMH,QAAQ,CAACQ,KAAT,CAAe,IAAf,EAAqBC,SAArB,CAA/B,CAAP;AACD;AACF,GAND;AAOD;;AAED,SAASZ,WAAT,CAAsBR,IAAtB,EAA4BqB,OAA5B,EAAqC;AACnCA,EAAAA,OAAO,CAACC,IAAR,CACE,MAAML,MAAM,CAACjB,IAAD,CADd,EAEEgB,GAAG,IAAIC,MAAM,CAACjB,IAAD,EAAOgB,GAAP,CAFf;AAKA,SAAOK,OAAP;AACD;;AAED,SAASX,aAAT,CAAwBV,IAAxB,EAA8BuB,IAA9B,EAAoC;AAClC,QAAMC,SAAS,GAAGD,IAAI,CAACd,MAAL,GAAc,CAAhC;AACA,QAAME,QAAQ,GAAGY,IAAI,CAACC,SAAD,CAArB;;AAEA,MAAI,OAAOb,QAAP,KAAoB,UAAxB,EAAoC;AAClCY,IAAAA,IAAI,CAACC,SAAD,CAAJ,GAAkBlB,YAAY,CAACN,IAAD,EAAOuB,IAAI,CAACC,SAAD,CAAX,CAA9B;AACD;;AAED,SAAOD,IAAP;AACD;;AAED,SAASN,MAAT,CAAiBjB,IAAjB,EAAuByB,KAAvB,EAA8B;AAC5B,MAAIA,KAAJ,EAAW;AACTzB,IAAAA,IAAI,CAAC0B,OAAL,CAAa;AACX,oBAAcD,KAAK,CAACE,IADT;AAEX,mBAAaF,KAAK,CAACG,OAFR;AAGX,qBAAeH,KAAK,CAACI;AAHV,KAAb;AAKD;;AAED7B,EAAAA,IAAI,CAACiB,MAAL;AACD;;AAED,SAASV,SAAT,CAAoBuB,GAApB,EAAyB;AACvB,SAAOC,QAAQ,CAACD,GAAD,CAAR,IAAiB,OAAOA,GAAG,CAACR,IAAX,KAAoB,UAA5C;AACD;;AAED,SAASS,QAAT,CAAmBD,GAAnB,EAAwB;AACtB,SAAO,OAAOA,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAK,IAA1C;AACD;;AAEDE,MAAM,CAACC,OAAP,GAAiBnC,EAAjB","sourcesContent":["'use strict'\n\nconst tx = {\n  // Set the outgoing host.\n  setHost (span, hostname, port) {\n    hostname && span.setTag('out.host', hostname)\n    port && span.setTag('out.port', port)\n  },\n\n  // Wrap a promise or a callback to also finish the span.\n  wrap (span, done) {\n    if (typeof done === 'function' || !done) {\n      return wrapCallback(span, done)\n    } else if (isPromise(done)) {\n      return wrapPromise(span, done)\n    } else if (done && done.length) {\n      return wrapArguments(span, done)\n    }\n  }\n}\n\nfunction wrapCallback (span, callback) {\n  const scope = span.tracer().scope()\n  const previous = scope.active()\n\n  return function (err) {\n    finish(span, err)\n\n    if (callback) {\n      return scope.activate(previous, () => callback.apply(this, arguments))\n    }\n  }\n}\n\nfunction wrapPromise (span, promise) {\n  promise.then(\n    () => finish(span),\n    err => finish(span, err)\n  )\n\n  return promise\n}\n\nfunction wrapArguments (span, args) {\n  const lastIndex = args.length - 1\n  const callback = args[lastIndex]\n\n  if (typeof callback === 'function') {\n    args[lastIndex] = wrapCallback(span, args[lastIndex])\n  }\n\n  return args\n}\n\nfunction finish (span, error) {\n  if (error) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    })\n  }\n\n  span.finish()\n}\n\nfunction isPromise (obj) {\n  return isObject(obj) && typeof obj.then === 'function'\n}\n\nfunction isObject (obj) {\n  return typeof obj === 'object' && obj !== null\n}\n\nmodule.exports = tx\n"]},"metadata":{},"sourceType":"script"}