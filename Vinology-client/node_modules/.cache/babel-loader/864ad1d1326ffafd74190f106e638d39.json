{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SourceMapper = void 0; // Originally copied from cloud-debug-nodejs's sourcemapper.ts from\n// https://github.com/googleapis/cloud-debug-nodejs/blob/7bdc2f1f62a3b45b7b53ea79f9444c8ed50e138b/src/agent/io/sourcemapper.ts\n// Modified to map from generated code to source code, rather than from source\n// code to generated code.\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst sourceMap = require(\"source-map\");\n\nconst scanner = require(\"../../third_party/cloud-debug-nodejs/src/agent/io/scanner\");\n\nconst pify = require('pify');\n\nconst pLimit = require('p-limit');\n\nconst readFile = pify(fs.readFile);\nconst CONCURRENCY = 10;\nconst MAP_EXT = '.map';\n/**\n * @param {!Map} infoMap The map that maps input source files to\n *  SourceMapConsumer objects that are used to calculate mapping information\n * @param {string} mapPath The path to the source map file to process.  The\n *  path should be relative to the process's current working directory\n * @private\n */\n\nfunction processSourceMap(infoMap, mapPath) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // this handles the case when the path is undefined, null, or\n    // the empty string\n    if (!mapPath || !mapPath.endsWith(MAP_EXT)) {\n      throw new Error(`The path \"${mapPath}\" does not specify a source map file`);\n    }\n\n    mapPath = path.normalize(mapPath);\n    let contents;\n\n    try {\n      contents = yield readFile(mapPath, 'utf8');\n    } catch (e) {\n      throw new Error('Could not read source map file ' + mapPath + ': ' + e);\n    }\n\n    let consumer;\n\n    try {\n      // TODO: Determine how to reconsile the type conflict where `consumer`\n      //       is constructed as a SourceMapConsumer but is used as a\n      //       RawSourceMap.\n      // TODO: Resolve the cast of `contents as any` (This is needed because the\n      //       type is expected to be of `RawSourceMap` but the existing\n      //       working code uses a string.)\n      consumer = yield new sourceMap.SourceMapConsumer(contents);\n    } catch (e) {\n      throw new Error('An error occurred while reading the ' + 'sourceMap file ' + mapPath + ': ' + e);\n    }\n    /*\n     * If the source map file defines a \"file\" attribute, use it as\n     * the output file where the path is relative to the directory\n     * containing the map file.  Otherwise, use the name of the output\n     * file (with the .map extension removed) as the output file.\n     */\n\n\n    const dir = path.dirname(mapPath);\n    const generatedBase = consumer.file ? consumer.file : path.basename(mapPath, MAP_EXT);\n    const generatedPath = path.resolve(dir, generatedBase);\n    infoMap.set(generatedPath, {\n      mapFileDir: dir,\n      mapConsumer: consumer\n    });\n  });\n}\n\nclass SourceMapper {\n  /**\n   * @param {Array.<string>} sourceMapPaths An array of paths to .map source map\n   *  files that should be processed.  The paths should be relative to the\n   *  current process's current working directory\n   * @param {Logger} logger A logger that reports errors that occurred while\n   *  processing the given source map files\n   * @constructor\n   */\n  constructor() {\n    this.infoMap = new Map();\n  }\n\n  static create(searchDirs) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const mapFiles = [];\n\n      for (const dir of searchDirs) {\n        try {\n          const mf = yield getMapFiles(dir);\n          mf.forEach(mapFile => {\n            mapFiles.push(path.resolve(dir, mapFile));\n          });\n        } catch (e) {\n          throw new Error(`failed to get source maps from ${dir}: ${e}`);\n        }\n      }\n\n      return createFromMapFiles(mapFiles);\n    });\n  }\n  /**\n   * Used to get the information about the transpiled file from a given input\n   * source file provided there isn't any ambiguity with associating the input\n   * path to exactly one output transpiled file.\n   *\n   * @param inputPath The (possibly relative) path to the original source file.\n   * @return The `MapInfoCompiled` object that describes the transpiled file\n   *  associated with the specified input path.  `null` is returned if either\n   *  zero files are associated with the input path or if more than one file\n   *  could possibly be associated with the given input path.\n   */\n\n\n  getMappingInfo(inputPath) {\n    if (this.infoMap.has(path.normalize(inputPath))) {\n      return this.infoMap.get(inputPath);\n    }\n\n    return null;\n  }\n  /**\n   * Used to determine if the source file specified by the given path has\n   * a .map file and an output file associated with it.\n   *\n   * If there is no such mapping, it could be because the input file is not\n   * the input to a transpilation process or it is the input to a transpilation\n   * process but its corresponding .map file was not given to the constructor\n   * of this mapper.\n   *\n   * @param {string} inputPath The path to an input file that could\n   *  possibly be the input to a transpilation process.  The path should be\n   *  relative to the process's current working directory.\n   */\n\n\n  hasMappingInfo(inputPath) {\n    return this.getMappingInfo(inputPath) !== null;\n  }\n  /**\n   * @param {string} inputPath The path to an input file that could possibly\n   *  be the input to a transpilation process.  The path should be relative to\n   *  the process's current working directory\n   * @param {number} The line number in the input file where the line number is\n   *   zero-based.\n   * @param {number} (Optional) The column number in the line of the file\n   *   specified where the column number is zero-based.\n   * @return {Object} The object returned has a \"file\" attribute for the\n   *   path of the output file associated with the given input file (where the\n   *   path is relative to the process's current working directory),\n   *   a \"line\" attribute of the line number in the output file associated with\n   *   the given line number for the input file, and an optional \"column\" number\n   *   of the column number of the output file associated with the given file\n   *   and line information.\n   *\n   *   If the given input file does not have mapping information associated\n   *   with it then the input location is returned.\n   */\n\n\n  mappingInfo(location) {\n    const inputPath = path.normalize(location.file);\n    const entry = this.getMappingInfo(inputPath);\n\n    if (entry === null) {\n      return location;\n    }\n\n    const generatedPos = {\n      line: location.line,\n      column: location.column\n    }; // TODO: Determine how to remove the explicit cast here.\n\n    const consumer = entry.mapConsumer;\n    const pos = consumer.originalPositionFor(generatedPos);\n\n    if (pos.source === null) {\n      return location;\n    }\n\n    return {\n      file: path.resolve(entry.mapFileDir, pos.source),\n      line: pos.line || undefined,\n      name: pos.name || location.name,\n      column: pos.column || undefined\n    };\n  }\n\n}\n\nexports.SourceMapper = SourceMapper;\n\nfunction createFromMapFiles(mapFiles) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const limit = pLimit(CONCURRENCY);\n    const mapper = new SourceMapper();\n    const promises = mapFiles.map(mapPath => limit(() => processSourceMap(mapper.infoMap, mapPath)));\n\n    try {\n      yield Promise.all(promises);\n    } catch (err) {\n      throw new Error('An error occurred while processing the source map files' + err);\n    }\n\n    return mapper;\n  });\n}\n\nfunction getMapFiles(baseDir) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const fileStats = yield scanner.scan(false, baseDir, /.js.map$/);\n    const mapFiles = fileStats.selectFiles(/.js.map$/, process.cwd());\n    return mapFiles;\n  });\n}","map":{"version":3,"sources":["../../../ts/src/sourcemapper/sourcemapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SourceMapper = void 0;\n// Originally copied from cloud-debug-nodejs's sourcemapper.ts from\n// https://github.com/googleapis/cloud-debug-nodejs/blob/7bdc2f1f62a3b45b7b53ea79f9444c8ed50e138b/src/agent/io/sourcemapper.ts\n// Modified to map from generated code to source code, rather than from source\n// code to generated code.\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst sourceMap = require(\"source-map\");\nconst scanner = require(\"../../third_party/cloud-debug-nodejs/src/agent/io/scanner\");\nconst pify = require('pify');\nconst pLimit = require('p-limit');\nconst readFile = pify(fs.readFile);\nconst CONCURRENCY = 10;\nconst MAP_EXT = '.map';\n/**\n * @param {!Map} infoMap The map that maps input source files to\n *  SourceMapConsumer objects that are used to calculate mapping information\n * @param {string} mapPath The path to the source map file to process.  The\n *  path should be relative to the process's current working directory\n * @private\n */\nfunction processSourceMap(infoMap, mapPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // this handles the case when the path is undefined, null, or\n        // the empty string\n        if (!mapPath || !mapPath.endsWith(MAP_EXT)) {\n            throw new Error(`The path \"${mapPath}\" does not specify a source map file`);\n        }\n        mapPath = path.normalize(mapPath);\n        let contents;\n        try {\n            contents = yield readFile(mapPath, 'utf8');\n        }\n        catch (e) {\n            throw new Error('Could not read source map file ' + mapPath + ': ' + e);\n        }\n        let consumer;\n        try {\n            // TODO: Determine how to reconsile the type conflict where `consumer`\n            //       is constructed as a SourceMapConsumer but is used as a\n            //       RawSourceMap.\n            // TODO: Resolve the cast of `contents as any` (This is needed because the\n            //       type is expected to be of `RawSourceMap` but the existing\n            //       working code uses a string.)\n            consumer = (yield new sourceMap.SourceMapConsumer(contents));\n        }\n        catch (e) {\n            throw new Error('An error occurred while reading the ' +\n                'sourceMap file ' +\n                mapPath +\n                ': ' +\n                e);\n        }\n        /*\n         * If the source map file defines a \"file\" attribute, use it as\n         * the output file where the path is relative to the directory\n         * containing the map file.  Otherwise, use the name of the output\n         * file (with the .map extension removed) as the output file.\n         */\n        const dir = path.dirname(mapPath);\n        const generatedBase = consumer.file\n            ? consumer.file\n            : path.basename(mapPath, MAP_EXT);\n        const generatedPath = path.resolve(dir, generatedBase);\n        infoMap.set(generatedPath, { mapFileDir: dir, mapConsumer: consumer });\n    });\n}\nclass SourceMapper {\n    /**\n     * @param {Array.<string>} sourceMapPaths An array of paths to .map source map\n     *  files that should be processed.  The paths should be relative to the\n     *  current process's current working directory\n     * @param {Logger} logger A logger that reports errors that occurred while\n     *  processing the given source map files\n     * @constructor\n     */\n    constructor() {\n        this.infoMap = new Map();\n    }\n    static create(searchDirs) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const mapFiles = [];\n            for (const dir of searchDirs) {\n                try {\n                    const mf = yield getMapFiles(dir);\n                    mf.forEach(mapFile => {\n                        mapFiles.push(path.resolve(dir, mapFile));\n                    });\n                }\n                catch (e) {\n                    throw new Error(`failed to get source maps from ${dir}: ${e}`);\n                }\n            }\n            return createFromMapFiles(mapFiles);\n        });\n    }\n    /**\n     * Used to get the information about the transpiled file from a given input\n     * source file provided there isn't any ambiguity with associating the input\n     * path to exactly one output transpiled file.\n     *\n     * @param inputPath The (possibly relative) path to the original source file.\n     * @return The `MapInfoCompiled` object that describes the transpiled file\n     *  associated with the specified input path.  `null` is returned if either\n     *  zero files are associated with the input path or if more than one file\n     *  could possibly be associated with the given input path.\n     */\n    getMappingInfo(inputPath) {\n        if (this.infoMap.has(path.normalize(inputPath))) {\n            return this.infoMap.get(inputPath);\n        }\n        return null;\n    }\n    /**\n     * Used to determine if the source file specified by the given path has\n     * a .map file and an output file associated with it.\n     *\n     * If there is no such mapping, it could be because the input file is not\n     * the input to a transpilation process or it is the input to a transpilation\n     * process but its corresponding .map file was not given to the constructor\n     * of this mapper.\n     *\n     * @param {string} inputPath The path to an input file that could\n     *  possibly be the input to a transpilation process.  The path should be\n     *  relative to the process's current working directory.\n     */\n    hasMappingInfo(inputPath) {\n        return this.getMappingInfo(inputPath) !== null;\n    }\n    /**\n     * @param {string} inputPath The path to an input file that could possibly\n     *  be the input to a transpilation process.  The path should be relative to\n     *  the process's current working directory\n     * @param {number} The line number in the input file where the line number is\n     *   zero-based.\n     * @param {number} (Optional) The column number in the line of the file\n     *   specified where the column number is zero-based.\n     * @return {Object} The object returned has a \"file\" attribute for the\n     *   path of the output file associated with the given input file (where the\n     *   path is relative to the process's current working directory),\n     *   a \"line\" attribute of the line number in the output file associated with\n     *   the given line number for the input file, and an optional \"column\" number\n     *   of the column number of the output file associated with the given file\n     *   and line information.\n     *\n     *   If the given input file does not have mapping information associated\n     *   with it then the input location is returned.\n     */\n    mappingInfo(location) {\n        const inputPath = path.normalize(location.file);\n        const entry = this.getMappingInfo(inputPath);\n        if (entry === null) {\n            return location;\n        }\n        const generatedPos = { line: location.line, column: location.column };\n        // TODO: Determine how to remove the explicit cast here.\n        const consumer = entry.mapConsumer;\n        const pos = consumer.originalPositionFor(generatedPos);\n        if (pos.source === null) {\n            return location;\n        }\n        return {\n            file: path.resolve(entry.mapFileDir, pos.source),\n            line: pos.line || undefined,\n            name: pos.name || location.name,\n            column: pos.column || undefined,\n        };\n    }\n}\nexports.SourceMapper = SourceMapper;\nfunction createFromMapFiles(mapFiles) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const limit = pLimit(CONCURRENCY);\n        const mapper = new SourceMapper();\n        const promises = mapFiles.map(mapPath => limit(() => processSourceMap(mapper.infoMap, mapPath)));\n        try {\n            yield Promise.all(promises);\n        }\n        catch (err) {\n            throw new Error('An error occurred while processing the source map files' + err);\n        }\n        return mapper;\n    });\n}\nfunction getMapFiles(baseDir) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const fileStats = yield scanner.scan(false, baseDir, /.js.map$/);\n        const mapFiles = fileStats.selectFiles(/.js.map$/, process.cwd());\n        return mapFiles;\n    });\n}\n//# sourceMappingURL=sourcemapper.js.map"]},"metadata":{},"sourceType":"script"}