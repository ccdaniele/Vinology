{"ast":null,"code":"\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CollapsingHighestDenseStore = void 0;\n\nvar DenseStore_1 = require(\"./DenseStore\");\n\nvar util_1 = require(\"./util\");\n/**\n * `CollapsingHighestDenseStore` is a dense store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins\n * if the number of bins exceeds `binLimit`\n */\n\n\nvar CollapsingHighestDenseStore =\n/** @class */\nfunction (_super) {\n  __extends(CollapsingHighestDenseStore, _super);\n  /**\n   * Initialize a new CollapsingHighestDenseStore\n   *\n   * @param binLimit The maximum number of bins\n   * @param chunkSize The number of bins to add each time the bins grow (default 128)\n   */\n\n\n  function CollapsingHighestDenseStore(binLimit, chunkSize) {\n    var _this = _super.call(this, chunkSize) || this;\n\n    _this.binLimit = binLimit;\n    _this.isCollapsed = false;\n    return _this;\n  }\n  /**\n   * Merge the contents of the parameter `store` into this store\n   *\n   * @param store The store to merge into the caller store\n   */\n\n\n  CollapsingHighestDenseStore.prototype.merge = function (store) {\n    if (store.count === 0) {\n      return;\n    }\n\n    if (this.count === 0) {\n      this.copy(store);\n      return;\n    }\n\n    if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n      this._extendRange(store.minKey, store.maxKey);\n    }\n\n    var collapseEndIndex = store.maxKey - store.offset + 1;\n    var collapseStartIndex = Math.max(this.maxKey + 1, store.minKey) - store.offset;\n\n    if (collapseEndIndex > collapseStartIndex) {\n      var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);\n      this.bins[this.length() - 1] += collapseCount;\n    } else {\n      collapseStartIndex = collapseEndIndex;\n    }\n\n    for (var key = store.minKey; key < collapseStartIndex + store.offset; key++) {\n      this.bins[key - this.offset] += store.bins[key - store.offset];\n    }\n\n    this.count += store.count;\n  };\n  /**\n   * Directly clone the contents of the parameter `store` into this store\n   *\n   * @param store The store to be copied into the caller store\n   */\n\n\n  CollapsingHighestDenseStore.prototype.copy = function (store) {\n    _super.prototype.copy.call(this, store);\n\n    this.isCollapsed = store.isCollapsed;\n  };\n\n  CollapsingHighestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n    var desiredLength = newMaxKey - newMinKey + 1;\n    return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);\n  };\n  /**\n   * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n   * without resizing the bins, in order to try to make it fit the specified range.\n   * Collapse to the left if necessary\n   */\n\n\n  CollapsingHighestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n    if (newMaxKey - newMinKey + 1 > this.length()) {\n      // The range of keys is too wide, the lowest bins need to be collapsed\n      newMaxKey = newMinKey + this.length() + 1;\n\n      if (newMaxKey <= this.minKey) {\n        // Put everything in the first bin\n        this.offset = newMinKey;\n        this.maxKey = newMaxKey;\n        this.bins.fill(0);\n        this.bins[this.length() - 1] = this.count;\n      } else {\n        var shift = this.offset - newMinKey;\n\n        if (shift > 0) {\n          var collapseStartIndex = newMaxKey - this.offset + 1;\n          var collapseEndIndex = this.maxKey - this.offset + 1;\n          var collapsedCount = util_1.sumOfRange(this.bins, collapseStartIndex, collapseEndIndex);\n          this.bins.fill(0, collapseStartIndex, collapseEndIndex);\n          this.bins[collapseStartIndex - 1] += collapsedCount;\n          this.maxKey = newMaxKey;\n\n          this._shiftBins(shift);\n        } else {\n          this.maxKey = newMaxKey; // Shift the buckets to make room for newMinKey\n\n          this._shiftBins(shift);\n        }\n\n        this.minKey = newMinKey;\n        this.isCollapsed = true;\n      }\n    } else {\n      this._centerBins(newMinKey, newMaxKey);\n\n      this.minKey = newMinKey;\n      this.maxKey = newMaxKey;\n    }\n  };\n  /** Calculate the bin index for the key, extending the range if necessary */\n\n\n  CollapsingHighestDenseStore.prototype._getIndex = function (key) {\n    if (key < this.minKey) {\n      if (this.isCollapsed) {\n        return this.length() - 1;\n      }\n\n      this._extendRange(key);\n\n      if (this.isCollapsed) {\n        return this.length() - 1;\n      }\n    } else if (key > this.maxKey) {\n      this._extendRange(key);\n    }\n\n    return key - this.offset;\n  };\n\n  return CollapsingHighestDenseStore;\n}(DenseStore_1.DenseStore);\n\nexports.CollapsingHighestDenseStore = CollapsingHighestDenseStore;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","defineProperty","exports","value","CollapsingHighestDenseStore","DenseStore_1","require","util_1","_super","binLimit","chunkSize","_this","isCollapsed","merge","store","count","copy","minKey","maxKey","_extendRange","collapseEndIndex","offset","collapseStartIndex","Math","max","collapseCount","sumOfRange","bins","length","key","_getNewLength","newMinKey","newMaxKey","desiredLength","min","ceil","_adjust","fill","shift","collapsedCount","_shiftBins","_centerBins","_getIndex","DenseStore"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollapsingHighestDenseStore = void 0;\nvar DenseStore_1 = require(\"./DenseStore\");\nvar util_1 = require(\"./util\");\n/**\n * `CollapsingHighestDenseStore` is a dense store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins\n * if the number of bins exceeds `binLimit`\n */\nvar CollapsingHighestDenseStore = /** @class */ (function (_super) {\n    __extends(CollapsingHighestDenseStore, _super);\n    /**\n     * Initialize a new CollapsingHighestDenseStore\n     *\n     * @param binLimit The maximum number of bins\n     * @param chunkSize The number of bins to add each time the bins grow (default 128)\n     */\n    function CollapsingHighestDenseStore(binLimit, chunkSize) {\n        var _this = _super.call(this, chunkSize) || this;\n        _this.binLimit = binLimit;\n        _this.isCollapsed = false;\n        return _this;\n    }\n    /**\n     * Merge the contents of the parameter `store` into this store\n     *\n     * @param store The store to merge into the caller store\n     */\n    CollapsingHighestDenseStore.prototype.merge = function (store) {\n        if (store.count === 0) {\n            return;\n        }\n        if (this.count === 0) {\n            this.copy(store);\n            return;\n        }\n        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n            this._extendRange(store.minKey, store.maxKey);\n        }\n        var collapseEndIndex = store.maxKey - store.offset + 1;\n        var collapseStartIndex = Math.max(this.maxKey + 1, store.minKey) - store.offset;\n        if (collapseEndIndex > collapseStartIndex) {\n            var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);\n            this.bins[this.length() - 1] += collapseCount;\n        }\n        else {\n            collapseStartIndex = collapseEndIndex;\n        }\n        for (var key = store.minKey; key < collapseStartIndex + store.offset; key++) {\n            this.bins[key - this.offset] += store.bins[key - store.offset];\n        }\n        this.count += store.count;\n    };\n    /**\n     * Directly clone the contents of the parameter `store` into this store\n     *\n     * @param store The store to be copied into the caller store\n     */\n    CollapsingHighestDenseStore.prototype.copy = function (store) {\n        _super.prototype.copy.call(this, store);\n        this.isCollapsed = store.isCollapsed;\n    };\n    CollapsingHighestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n        var desiredLength = newMaxKey - newMinKey + 1;\n        return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);\n    };\n    /**\n     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n     * without resizing the bins, in order to try to make it fit the specified range.\n     * Collapse to the left if necessary\n     */\n    CollapsingHighestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n        if (newMaxKey - newMinKey + 1 > this.length()) {\n            // The range of keys is too wide, the lowest bins need to be collapsed\n            newMaxKey = newMinKey + this.length() + 1;\n            if (newMaxKey <= this.minKey) {\n                // Put everything in the first bin\n                this.offset = newMinKey;\n                this.maxKey = newMaxKey;\n                this.bins.fill(0);\n                this.bins[this.length() - 1] = this.count;\n            }\n            else {\n                var shift = this.offset - newMinKey;\n                if (shift > 0) {\n                    var collapseStartIndex = newMaxKey - this.offset + 1;\n                    var collapseEndIndex = this.maxKey - this.offset + 1;\n                    var collapsedCount = util_1.sumOfRange(this.bins, collapseStartIndex, collapseEndIndex);\n                    this.bins.fill(0, collapseStartIndex, collapseEndIndex);\n                    this.bins[collapseStartIndex - 1] += collapsedCount;\n                    this.maxKey = newMaxKey;\n                    this._shiftBins(shift);\n                }\n                else {\n                    this.maxKey = newMaxKey;\n                    // Shift the buckets to make room for newMinKey\n                    this._shiftBins(shift);\n                }\n                this.minKey = newMinKey;\n                this.isCollapsed = true;\n            }\n        }\n        else {\n            this._centerBins(newMinKey, newMaxKey);\n            this.minKey = newMinKey;\n            this.maxKey = newMaxKey;\n        }\n    };\n    /** Calculate the bin index for the key, extending the range if necessary */\n    CollapsingHighestDenseStore.prototype._getIndex = function (key) {\n        if (key < this.minKey) {\n            if (this.isCollapsed) {\n                return this.length() - 1;\n            }\n            this._extendRange(key);\n            if (this.isCollapsed) {\n                return this.length() - 1;\n            }\n        }\n        else if (key > this.maxKey) {\n            this._extendRange(key);\n        }\n        return key - this.offset;\n    };\n    return CollapsingHighestDenseStore;\n}(DenseStore_1.DenseStore));\nexports.CollapsingHighestDenseStore = CollapsingHighestDenseStore;\n"]},"metadata":{},"sourceType":"script"}