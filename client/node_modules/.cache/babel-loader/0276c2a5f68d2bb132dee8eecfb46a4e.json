{"ast":null,"code":"'use strict';\n\nconst {\n  LOG\n} = require('../../../ext/formats');\n\nfunction createWrapWrite(tracer, config) {\n  return function wrapWrite(write) {\n    return function writeWithTrace(chunk, encoding, callback) {\n      const span = tracer.scope().active();\n      tracer.inject(span, LOG, chunk);\n      const result = write.apply(this, arguments);\n      delete chunk.dd;\n      return result;\n    };\n  };\n}\n\nfunction createWrapMethod(tracer, config) {\n  return function wrapMethod(method) {\n    return function methodWithTrace() {\n      const result = method.apply(this, arguments);\n\n      for (const name in this.transports) {\n        const transport = this.transports[name];\n        if (transport._dd_patched || typeof transport.log !== 'function') continue;\n        transport.log = createWrapLog(tracer, config)(transport.log);\n        transport._dd_patched = true;\n      }\n\n      return result;\n    };\n  };\n}\n\nfunction createWrapLog(tracer, config) {\n  return function wrapLog(log) {\n    return function logWithTrace(level, msg, meta, callback) {\n      const span = tracer.scope().active();\n      meta = arguments[2] = meta || {};\n      tracer.inject(span, LOG, meta);\n      const result = log.apply(this, arguments);\n      delete meta.dd;\n      return result;\n    };\n  };\n}\n\nmodule.exports = [{\n  name: 'winston',\n  file: 'lib/winston/logger.js',\n  versions: ['>=3'],\n\n  patch(Logger, tracer, config) {\n    if (!tracer._logInjection) return;\n    this.wrap(Logger.prototype, 'write', createWrapWrite(tracer, config));\n  },\n\n  unpatch(Logger) {\n    this.unwrap(Logger.prototype, 'write');\n  }\n\n}, {\n  name: 'winston',\n  file: 'lib/winston/logger.js',\n  versions: ['2'],\n\n  patch(logger, tracer, config) {\n    if (!tracer._logInjection) return;\n    this.wrap(logger.Logger.prototype, 'configure', createWrapMethod(tracer, config));\n    this.wrap(logger.Logger.prototype, 'add', createWrapMethod(tracer, config));\n  },\n\n  unpatch(logger) {\n    this.unwrap(logger.Logger.prototype, 'configure');\n    this.unwrap(logger.Logger.prototype, 'add');\n  }\n\n}, {\n  name: 'winston',\n  file: 'lib/winston/logger.js',\n  versions: ['1'],\n\n  patch(logger, tracer, config) {\n    if (!tracer._logInjection) return;\n    this.wrap(logger.Logger.prototype, 'add', createWrapMethod(tracer, config));\n  },\n\n  unpatch(logger) {\n    this.unwrap(logger.Logger.prototype, 'add');\n  }\n\n}];","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-winston/src/index.js"],"names":["LOG","require","createWrapWrite","tracer","config","wrapWrite","write","writeWithTrace","chunk","encoding","callback","span","scope","active","inject","result","apply","arguments","dd","createWrapMethod","wrapMethod","method","methodWithTrace","name","transports","transport","_dd_patched","log","createWrapLog","wrapLog","logWithTrace","level","msg","meta","module","exports","file","versions","patch","Logger","_logInjection","wrap","prototype","unpatch","unwrap","logger"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { LOG } = require('../../../ext/formats')\n\nfunction createWrapWrite (tracer, config) {\n  return function wrapWrite (write) {\n    return function writeWithTrace (chunk, encoding, callback) {\n      const span = tracer.scope().active()\n\n      tracer.inject(span, LOG, chunk)\n\n      const result = write.apply(this, arguments)\n\n      delete chunk.dd\n\n      return result\n    }\n  }\n}\n\nfunction createWrapMethod (tracer, config) {\n  return function wrapMethod (method) {\n    return function methodWithTrace () {\n      const result = method.apply(this, arguments)\n\n      for (const name in this.transports) {\n        const transport = this.transports[name]\n\n        if (transport._dd_patched || typeof transport.log !== 'function') continue\n\n        transport.log = createWrapLog(tracer, config)(transport.log)\n        transport._dd_patched = true\n      }\n\n      return result\n    }\n  }\n}\n\nfunction createWrapLog (tracer, config) {\n  return function wrapLog (log) {\n    return function logWithTrace (level, msg, meta, callback) {\n      const span = tracer.scope().active()\n\n      meta = arguments[2] = meta || {}\n\n      tracer.inject(span, LOG, meta)\n\n      const result = log.apply(this, arguments)\n\n      delete meta.dd\n\n      return result\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'winston',\n    file: 'lib/winston/logger.js',\n    versions: ['>=3'],\n    patch (Logger, tracer, config) {\n      if (!tracer._logInjection) return\n      this.wrap(Logger.prototype, 'write', createWrapWrite(tracer, config))\n    },\n    unpatch (Logger) {\n      this.unwrap(Logger.prototype, 'write')\n    }\n  },\n  {\n    name: 'winston',\n    file: 'lib/winston/logger.js',\n    versions: ['2'],\n    patch (logger, tracer, config) {\n      if (!tracer._logInjection) return\n      this.wrap(logger.Logger.prototype, 'configure', createWrapMethod(tracer, config))\n      this.wrap(logger.Logger.prototype, 'add', createWrapMethod(tracer, config))\n    },\n    unpatch (logger) {\n      this.unwrap(logger.Logger.prototype, 'configure')\n      this.unwrap(logger.Logger.prototype, 'add')\n    }\n  },\n  {\n    name: 'winston',\n    file: 'lib/winston/logger.js',\n    versions: ['1'],\n    patch (logger, tracer, config) {\n      if (!tracer._logInjection) return\n      this.wrap(logger.Logger.prototype, 'add', createWrapMethod(tracer, config))\n    },\n    unpatch (logger) {\n      this.unwrap(logger.Logger.prototype, 'add')\n    }\n  }\n]\n"]},"metadata":{},"sourceType":"script"}