{"ast":null,"code":"'use strict';\n\nconst Tracer = require('./opentracing/tracer');\n\nconst tags = require('../../../ext/tags');\n\nconst scopes = require('../../../ext/scopes');\n\nconst getScope = require('./scope');\n\nconst {\n  isError\n} = require('./util');\n\nconst {\n  setStartupLogConfig\n} = require('./startup-log');\n\nconst SPAN_TYPE = tags.SPAN_TYPE;\nconst RESOURCE_NAME = tags.RESOURCE_NAME;\nconst SERVICE_NAME = tags.SERVICE_NAME;\nconst MEASURED = tags.MEASURED;\nconst NOOP = scopes.NOOP;\n\nclass DatadogTracer extends Tracer {\n  constructor(config) {\n    super(config);\n    const Scope = getScope(config.scope);\n    this._scopeManager = getScopeManager(config);\n    this._scope = new Scope(config);\n    setStartupLogConfig(config);\n  }\n\n  trace(name, options, fn) {\n    options = Object.assign({}, {\n      childOf: this.scope().active()\n    }, options);\n\n    if (!options.childOf && options.orphanable === false) {\n      return fn(null, () => {});\n    }\n\n    const span = this.startSpan(name, options);\n    addTags(span, options);\n\n    try {\n      if (fn.length > 1) {\n        return this.scope().activate(span, () => fn(span, err => {\n          addError(span, err);\n          span.finish();\n        }));\n      }\n\n      const result = this.scope().activate(span, () => fn(span));\n\n      if (result && typeof result.then === 'function') {\n        result.then(() => span.finish(), err => {\n          addError(span, err);\n          span.finish();\n        });\n      } else {\n        span.finish();\n      }\n\n      return result;\n    } catch (e) {\n      addError(span, e);\n      span.finish();\n      throw e;\n    }\n  }\n\n  wrap(name, options, fn) {\n    const tracer = this;\n    return function () {\n      let optionsObj = options;\n\n      if (typeof optionsObj === 'function' && typeof fn === 'function') {\n        optionsObj = optionsObj.apply(this, arguments);\n      }\n\n      if (optionsObj && optionsObj.orphanable === false && !tracer.scope().active()) {\n        return fn.apply(this, arguments);\n      }\n\n      const lastArgId = arguments.length - 1;\n      const cb = arguments[lastArgId];\n\n      if (typeof cb === 'function') {\n        const scopeBoundCb = tracer.scope().bind(cb);\n        return tracer.trace(name, optionsObj, (span, done) => {\n          arguments[lastArgId] = function (err) {\n            done(err);\n            return scopeBoundCb.apply(this, arguments);\n          };\n\n          return fn.apply(this, arguments);\n        });\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments));\n      }\n    };\n  }\n\n  setUrl(url) {\n    this._exporter.setUrl(url);\n  }\n\n  scopeManager() {\n    return this._scopeManager;\n  }\n\n  scope() {\n    return this._scope;\n  }\n\n  currentSpan() {\n    return this.scope().active();\n  }\n\n  getRumData() {\n    if (!this._enableGetRumData) {\n      return '';\n    }\n\n    const span = this.scope().active().context();\n    const traceId = span.toTraceId();\n    const traceTime = Date.now();\n    return `\\\n<meta name=\"dd-trace-id\" content=\"${traceId}\" />\\\n<meta name=\"dd-trace-time\" content=\"${traceTime}\" />`;\n  }\n\n}\n\nfunction addError(span, error) {\n  if (isError(error)) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    });\n  }\n}\n\nfunction addTags(span, options) {\n  const tags = {};\n  if (options.type) tags[SPAN_TYPE] = options.type;\n  if (options.service) tags[SERVICE_NAME] = options.service;\n  if (options.resource) tags[RESOURCE_NAME] = options.resource;\n  tags[MEASURED] = options.measured;\n  span.addTags(tags);\n}\n\nfunction getScopeManager(config) {\n  let ScopeManager;\n\n  if (config.scope === NOOP) {\n    ScopeManager = require('./scope/noop/scope_manager');\n  } else {\n    ScopeManager = require('./scope/scope_manager');\n  }\n\n  return new ScopeManager();\n}\n\nmodule.exports = DatadogTracer;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/tracer.js"],"names":["Tracer","require","tags","scopes","getScope","isError","setStartupLogConfig","SPAN_TYPE","RESOURCE_NAME","SERVICE_NAME","MEASURED","NOOP","DatadogTracer","constructor","config","Scope","scope","_scopeManager","getScopeManager","_scope","trace","name","options","fn","Object","assign","childOf","active","orphanable","span","startSpan","addTags","length","activate","err","addError","finish","result","then","e","wrap","tracer","optionsObj","apply","arguments","lastArgId","cb","scopeBoundCb","bind","done","setUrl","url","_exporter","scopeManager","currentSpan","getRumData","_enableGetRumData","context","traceId","toTraceId","traceTime","Date","now","error","message","stack","type","service","resource","measured","ScopeManager","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Tracer = require('./opentracing/tracer')\nconst tags = require('../../../ext/tags')\nconst scopes = require('../../../ext/scopes')\nconst getScope = require('./scope')\nconst { isError } = require('./util')\nconst { setStartupLogConfig } = require('./startup-log')\n\nconst SPAN_TYPE = tags.SPAN_TYPE\nconst RESOURCE_NAME = tags.RESOURCE_NAME\nconst SERVICE_NAME = tags.SERVICE_NAME\nconst MEASURED = tags.MEASURED\nconst NOOP = scopes.NOOP\n\nclass DatadogTracer extends Tracer {\n  constructor (config) {\n    super(config)\n\n    const Scope = getScope(config.scope)\n\n    this._scopeManager = getScopeManager(config)\n    this._scope = new Scope(config)\n    setStartupLogConfig(config)\n  }\n\n  trace (name, options, fn) {\n    options = Object.assign({}, {\n      childOf: this.scope().active()\n    }, options)\n\n    if (!options.childOf && options.orphanable === false) {\n      return fn(null, () => {})\n    }\n\n    const span = this.startSpan(name, options)\n\n    addTags(span, options)\n\n    try {\n      if (fn.length > 1) {\n        return this.scope().activate(span, () => fn(span, err => {\n          addError(span, err)\n          span.finish()\n        }))\n      }\n\n      const result = this.scope().activate(span, () => fn(span))\n\n      if (result && typeof result.then === 'function') {\n        result.then(\n          () => span.finish(),\n          err => {\n            addError(span, err)\n            span.finish()\n          }\n        )\n      } else {\n        span.finish()\n      }\n\n      return result\n    } catch (e) {\n      addError(span, e)\n      span.finish()\n      throw e\n    }\n  }\n\n  wrap (name, options, fn) {\n    const tracer = this\n\n    return function () {\n      let optionsObj = options\n      if (typeof optionsObj === 'function' && typeof fn === 'function') {\n        optionsObj = optionsObj.apply(this, arguments)\n      }\n\n      if (optionsObj && optionsObj.orphanable === false && !tracer.scope().active()) {\n        return fn.apply(this, arguments)\n      }\n\n      const lastArgId = arguments.length - 1\n      const cb = arguments[lastArgId]\n\n      if (typeof cb === 'function') {\n        const scopeBoundCb = tracer.scope().bind(cb)\n        return tracer.trace(name, optionsObj, (span, done) => {\n          arguments[lastArgId] = function (err) {\n            done(err)\n            return scopeBoundCb.apply(this, arguments)\n          }\n\n          return fn.apply(this, arguments)\n        })\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments))\n      }\n    }\n  }\n\n  setUrl (url) {\n    this._exporter.setUrl(url)\n  }\n\n  scopeManager () {\n    return this._scopeManager\n  }\n\n  scope () {\n    return this._scope\n  }\n\n  currentSpan () {\n    return this.scope().active()\n  }\n\n  getRumData () {\n    if (!this._enableGetRumData) {\n      return ''\n    }\n    const span = this.scope().active().context()\n    const traceId = span.toTraceId()\n    const traceTime = Date.now()\n    return `\\\n<meta name=\"dd-trace-id\" content=\"${traceId}\" />\\\n<meta name=\"dd-trace-time\" content=\"${traceTime}\" />`\n  }\n}\n\nfunction addError (span, error) {\n  if (isError(error)) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    })\n  }\n}\n\nfunction addTags (span, options) {\n  const tags = {}\n\n  if (options.type) tags[SPAN_TYPE] = options.type\n  if (options.service) tags[SERVICE_NAME] = options.service\n  if (options.resource) tags[RESOURCE_NAME] = options.resource\n\n  tags[MEASURED] = options.measured\n\n  span.addTags(tags)\n}\n\nfunction getScopeManager (config) {\n  let ScopeManager\n\n  if (config.scope === NOOP) {\n    ScopeManager = require('./scope/noop/scope_manager')\n  } else {\n    ScopeManager = require('./scope/scope_manager')\n  }\n\n  return new ScopeManager()\n}\n\nmodule.exports = DatadogTracer\n"]},"metadata":{},"sourceType":"script"}