{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst Module = require('module');\n\nconst parse = require('module-details-from-path');\n\nmodule.exports = function hook(modules, onrequire) {\n  if (!hook.orig) {\n    hook.orig = Module.prototype.require;\n\n    Module.prototype.require = function (request) {\n      return hook.require.apply(this, arguments);\n    };\n  }\n\n  hook.cache = {};\n  const patching = {};\n\n  hook.require = function (request) {\n    const filename = Module._resolveFilename(request, this);\n\n    const core = filename.indexOf(path.sep) === -1;\n    let name, basedir; // return known patched modules immediately\n\n    if (hook.cache.hasOwnProperty(filename)) {\n      // require.cache was potentially altered externally\n      if (require.cache[filename] && require.cache[filename].exports !== hook.cache[filename].original) {\n        return require.cache[filename].exports;\n      }\n\n      return hook.cache[filename].exports;\n    } // Check if this module has a patcher in-progress already.\n    // Otherwise, mark this module as patching in-progress.\n\n\n    const patched = patching[filename];\n\n    if (!patched) {\n      patching[filename] = true;\n    }\n\n    const exports = hook.orig.apply(this, arguments); // If it's already patched, just return it as-is.\n\n    if (patched) return exports; // The module has already been loaded,\n    // so the patching mark can be cleaned up.\n\n    delete patching[filename];\n\n    if (core) {\n      if (modules && modules.indexOf(filename) === -1) return exports; // abort if module name isn't on whitelist\n\n      name = filename;\n    } else {\n      const stat = parse(filename);\n      if (!stat) return exports; // abort if filename could not be parsed\n\n      name = stat.name;\n      basedir = stat.basedir;\n      if (modules && modules.indexOf(name) === -1) return exports; // abort if module name isn't on whitelist\n      // figure out if this is the main module file, or a file inside the module\n\n      const paths = Module._resolveLookupPaths(name, this, true);\n\n      if (!paths) {\n        // abort if _resolveLookupPaths return null\n        return exports;\n      }\n\n      const res = Module._findPath(name, [basedir, ...paths]);\n\n      if (res !== filename) {\n        // this is a module-internal file\n        // use the module-relative path to the file, prefixed by original module name\n        name = name + path.sep + path.relative(basedir, filename);\n      }\n    } // ensure that the cache entry is assigned a value before calling\n    // onrequire, in case calling onrequire requires the same module.\n\n\n    hook.cache[filename] = {\n      exports\n    };\n    hook.cache[filename].original = exports;\n    hook.cache[filename].exports = onrequire(exports, name, basedir);\n    return hook.cache[filename].exports;\n  };\n};","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/ritm.js"],"names":["path","require","Module","parse","module","exports","hook","modules","onrequire","orig","prototype","request","apply","arguments","cache","patching","filename","_resolveFilename","core","indexOf","sep","name","basedir","hasOwnProperty","original","patched","stat","paths","_resolveLookupPaths","res","_findPath","relative"],"mappings":"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","sourcesContent":["'use strict'\n\nconst path = require('path')\nconst Module = require('module')\nconst parse = require('module-details-from-path')\n\nmodule.exports = function hook (modules, onrequire) {\n  if (!hook.orig) {\n    hook.orig = Module.prototype.require\n\n    Module.prototype.require = function (request) {\n      return hook.require.apply(this, arguments)\n    }\n  }\n\n  hook.cache = {}\n\n  const patching = {}\n\n  hook.require = function (request) {\n    const filename = Module._resolveFilename(request, this)\n    const core = filename.indexOf(path.sep) === -1\n    let name, basedir\n\n    // return known patched modules immediately\n    if (hook.cache.hasOwnProperty(filename)) {\n      // require.cache was potentially altered externally\n      if (require.cache[filename] && require.cache[filename].exports !== hook.cache[filename].original) {\n        return require.cache[filename].exports\n      }\n\n      return hook.cache[filename].exports\n    }\n\n    // Check if this module has a patcher in-progress already.\n    // Otherwise, mark this module as patching in-progress.\n    const patched = patching[filename]\n    if (!patched) {\n      patching[filename] = true\n    }\n\n    const exports = hook.orig.apply(this, arguments)\n\n    // If it's already patched, just return it as-is.\n    if (patched) return exports\n\n    // The module has already been loaded,\n    // so the patching mark can be cleaned up.\n    delete patching[filename]\n\n    if (core) {\n      if (modules && modules.indexOf(filename) === -1) return exports // abort if module name isn't on whitelist\n      name = filename\n    } else {\n      const stat = parse(filename)\n      if (!stat) return exports // abort if filename could not be parsed\n      name = stat.name\n      basedir = stat.basedir\n\n      if (modules && modules.indexOf(name) === -1) return exports // abort if module name isn't on whitelist\n\n      // figure out if this is the main module file, or a file inside the module\n      const paths = Module._resolveLookupPaths(name, this, true)\n      if (!paths) {\n        // abort if _resolveLookupPaths return null\n        return exports\n      }\n      const res = Module._findPath(name, [basedir, ...paths])\n      if (res !== filename) {\n        // this is a module-internal file\n        // use the module-relative path to the file, prefixed by original module name\n        name = name + path.sep + path.relative(basedir, filename)\n      }\n    }\n\n    // ensure that the cache entry is assigned a value before calling\n    // onrequire, in case calling onrequire requires the same module.\n    hook.cache[filename] = { exports }\n    hook.cache[filename].original = exports\n    hook.cache[filename].exports = onrequire(exports, name, basedir)\n\n    return hook.cache[filename].exports\n  }\n}\n"]},"metadata":{},"sourceType":"script"}