{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst {\n  Config\n} = require('./config');\n\nconst {\n  SourceMapper\n} = require('./mapper');\n\nclass Profiler extends EventEmitter {\n  constructor() {\n    super();\n    this._enabled = false;\n    this._logger = undefined;\n    this._config = undefined;\n    this._timer = undefined;\n    this._lastStart = undefined;\n  }\n\n  start(options) {\n    if (this._enabled) return;\n    const config = this._config = new Config(options);\n    if (!config.enabled) return;\n    this._logger = config.logger;\n    this._enabled = true;\n\n    try {\n      const mapper = config.sourceMap ? new SourceMapper() : null;\n\n      for (const profiler of config.profilers) {\n        // TODO: move this out of Profiler when restoring sourcemap support\n        profiler.start({\n          mapper\n        });\n\n        this._logger.debug(`Started ${profiler.type} profiler`);\n      }\n\n      this._capture(config.flushInterval);\n    } catch (e) {\n      this._logger.error(e);\n\n      this.stop();\n    }\n\n    return this;\n  }\n\n  stop() {\n    if (!this._enabled) return;\n    this._enabled = false;\n\n    for (const profiler of this._config.profilers) {\n      profiler.stop();\n\n      this._logger.debug(`Stopped ${profiler.type} profiler`);\n    }\n\n    clearTimeout(this._timer);\n    this._timer = undefined;\n    return this;\n  }\n\n  _capture(timeout) {\n    if (!this._enabled) return;\n    this._lastStart = new Date();\n\n    if (!this._timer || timeout !== this._config.flushInterval) {\n      this._timer = setTimeout(() => this._collect(), timeout);\n\n      this._timer.unref();\n    } else {\n      this._timer.refresh();\n    }\n  }\n\n  async _collect() {\n    const start = this._lastStart;\n    const end = new Date();\n    const profiles = {};\n\n    try {\n      for (const profiler of this._config.profilers) {\n        const profile = profiler.profile();\n        if (!profile) continue;\n        profiles[profiler.type] = await profiler.encode(profile);\n\n        this._logger.debug(`Collected ${profiler.type} profile: ` + JSON.stringify(profile));\n      }\n\n      this._capture(this._config.flushInterval);\n\n      await this._submit(profiles, start, end);\n\n      this._logger.debug('Submitted profiles');\n    } catch (err) {\n      this._logger.error(err);\n\n      this.stop();\n    }\n  }\n\n  _submit(profiles, start, end) {\n    if (!Object.keys(profiles).length) {\n      return Promise.reject(new Error('No profiles to submit'));\n    }\n\n    const {\n      tags\n    } = this._config;\n    const tasks = [];\n\n    for (const exporter of this._config.exporters) {\n      const task = exporter.export({\n        profiles,\n        start,\n        end,\n        tags\n      }).catch(err => this._logger.error(err));\n      tasks.push(task);\n    }\n\n    return Promise.all(tasks);\n  }\n\n}\n\nmodule.exports = {\n  Profiler\n};","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/profiling/profiler.js"],"names":["EventEmitter","require","Config","SourceMapper","Profiler","constructor","_enabled","_logger","undefined","_config","_timer","_lastStart","start","options","config","enabled","logger","mapper","sourceMap","profiler","profilers","debug","type","_capture","flushInterval","e","error","stop","clearTimeout","timeout","Date","setTimeout","_collect","unref","refresh","end","profiles","profile","encode","JSON","stringify","_submit","err","Object","keys","length","Promise","reject","Error","tags","tasks","exporter","exporters","task","export","catch","push","all","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { EventEmitter } = require('events')\nconst { Config } = require('./config')\nconst { SourceMapper } = require('./mapper')\n\nclass Profiler extends EventEmitter {\n  constructor () {\n    super()\n    this._enabled = false\n    this._logger = undefined\n    this._config = undefined\n    this._timer = undefined\n    this._lastStart = undefined\n  }\n\n  start (options) {\n    if (this._enabled) return\n\n    const config = this._config = new Config(options)\n\n    if (!config.enabled) return\n\n    this._logger = config.logger\n\n    this._enabled = true\n\n    try {\n      const mapper = config.sourceMap ? new SourceMapper() : null\n\n      for (const profiler of config.profilers) {\n        // TODO: move this out of Profiler when restoring sourcemap support\n        profiler.start({ mapper })\n        this._logger.debug(`Started ${profiler.type} profiler`)\n      }\n\n      this._capture(config.flushInterval)\n    } catch (e) {\n      this._logger.error(e)\n      this.stop()\n    }\n\n    return this\n  }\n\n  stop () {\n    if (!this._enabled) return\n\n    this._enabled = false\n\n    for (const profiler of this._config.profilers) {\n      profiler.stop()\n      this._logger.debug(`Stopped ${profiler.type} profiler`)\n    }\n\n    clearTimeout(this._timer)\n    this._timer = undefined\n\n    return this\n  }\n\n  _capture (timeout) {\n    if (!this._enabled) return\n    this._lastStart = new Date()\n\n    if (!this._timer || timeout !== this._config.flushInterval) {\n      this._timer = setTimeout(() => this._collect(), timeout)\n      this._timer.unref()\n    } else {\n      this._timer.refresh()\n    }\n  }\n\n  async _collect () {\n    const start = this._lastStart\n    const end = new Date()\n    const profiles = {}\n\n    try {\n      for (const profiler of this._config.profilers) {\n        const profile = profiler.profile()\n        if (!profile) continue\n\n        profiles[profiler.type] = await profiler.encode(profile)\n        this._logger.debug(`Collected ${profiler.type} profile: ` + JSON.stringify(profile))\n      }\n\n      this._capture(this._config.flushInterval)\n      await this._submit(profiles, start, end)\n      this._logger.debug('Submitted profiles')\n    } catch (err) {\n      this._logger.error(err)\n      this.stop()\n    }\n  }\n\n  _submit (profiles, start, end) {\n    if (!Object.keys(profiles).length) {\n      return Promise.reject(new Error('No profiles to submit'))\n    }\n    const { tags } = this._config\n    const tasks = []\n\n    for (const exporter of this._config.exporters) {\n      const task = exporter.export({ profiles, start, end, tags })\n        .catch(err => this._logger.error(err))\n\n      tasks.push(task)\n    }\n\n    return Promise.all(tasks)\n  }\n}\n\nmodule.exports = { Profiler }\n"]},"metadata":{},"sourceType":"script"}