{"ast":null,"code":"'use strict';\n\nconst shimmer = require('../../datadog-shimmer');\n\nconst log = require('./log');\n\nconst metrics = require('./metrics');\n\nconst Loader = require('./loader');\n\nconst {\n  isTrue\n} = require('./util');\n\nconst plugins = require('./plugins');\n\nconst disabledPlugins = process.env.DD_TRACE_DISABLED_PLUGINS;\n\nconst collectDisabledPlugins = () => {\n  return new Set(disabledPlugins && disabledPlugins.split(',').map(plugin => plugin.trim()));\n};\n\nfunction cleanEnv(name) {\n  return process.env[`DD_TRACE_${name.toUpperCase()}`.replace(/[^a-z0-9_]/ig, '_')];\n}\n\nfunction getConfig(name, config = {}) {\n  if (!name) {\n    return config;\n  }\n\n  const enabled = cleanEnv(`${name}_ENABLED`);\n\n  if (enabled !== undefined) {\n    config.enabled = isTrue(enabled);\n  }\n\n  return config;\n}\n\nclass Instrumenter {\n  constructor(tracer) {\n    this._tracer = tracer;\n    this._loader = new Loader(this);\n    this._enabled = false;\n    this._names = new Set();\n    this._plugins = new Map();\n    this._instrumented = new Map();\n    this._disabledPlugins = collectDisabledPlugins();\n  }\n\n  use(name, config) {\n    if (typeof config === 'boolean') {\n      config = {\n        enabled: config\n      };\n    }\n\n    config = getConfig(name, config);\n\n    try {\n      this._set(plugins[name.toLowerCase()], {\n        name,\n        config\n      });\n    } catch (e) {\n      log.debug(`Could not find a plugin named \"${name}\".`);\n    }\n\n    if (this._enabled) {\n      this._loader.reload(this._plugins);\n    }\n  }\n\n  enable(config) {\n    config = config || {};\n    const serviceMapping = config.serviceMapping;\n    this._enabled = true;\n\n    if (config.plugins !== false) {\n      Object.keys(plugins).filter(name => !this._plugins.has(plugins[name])).forEach(name => {\n        const pluginConfig = {};\n\n        if (serviceMapping && serviceMapping[name]) {\n          pluginConfig.service = serviceMapping[name];\n        }\n\n        this._set(plugins[name], {\n          name,\n          config: getConfig(name, pluginConfig)\n        });\n      });\n    }\n\n    this._loader.reload(this._plugins);\n  }\n\n  disable() {\n    for (const instrumentation of this._instrumented.keys()) {\n      this.unpatch(instrumentation);\n    }\n\n    this._plugins.clear();\n\n    this._enabled = false;\n\n    this._loader.reload(this._plugins);\n  }\n\n  wrap(nodules, names, wrapper) {\n    shimmer.massWrap(nodules, names, wrapper);\n  }\n\n  unwrap(nodules, names, wrapper) {\n    shimmer.massUnwrap(nodules, names, wrapper);\n  }\n\n  wrapExport(moduleExports, wrapper) {\n    return shimmer.wrap(moduleExports, wrapper);\n  }\n\n  unwrapExport(moduleExports) {\n    return shimmer.unwrap(moduleExports);\n  }\n\n  load(plugin, meta) {\n    if (!this._enabled) return;\n    const instrumentations = [].concat(plugin);\n    const enabled = meta.config.enabled !== false;\n    metrics.boolean(`datadog.tracer.node.plugin.enabled.by.name`, enabled, `name:${meta.name}`);\n\n    try {\n      instrumentations.forEach(instrumentation => {\n        this._loader.load(instrumentation, meta.config);\n      });\n    } catch (e) {\n      log.error(e);\n      this.unload(plugin);\n      log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`);\n      metrics.increment(`datadog.tracer.node.plugin.errors`, true);\n    }\n  }\n\n  unload(plugin) {\n    [].concat(plugin).forEach(instrumentation => {\n      this.unpatch(instrumentation);\n\n      this._instrumented.delete(instrumentation);\n    });\n\n    const meta = this._plugins.get(plugin);\n\n    if (meta) {\n      this._plugins.delete(plugin);\n\n      metrics.boolean(`datadog.tracer.node.plugin.enabled.by.name`, false, `name:${meta.name}`);\n    }\n  }\n\n  patch(instrumentation, moduleExports, config) {\n    let instrumented = this._instrumented.get(instrumentation);\n\n    if (!instrumented) {\n      this._instrumented.set(instrumentation, instrumented = new Set());\n    }\n\n    if (!instrumented.has(this._defaultExport(moduleExports))) {\n      try {\n        moduleExports = instrumentation.patch.call(this, moduleExports, this._tracer._tracer, config) || moduleExports;\n        return moduleExports;\n      } finally {\n        // add even on error since `unpatch` will take care of removing it.\n        instrumented.add(this._defaultExport(moduleExports));\n      }\n    }\n  }\n\n  unpatch(instrumentation) {\n    const instrumented = this._instrumented.get(instrumentation);\n\n    if (instrumented) {\n      instrumented.forEach(moduleExports => {\n        try {\n          instrumentation.unpatch.call(this, moduleExports, this._tracer);\n        } catch (e) {\n          log.error(e);\n        }\n      });\n    }\n  }\n\n  _set(plugin, meta) {\n    if (this._disabledPlugins.has(meta.name)) {\n      log.debug(`Plugin \"${meta.name}\" was disabled via configuration option.`);\n    } else {\n      this._plugins.set(plugin, meta);\n\n      this.load(plugin, meta);\n    }\n  } // ESM modules have a different export between `import` and `require` so we\n  // use the default export instead when available.\n\n\n  _defaultExport(moduleExports) {\n    return moduleExports && (moduleExports.default || moduleExports);\n  }\n\n}\n\nmodule.exports = Instrumenter;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/instrumenter.js"],"names":["shimmer","require","log","metrics","Loader","isTrue","plugins","disabledPlugins","process","env","DD_TRACE_DISABLED_PLUGINS","collectDisabledPlugins","Set","split","map","plugin","trim","cleanEnv","name","toUpperCase","replace","getConfig","config","enabled","undefined","Instrumenter","constructor","tracer","_tracer","_loader","_enabled","_names","_plugins","Map","_instrumented","_disabledPlugins","use","_set","toLowerCase","e","debug","reload","enable","serviceMapping","Object","keys","filter","has","forEach","pluginConfig","service","disable","instrumentation","unpatch","clear","wrap","nodules","names","wrapper","massWrap","unwrap","massUnwrap","wrapExport","moduleExports","unwrapExport","load","meta","instrumentations","concat","boolean","error","unload","increment","delete","get","patch","instrumented","set","_defaultExport","call","add","default","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,uBAAD,CAAvB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAM;AAAEI,EAAAA;AAAF,IAAaJ,OAAO,CAAC,QAAD,CAA1B;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,WAAD,CAAvB;;AAEA,MAAMM,eAAe,GAAGC,OAAO,CAACC,GAAR,CAAYC,yBAApC;;AAEA,MAAMC,sBAAsB,GAAG,MAAM;AACnC,SAAO,IAAIC,GAAJ,CAAQL,eAAe,IAAIA,eAAe,CAACM,KAAhB,CAAsB,GAAtB,EAA2BC,GAA3B,CAA+BC,MAAM,IAAIA,MAAM,CAACC,IAAP,EAAzC,CAA3B,CAAP;AACD,CAFD;;AAIA,SAASC,QAAT,CAAmBC,IAAnB,EAAyB;AACvB,SAAOV,OAAO,CAACC,GAAR,CAAa,YAAWS,IAAI,CAACC,WAAL,EAAmB,EAA/B,CAAiCC,OAAjC,CAAyC,cAAzC,EAAyD,GAAzD,CAAZ,CAAP;AACD;;AAED,SAASC,SAAT,CAAoBH,IAApB,EAA0BI,MAAM,GAAG,EAAnC,EAAuC;AACrC,MAAI,CAACJ,IAAL,EAAW;AACT,WAAOI,MAAP;AACD;;AAED,QAAMC,OAAO,GAAGN,QAAQ,CAAE,GAAEC,IAAK,UAAT,CAAxB;;AACA,MAAIK,OAAO,KAAKC,SAAhB,EAA2B;AACzBF,IAAAA,MAAM,CAACC,OAAP,GAAiBlB,MAAM,CAACkB,OAAD,CAAvB;AACD;;AAED,SAAOD,MAAP;AACD;;AAED,MAAMG,YAAN,CAAmB;AACjBC,EAAAA,WAAW,CAAEC,MAAF,EAAU;AACnB,SAAKC,OAAL,GAAeD,MAAf;AACA,SAAKE,OAAL,GAAe,IAAIzB,MAAJ,CAAW,IAAX,CAAf;AACA,SAAK0B,QAAL,GAAgB,KAAhB;AACA,SAAKC,MAAL,GAAc,IAAInB,GAAJ,EAAd;AACA,SAAKoB,QAAL,GAAgB,IAAIC,GAAJ,EAAhB;AACA,SAAKC,aAAL,GAAqB,IAAID,GAAJ,EAArB;AACA,SAAKE,gBAAL,GAAwBxB,sBAAsB,EAA9C;AACD;;AAEDyB,EAAAA,GAAG,CAAElB,IAAF,EAAQI,MAAR,EAAgB;AACjB,QAAI,OAAOA,MAAP,KAAkB,SAAtB,EAAiC;AAC/BA,MAAAA,MAAM,GAAG;AAAEC,QAAAA,OAAO,EAAED;AAAX,OAAT;AACD;;AAEDA,IAAAA,MAAM,GAAGD,SAAS,CAACH,IAAD,EAAOI,MAAP,CAAlB;;AAEA,QAAI;AACF,WAAKe,IAAL,CAAU/B,OAAO,CAACY,IAAI,CAACoB,WAAL,EAAD,CAAjB,EAAuC;AAAEpB,QAAAA,IAAF;AAAQI,QAAAA;AAAR,OAAvC;AACD,KAFD,CAEE,OAAOiB,CAAP,EAAU;AACVrC,MAAAA,GAAG,CAACsC,KAAJ,CAAW,kCAAiCtB,IAAK,IAAjD;AACD;;AAED,QAAI,KAAKY,QAAT,EAAmB;AACjB,WAAKD,OAAL,CAAaY,MAAb,CAAoB,KAAKT,QAAzB;AACD;AACF;;AAEDU,EAAAA,MAAM,CAAEpB,MAAF,EAAU;AACdA,IAAAA,MAAM,GAAGA,MAAM,IAAI,EAAnB;AACA,UAAMqB,cAAc,GAAGrB,MAAM,CAACqB,cAA9B;AAEA,SAAKb,QAAL,GAAgB,IAAhB;;AAEA,QAAIR,MAAM,CAAChB,OAAP,KAAmB,KAAvB,EAA8B;AAC5BsC,MAAAA,MAAM,CAACC,IAAP,CAAYvC,OAAZ,EACGwC,MADH,CACU5B,IAAI,IAAI,CAAC,KAAKc,QAAL,CAAce,GAAd,CAAkBzC,OAAO,CAACY,IAAD,CAAzB,CADnB,EAEG8B,OAFH,CAEW9B,IAAI,IAAI;AACf,cAAM+B,YAAY,GAAG,EAArB;;AACA,YAAIN,cAAc,IAAIA,cAAc,CAACzB,IAAD,CAApC,EAA4C;AAC1C+B,UAAAA,YAAY,CAACC,OAAb,GAAuBP,cAAc,CAACzB,IAAD,CAArC;AACD;;AACD,aAAKmB,IAAL,CAAU/B,OAAO,CAACY,IAAD,CAAjB,EAAyB;AAAEA,UAAAA,IAAF;AAAQI,UAAAA,MAAM,EAAED,SAAS,CAACH,IAAD,EAAO+B,YAAP;AAAzB,SAAzB;AACD,OARH;AASD;;AAED,SAAKpB,OAAL,CAAaY,MAAb,CAAoB,KAAKT,QAAzB;AACD;;AAEDmB,EAAAA,OAAO,GAAI;AACT,SAAK,MAAMC,eAAX,IAA8B,KAAKlB,aAAL,CAAmBW,IAAnB,EAA9B,EAAyD;AACvD,WAAKQ,OAAL,CAAaD,eAAb;AACD;;AAED,SAAKpB,QAAL,CAAcsB,KAAd;;AACA,SAAKxB,QAAL,GAAgB,KAAhB;;AACA,SAAKD,OAAL,CAAaY,MAAb,CAAoB,KAAKT,QAAzB;AACD;;AAEDuB,EAAAA,IAAI,CAAEC,OAAF,EAAWC,KAAX,EAAkBC,OAAlB,EAA2B;AAC7B1D,IAAAA,OAAO,CAAC2D,QAAR,CAAiBH,OAAjB,EAA0BC,KAA1B,EAAiCC,OAAjC;AACD;;AAEDE,EAAAA,MAAM,CAAEJ,OAAF,EAAWC,KAAX,EAAkBC,OAAlB,EAA2B;AAC/B1D,IAAAA,OAAO,CAAC6D,UAAR,CAAmBL,OAAnB,EAA4BC,KAA5B,EAAmCC,OAAnC;AACD;;AAEDI,EAAAA,UAAU,CAAEC,aAAF,EAAiBL,OAAjB,EAA0B;AAClC,WAAO1D,OAAO,CAACuD,IAAR,CAAaQ,aAAb,EAA4BL,OAA5B,CAAP;AACD;;AAEDM,EAAAA,YAAY,CAAED,aAAF,EAAiB;AAC3B,WAAO/D,OAAO,CAAC4D,MAAR,CAAeG,aAAf,CAAP;AACD;;AAEDE,EAAAA,IAAI,CAAElD,MAAF,EAAUmD,IAAV,EAAgB;AAClB,QAAI,CAAC,KAAKpC,QAAV,EAAoB;AAEpB,UAAMqC,gBAAgB,GAAG,GAAGC,MAAH,CAAUrD,MAAV,CAAzB;AACA,UAAMQ,OAAO,GAAG2C,IAAI,CAAC5C,MAAL,CAAYC,OAAZ,KAAwB,KAAxC;AAEApB,IAAAA,OAAO,CAACkE,OAAR,CAAiB,4CAAjB,EAA8D9C,OAA9D,EAAwE,QAAO2C,IAAI,CAAChD,IAAK,EAAzF;;AAEA,QAAI;AACFiD,MAAAA,gBAAgB,CACbnB,OADH,CACWI,eAAe,IAAI;AAC1B,aAAKvB,OAAL,CAAaoC,IAAb,CAAkBb,eAAlB,EAAmCc,IAAI,CAAC5C,MAAxC;AACD,OAHH;AAID,KALD,CAKE,OAAOiB,CAAP,EAAU;AACVrC,MAAAA,GAAG,CAACoE,KAAJ,CAAU/B,CAAV;AACA,WAAKgC,MAAL,CAAYxD,MAAZ;AACAb,MAAAA,GAAG,CAACsC,KAAJ,CAAW,+BAA8B0B,IAAI,CAAChD,IAAK,iCAAnD;AAEAf,MAAAA,OAAO,CAACqE,SAAR,CAAmB,mCAAnB,EAAuD,IAAvD;AACD;AACF;;AAEDD,EAAAA,MAAM,CAAExD,MAAF,EAAU;AACd,OAAGqD,MAAH,CAAUrD,MAAV,EACGiC,OADH,CACWI,eAAe,IAAI;AAC1B,WAAKC,OAAL,CAAaD,eAAb;;AACA,WAAKlB,aAAL,CAAmBuC,MAAnB,CAA0BrB,eAA1B;AACD,KAJH;;AAMA,UAAMc,IAAI,GAAG,KAAKlC,QAAL,CAAc0C,GAAd,CAAkB3D,MAAlB,CAAb;;AAEA,QAAImD,IAAJ,EAAU;AACR,WAAKlC,QAAL,CAAcyC,MAAd,CAAqB1D,MAArB;;AAEAZ,MAAAA,OAAO,CAACkE,OAAR,CAAiB,4CAAjB,EAA8D,KAA9D,EAAsE,QAAOH,IAAI,CAAChD,IAAK,EAAvF;AACD;AACF;;AAEDyD,EAAAA,KAAK,CAAEvB,eAAF,EAAmBW,aAAnB,EAAkCzC,MAAlC,EAA0C;AAC7C,QAAIsD,YAAY,GAAG,KAAK1C,aAAL,CAAmBwC,GAAnB,CAAuBtB,eAAvB,CAAnB;;AAEA,QAAI,CAACwB,YAAL,EAAmB;AACjB,WAAK1C,aAAL,CAAmB2C,GAAnB,CAAuBzB,eAAvB,EAAwCwB,YAAY,GAAG,IAAIhE,GAAJ,EAAvD;AACD;;AAED,QAAI,CAACgE,YAAY,CAAC7B,GAAb,CAAiB,KAAK+B,cAAL,CAAoBf,aAApB,CAAjB,CAAL,EAA2D;AACzD,UAAI;AACFA,QAAAA,aAAa,GAAGX,eAAe,CAACuB,KAAhB,CAAsBI,IAAtB,CAA2B,IAA3B,EAAiChB,aAAjC,EAAgD,KAAKnC,OAAL,CAAaA,OAA7D,EAAsEN,MAAtE,KAAiFyC,aAAjG;AACA,eAAOA,aAAP;AACD,OAHD,SAGU;AACR;AACAa,QAAAA,YAAY,CAACI,GAAb,CAAiB,KAAKF,cAAL,CAAoBf,aAApB,CAAjB;AACD;AACF;AACF;;AAEDV,EAAAA,OAAO,CAAED,eAAF,EAAmB;AACxB,UAAMwB,YAAY,GAAG,KAAK1C,aAAL,CAAmBwC,GAAnB,CAAuBtB,eAAvB,CAArB;;AAEA,QAAIwB,YAAJ,EAAkB;AAChBA,MAAAA,YAAY,CAAC5B,OAAb,CAAqBe,aAAa,IAAI;AACpC,YAAI;AACFX,UAAAA,eAAe,CAACC,OAAhB,CAAwB0B,IAAxB,CAA6B,IAA7B,EAAmChB,aAAnC,EAAkD,KAAKnC,OAAvD;AACD,SAFD,CAEE,OAAOW,CAAP,EAAU;AACVrC,UAAAA,GAAG,CAACoE,KAAJ,CAAU/B,CAAV;AACD;AACF,OAND;AAOD;AACF;;AAEDF,EAAAA,IAAI,CAAEtB,MAAF,EAAUmD,IAAV,EAAgB;AAClB,QAAI,KAAK/B,gBAAL,CAAsBY,GAAtB,CAA0BmB,IAAI,CAAChD,IAA/B,CAAJ,EAA0C;AACxChB,MAAAA,GAAG,CAACsC,KAAJ,CAAW,WAAU0B,IAAI,CAAChD,IAAK,0CAA/B;AACD,KAFD,MAEO;AACL,WAAKc,QAAL,CAAc6C,GAAd,CAAkB9D,MAAlB,EAA0BmD,IAA1B;;AACA,WAAKD,IAAL,CAAUlD,MAAV,EAAkBmD,IAAlB;AACD;AACF,GAzJgB,CA2JjB;AACA;;;AACAY,EAAAA,cAAc,CAAEf,aAAF,EAAiB;AAC7B,WAAOA,aAAa,KAAKA,aAAa,CAACkB,OAAd,IAAyBlB,aAA9B,CAApB;AACD;;AA/JgB;;AAkKnBmB,MAAM,CAACC,OAAP,GAAiB1D,YAAjB","sourcesContent":["'use strict'\n\nconst shimmer = require('../../datadog-shimmer')\nconst log = require('./log')\nconst metrics = require('./metrics')\nconst Loader = require('./loader')\nconst { isTrue } = require('./util')\nconst plugins = require('./plugins')\n\nconst disabledPlugins = process.env.DD_TRACE_DISABLED_PLUGINS\n\nconst collectDisabledPlugins = () => {\n  return new Set(disabledPlugins && disabledPlugins.split(',').map(plugin => plugin.trim()))\n}\n\nfunction cleanEnv (name) {\n  return process.env[`DD_TRACE_${name.toUpperCase()}`.replace(/[^a-z0-9_]/ig, '_')]\n}\n\nfunction getConfig (name, config = {}) {\n  if (!name) {\n    return config\n  }\n\n  const enabled = cleanEnv(`${name}_ENABLED`)\n  if (enabled !== undefined) {\n    config.enabled = isTrue(enabled)\n  }\n\n  return config\n}\n\nclass Instrumenter {\n  constructor (tracer) {\n    this._tracer = tracer\n    this._loader = new Loader(this)\n    this._enabled = false\n    this._names = new Set()\n    this._plugins = new Map()\n    this._instrumented = new Map()\n    this._disabledPlugins = collectDisabledPlugins()\n  }\n\n  use (name, config) {\n    if (typeof config === 'boolean') {\n      config = { enabled: config }\n    }\n\n    config = getConfig(name, config)\n\n    try {\n      this._set(plugins[name.toLowerCase()], { name, config })\n    } catch (e) {\n      log.debug(`Could not find a plugin named \"${name}\".`)\n    }\n\n    if (this._enabled) {\n      this._loader.reload(this._plugins)\n    }\n  }\n\n  enable (config) {\n    config = config || {}\n    const serviceMapping = config.serviceMapping\n\n    this._enabled = true\n\n    if (config.plugins !== false) {\n      Object.keys(plugins)\n        .filter(name => !this._plugins.has(plugins[name]))\n        .forEach(name => {\n          const pluginConfig = {}\n          if (serviceMapping && serviceMapping[name]) {\n            pluginConfig.service = serviceMapping[name]\n          }\n          this._set(plugins[name], { name, config: getConfig(name, pluginConfig) })\n        })\n    }\n\n    this._loader.reload(this._plugins)\n  }\n\n  disable () {\n    for (const instrumentation of this._instrumented.keys()) {\n      this.unpatch(instrumentation)\n    }\n\n    this._plugins.clear()\n    this._enabled = false\n    this._loader.reload(this._plugins)\n  }\n\n  wrap (nodules, names, wrapper) {\n    shimmer.massWrap(nodules, names, wrapper)\n  }\n\n  unwrap (nodules, names, wrapper) {\n    shimmer.massUnwrap(nodules, names, wrapper)\n  }\n\n  wrapExport (moduleExports, wrapper) {\n    return shimmer.wrap(moduleExports, wrapper)\n  }\n\n  unwrapExport (moduleExports) {\n    return shimmer.unwrap(moduleExports)\n  }\n\n  load (plugin, meta) {\n    if (!this._enabled) return\n\n    const instrumentations = [].concat(plugin)\n    const enabled = meta.config.enabled !== false\n\n    metrics.boolean(`datadog.tracer.node.plugin.enabled.by.name`, enabled, `name:${meta.name}`)\n\n    try {\n      instrumentations\n        .forEach(instrumentation => {\n          this._loader.load(instrumentation, meta.config)\n        })\n    } catch (e) {\n      log.error(e)\n      this.unload(plugin)\n      log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`)\n\n      metrics.increment(`datadog.tracer.node.plugin.errors`, true)\n    }\n  }\n\n  unload (plugin) {\n    [].concat(plugin)\n      .forEach(instrumentation => {\n        this.unpatch(instrumentation)\n        this._instrumented.delete(instrumentation)\n      })\n\n    const meta = this._plugins.get(plugin)\n\n    if (meta) {\n      this._plugins.delete(plugin)\n\n      metrics.boolean(`datadog.tracer.node.plugin.enabled.by.name`, false, `name:${meta.name}`)\n    }\n  }\n\n  patch (instrumentation, moduleExports, config) {\n    let instrumented = this._instrumented.get(instrumentation)\n\n    if (!instrumented) {\n      this._instrumented.set(instrumentation, instrumented = new Set())\n    }\n\n    if (!instrumented.has(this._defaultExport(moduleExports))) {\n      try {\n        moduleExports = instrumentation.patch.call(this, moduleExports, this._tracer._tracer, config) || moduleExports\n        return moduleExports\n      } finally {\n        // add even on error since `unpatch` will take care of removing it.\n        instrumented.add(this._defaultExport(moduleExports))\n      }\n    }\n  }\n\n  unpatch (instrumentation) {\n    const instrumented = this._instrumented.get(instrumentation)\n\n    if (instrumented) {\n      instrumented.forEach(moduleExports => {\n        try {\n          instrumentation.unpatch.call(this, moduleExports, this._tracer)\n        } catch (e) {\n          log.error(e)\n        }\n      })\n    }\n  }\n\n  _set (plugin, meta) {\n    if (this._disabledPlugins.has(meta.name)) {\n      log.debug(`Plugin \"${meta.name}\" was disabled via configuration option.`)\n    } else {\n      this._plugins.set(plugin, meta)\n      this.load(plugin, meta)\n    }\n  }\n\n  // ESM modules have a different export between `import` and `require` so we\n  // use the default export instead when available.\n  _defaultExport (moduleExports) {\n    return moduleExports && (moduleExports.default || moduleExports)\n  }\n}\n\nmodule.exports = Instrumenter\n"]},"metadata":{},"sourceType":"script"}