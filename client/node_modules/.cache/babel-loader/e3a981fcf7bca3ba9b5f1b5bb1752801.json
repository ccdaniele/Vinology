{"ast":null,"code":"'use strict';\n\nlet kDirReadPromisified;\nlet kDirClosePromisified;\nlet kHandle;\nconst ddFhSym = Symbol('ddFileHandle');\nconst tagMakers = {\n  open: createOpenTags,\n  close: createCloseTags,\n  readFile: createReadFileTags,\n  writeFile: createWriteFileTags,\n  appendFile: createAppendFileTags,\n  access: createPathTags,\n  copyFile: createCopyFileTags,\n  stat: createPathTags,\n  lstat: createPathTags,\n  fstat: createFDTags,\n  readdir: createPathTags,\n  opendir: createPathTags,\n  read: createFDTags,\n  write: createFDTags,\n  writev: createFDTags,\n  chmod: createChmodTags,\n  lchmod: createChmodTags,\n  fchmod: createFchmodTags,\n  chown: createChownTags,\n  lchown: createChownTags,\n  fchown: createFchownTags,\n  realpath: createPathTags,\n  readlink: createPathTags,\n  unlink: createPathTags,\n  symlink: createCopyFileTags,\n  link: createCopyFileTags,\n  rmdir: createPathTags,\n  rename: createCopyFileTags,\n  fsync: createFDTags,\n  fdatasync: createFDTags,\n  mkdir: createPathTags,\n  truncate: createPathTags,\n  ftruncate: createFDTags,\n  utimes: createPathTags,\n  futimes: createFDTags,\n  mkdtemp: createPathTags\n};\nconst promisifiable = ['read', 'readv', 'write', 'writev'];\nconst orphanable = false;\n\nfunction createWrapCreateReadStream(config, tracer) {\n  return function wrapCreateReadStream(createReadStream) {\n    return function createReadStreamWithTrace(path, options) {\n      if (!hasParent(tracer)) {\n        return createReadStream.apply(this, arguments);\n      }\n\n      const tags = makeFSFlagTags('ReadStream', path, options, 'r', config, tracer);\n      return tracer.trace('fs.operation', {\n        tags,\n        orphanable\n      }, (span, done) => {\n        const stream = createReadStream.apply(this, arguments);\n        stream.once('end', done);\n        stream.once('error', done);\n        return stream;\n      });\n    };\n  };\n}\n\nfunction createWrapCreateWriteStream(config, tracer) {\n  return function wrapCreateWriteStream(createWriteStream) {\n    return function createWriteStreamWithTrace(path, options) {\n      const tags = makeFSFlagTags('WriteStream', path, options, 'w', config, tracer);\n      return tracer.trace('fs.operation', {\n        tags,\n        orphanable\n      }, (span, done) => {\n        const stream = createWriteStream.apply(this, arguments);\n        stream.once('finish', done);\n        stream.once('error', done);\n        return stream;\n      });\n    };\n  };\n}\n\nfunction createWrapExists(config, tracer) {\n  return function wrapExists(exists) {\n    const existsWithTrace = function existsWithTrace(path, cb) {\n      if (typeof cb !== 'function') {\n        return exists.apply(this, arguments);\n      }\n\n      const tags = makeFSTags('exists', path, null, config, tracer);\n      return tracer.trace('fs.operation', {\n        tags,\n        orphanable\n      }, (span, done) => {\n        arguments[1] = function (result) {\n          done();\n          cb.apply(this, arguments);\n        };\n\n        return exists.apply(this, arguments);\n      });\n    };\n\n    copySymbols(exists, existsWithTrace);\n    return existsWithTrace;\n  };\n}\n\nfunction createWrapDirRead(config, tracer, sync) {\n  const name = sync ? 'dir.readSync' : 'dir.read';\n  return function wrapDirRead(read) {\n    function options() {\n      const tags = makeFSTags(name, this.path, null, config, tracer);\n      return {\n        tags,\n        orphanable\n      };\n    }\n\n    return tracer.wrap('fs.operation', options, read, true);\n  };\n}\n\nfunction createWrapDirClose(config, tracer, sync) {\n  const name = sync ? 'dir.closeSync' : 'dir.close';\n  return function wrapDirClose(close) {\n    function options() {\n      const tags = makeFSTags(name, this.path, null, config, tracer);\n      return {\n        tags,\n        orphanable\n      };\n    }\n\n    return tracer.wrap('fs.operation', options, close, true);\n  };\n}\n\nfunction createWrapDirAsyncIterator(config, tracer, instrumenter) {\n  return function wrapDirAsyncIterator(asyncIterator) {\n    return function asyncIteratorWithTrace() {\n      if (!kDirReadPromisified) {\n        const keys = Reflect.ownKeys(this);\n\n        for (const key of keys) {\n          if (kDirReadPromisified && kDirClosePromisified) break;\n          if (typeof key !== 'symbol') continue;\n\n          if (!kDirReadPromisified && getSymbolName(key).includes('kDirReadPromisified')) {\n            kDirReadPromisified = key;\n          }\n\n          if (!kDirClosePromisified && getSymbolName(key).includes('kDirClosePromisified')) {\n            kDirClosePromisified = key;\n          }\n        }\n      }\n\n      instrumenter.wrap(this, kDirReadPromisified, createWrapDirRead(config, tracer));\n      instrumenter.wrap(this, kDirClosePromisified, createWrapKDirClose(config, tracer, instrumenter));\n      return asyncIterator.apply(this, arguments);\n    };\n  };\n}\n\nfunction createWrapKDirClose(config, tracer, instrumenter) {\n  return function wrapKDirClose(kDirClose) {\n    return function kDirCloseWithTrace() {\n      const tags = makeFSTags('dir.close', this.path, null, config, tracer);\n      return tracer.trace('fs.operation', {\n        tags,\n        orphanable\n      }, span => {\n        const p = kDirClose.apply(this, arguments);\n\n        const unwrapBoth = () => {\n          instrumenter.unwrap(this, kDirReadPromisified);\n          instrumenter.unwrap(this, kDirClosePromisified);\n        };\n\n        p.then(unwrapBoth, unwrapBoth);\n        return p;\n      });\n    };\n  };\n}\n\nfunction createOpenTags(resourceName, config, tracer) {\n  return function openTags(path, flag, mode) {\n    if (!flag || typeof flag === 'function') {\n      flag = null;\n    }\n\n    return makeFSFlagTags(resourceName, path, {\n      flag\n    }, 'r', config, tracer);\n  };\n}\n\nfunction createCloseTags(resourceName, config, tracer) {\n  return function closeTags(fd) {\n    if (typeof fd === 'undefined' && this && this[ddFhSym]) {\n      fd = this[ddFhSym].fd;\n    }\n\n    if (typeof fd !== 'number' || !Number.isInteger(fd)) {\n      return;\n    }\n\n    return makeFSTags(resourceName, fd, null, config, tracer);\n  };\n}\n\nfunction createReadFileTags(resourceName, config, tracer) {\n  return function readFileTags(path, options) {\n    return makeFSFlagTags(resourceName, path, options, 'r', config, tracer);\n  };\n}\n\nfunction createWriteFileTags(resourceName, config, tracer) {\n  return function writeFileTags(path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'w', config, tracer);\n  };\n}\n\nfunction createAppendFileTags(resourceName, config, tracer) {\n  return function appendFileTags(path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'a', config, tracer);\n  };\n}\n\nfunction createCopyFileTags(resourceName, config, tracer) {\n  return function copyFileTags(src, dest, flag) {\n    return makeFSTags(resourceName, {\n      src,\n      dest\n    }, null, config, tracer);\n  };\n}\n\nfunction createChmodTags(resourceName, config, tracer) {\n  return function chmodTags(fd, mode) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer);\n    tags['file.mode'] = mode.toString(8);\n    return tags;\n  };\n}\n\nfunction createFchmodTags(resourceName, config, tracer) {\n  return function fchmodTags(fd, mode) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      mode = fd;\n      fd = this.fd;\n    }\n\n    const tags = makeFSTags(resourceName, fd, null, config, tracer);\n\n    if (mode) {\n      tags['file.mode'] = mode.toString(8);\n    }\n\n    return tags;\n  };\n}\n\nfunction createPathTags(resourceName, config, tracer) {\n  return function pathTags(path) {\n    return makeFSTags(resourceName, path, null, config, tracer);\n  };\n}\n\nfunction createFDTags(resourceName, config, tracer) {\n  return function fdTags(fd) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      fd = this.fd;\n    }\n\n    return makeFSTags(resourceName, fd, null, config, tracer);\n  };\n}\n\nfunction createChownTags(resourceName, config, tracer) {\n  return function chownTags(fd, uid, gid) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer);\n\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString();\n    }\n\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString();\n    }\n\n    return tags;\n  };\n}\n\nfunction createFchownTags(resourceName, config, tracer) {\n  return function fchownTags(fd, uid, gid) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      gid = uid;\n      uid = fd;\n      fd = this.fd;\n    }\n\n    const tags = makeFSTags(resourceName, fd, null, config, tracer);\n\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString();\n    }\n\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString();\n    }\n\n    return tags;\n  };\n}\n\nfunction getSymbolName(sym) {\n  return sym.description || sym.toString();\n}\n\nfunction hasParent(tracer) {\n  return !!tracer.scope().active();\n}\n\nfunction createWrapCb(tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer);\n  return function wrapFunction(fn) {\n    return tracer.wrap('fs.operation', function () {\n      if (typeof arguments[arguments.length - 1] !== 'function') {\n        return;\n      }\n\n      const tags = makeTags.apply(this, arguments);\n      return tags ? {\n        tags,\n        orphanable\n      } : {\n        orphanable\n      };\n    }, fn, true);\n  };\n}\n\nfunction createWrap(tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer);\n  return function wrapSyncFunction(fn) {\n    return tracer.wrap('fs.operation', function () {\n      const tags = makeTags.apply(this, arguments);\n      return tags ? {\n        tags,\n        orphanable\n      } : {\n        orphanable\n      };\n    }, fn, true);\n  };\n}\n\nfunction makeFSFlagTags(resourceName, path, options, defaultFlag, config, tracer) {\n  const tags = makeFSTags(resourceName, path, options, config, tracer);\n\n  if (tags) {\n    let flag = defaultFlag;\n\n    if (typeof options === 'object' && options !== null) {\n      if (options.flag) {\n        flag = options.flag;\n      } else if (options.flags) {\n        flag = options.flags;\n      }\n    }\n\n    tags['file.flag'] = flag;\n    return tags;\n  }\n}\n\nfunction makeFSTags(resourceName, path, options, config, tracer) {\n  path = options && typeof options === 'object' && 'fd' in options ? options.fd : path;\n  const tags = {\n    'component': 'fs',\n    'span.kind': 'internal',\n    'resource.name': resourceName,\n    'service.name': config.service || tracer._service\n  };\n\n  switch (typeof path) {\n    case 'object':\n      {\n        if (path === null) return tags;\n        const src = 'src' in path ? path.src : null;\n        const dest = 'dest' in path ? path.dest : null;\n\n        if (src || dest) {\n          tags['file.src'] = src;\n          tags['file.dest'] = dest;\n        } else {\n          tags['file.path'] = path;\n        }\n\n        break;\n      }\n\n    case 'string':\n      {\n        tags['file.path'] = path;\n        break;\n      }\n\n    case 'number':\n      {\n        tags['file.descriptor'] = path.toString();\n        break;\n      }\n  }\n\n  return tags;\n}\n\nfunction copySymbols(from, to) {\n  const props = Object.getOwnPropertyDescriptors(from);\n  const keys = Reflect.ownKeys(props);\n\n  for (const key of keys) {\n    if (typeof key !== 'symbol' || to.hasOwnProperty(key)) continue;\n    Object.defineProperty(to, key, props[key]);\n  }\n}\n\nfunction getFileHandlePrototype(fs) {\n  return fs.promises.open(__filename, 'r').then(fh => {\n    if (!kHandle) {\n      kHandle = Reflect.ownKeys(fh).find(key => typeof key === 'symbol' && key.toString().includes('kHandle'));\n    }\n\n    fh.close();\n    return Object.getPrototypeOf(fh);\n  });\n}\n\nfunction patchClassicFunctions(fs, tracer, config) {\n  for (const name in fs) {\n    if (!fs[name]) continue;\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name;\n    const original = fs[name];\n\n    if (tagMakerName in tagMakers) {\n      const tagMaker = tagMakers[tagMakerName];\n\n      if (name.endsWith('Sync')) {\n        this.wrap(fs, name, createWrap(tracer, config, name, tagMaker));\n      } else {\n        this.wrap(fs, name, createWrapCb(tracer, config, name, tagMaker));\n      }\n\n      if (name in promisifiable) {\n        copySymbols(original, fs[name]);\n      }\n    }\n  }\n}\n\nfunction patchFileHandle(fs, tracer, config) {\n  getFileHandlePrototype(fs).then(fileHandlePrototype => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue;\n      }\n\n      let tagMaker;\n      const fName = 'f' + name;\n\n      if (fName in tagMakers) {\n        tagMaker = tagMakers[fName];\n      } else {\n        tagMaker = createFDTags;\n      }\n\n      const instrumenter = this;\n      const desc = Reflect.getOwnPropertyDescriptor(fileHandlePrototype, kHandle);\n\n      if (!desc || !desc.get) {\n        Reflect.defineProperty(fileHandlePrototype, kHandle, {\n          get() {\n            return this[ddFhSym];\n          },\n\n          set(h) {\n            this[ddFhSym] = h;\n            instrumenter.wrap(this, 'close', createWrap(tracer, config, 'filehandle.close', tagMakers.close));\n          },\n\n          configurable: true\n        });\n      }\n\n      this.wrap(fileHandlePrototype, name, createWrap(tracer, config, 'filehandle.' + name, tagMaker));\n    }\n  });\n}\n\nfunction patchPromiseFunctions(fs, tracer, config) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      const tagMaker = tagMakers[name];\n      this.wrap(fs.promises, name, createWrap(tracer, config, 'promises.' + name, tagMaker));\n    }\n  }\n}\n\nfunction patchDirFunctions(fs, tracer, config) {\n  this.wrap(fs.Dir.prototype, 'close', createWrapDirClose(config, tracer));\n  this.wrap(fs.Dir.prototype, 'closeSync', createWrapDirClose(config, tracer, true));\n  this.wrap(fs.Dir.prototype, 'read', createWrapDirRead(config, tracer));\n  this.wrap(fs.Dir.prototype, 'readSync', createWrapDirRead(config, tracer, true));\n  this.wrap(fs.Dir.prototype, Symbol.asyncIterator, createWrapDirAsyncIterator(config, tracer, this));\n}\n\nfunction unpatchClassicFunctions(fs) {\n  for (const name in fs) {\n    if (!fs[name]) continue;\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name;\n\n    if (tagMakerName in tagMakers) {\n      this.unwrap(fs, name);\n    }\n  }\n}\n\nfunction unpatchFileHandle(fs) {\n  getFileHandlePrototype(fs).then(fileHandlePrototype => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue;\n      }\n\n      this.unwrap(fileHandlePrototype, name);\n    }\n\n    delete fileHandlePrototype[kHandle];\n  });\n}\n\nfunction unpatchPromiseFunctions(fs) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      this.unwrap(fs.promises, name);\n    }\n  }\n}\n\nfunction unpatchDirFunctions(fs) {\n  this.unwrap(fs.Dir.prototype, 'close');\n  this.unwrap(fs.Dir.prototype, 'closeSync');\n  this.unwrap(fs.Dir.prototype, 'read');\n  this.unwrap(fs.Dir.prototype, 'readSync');\n  this.unwrap(fs.Dir.prototype, Symbol.asyncIterator);\n}\n\nmodule.exports = {\n  name: 'fs',\n\n  patch(fs, tracer, config) {\n    const realpathNative = fs.realpath.native;\n    const realpathSyncNative = fs.realpathSync.native;\n    patchClassicFunctions.call(this, fs, tracer, config);\n\n    if (fs.promises) {\n      patchFileHandle.call(this, fs, tracer, config);\n      patchPromiseFunctions.call(this, fs, tracer, config);\n    }\n\n    if (fs.Dir) {\n      patchDirFunctions.call(this, fs, tracer, config);\n    }\n\n    this.wrap(fs, 'createReadStream', createWrapCreateReadStream(config, tracer));\n    this.wrap(fs, 'createWriteStream', createWrapCreateWriteStream(config, tracer));\n    this.wrap(fs, 'existsSync', createWrap(tracer, config, 'existsSync', createPathTags));\n    this.wrap(fs, 'exists', createWrapExists(config, tracer));\n\n    if (realpathNative) {\n      fs.realpath.native = createWrapCb(tracer, config, 'realpath.native', createPathTags)(realpathNative);\n    }\n\n    if (realpathSyncNative) {\n      fs.realpathSync.native = createWrap(tracer, config, 'realpath.native', createPathTags)(realpathSyncNative);\n    }\n  },\n\n  unpatch(fs) {\n    unpatchClassicFunctions.call(this, fs);\n\n    if (fs.promises) {\n      unpatchFileHandle.call(this, fs);\n      unpatchPromiseFunctions.call(this, fs);\n    }\n\n    if (fs.Dir) {\n      unpatchDirFunctions.call(this, fs);\n    }\n\n    this.unwrap(fs, 'createReadStream');\n    this.unwrap(fs, 'createWriteStream');\n    this.unwrap(fs, 'existsSync');\n    this.unwrap(fs, 'exists');\n  }\n\n};\n/** TODO fs functions:\n\nunwatchFile\nwatch\nwatchFile\n*/","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-fs/src/index.js"],"names":["kDirReadPromisified","kDirClosePromisified","kHandle","ddFhSym","Symbol","tagMakers","open","createOpenTags","close","createCloseTags","readFile","createReadFileTags","writeFile","createWriteFileTags","appendFile","createAppendFileTags","access","createPathTags","copyFile","createCopyFileTags","stat","lstat","fstat","createFDTags","readdir","opendir","read","write","writev","chmod","createChmodTags","lchmod","fchmod","createFchmodTags","chown","createChownTags","lchown","fchown","createFchownTags","realpath","readlink","unlink","symlink","link","rmdir","rename","fsync","fdatasync","mkdir","truncate","ftruncate","utimes","futimes","mkdtemp","promisifiable","orphanable","createWrapCreateReadStream","config","tracer","wrapCreateReadStream","createReadStream","createReadStreamWithTrace","path","options","hasParent","apply","arguments","tags","makeFSFlagTags","trace","span","done","stream","once","createWrapCreateWriteStream","wrapCreateWriteStream","createWriteStream","createWriteStreamWithTrace","createWrapExists","wrapExists","exists","existsWithTrace","cb","makeFSTags","result","copySymbols","createWrapDirRead","sync","name","wrapDirRead","wrap","createWrapDirClose","wrapDirClose","createWrapDirAsyncIterator","instrumenter","wrapDirAsyncIterator","asyncIterator","asyncIteratorWithTrace","keys","Reflect","ownKeys","key","getSymbolName","includes","createWrapKDirClose","wrapKDirClose","kDirClose","kDirCloseWithTrace","p","unwrapBoth","unwrap","then","resourceName","openTags","flag","mode","closeTags","fd","Number","isInteger","readFileTags","writeFileTags","data","appendFileTags","copyFileTags","src","dest","chmodTags","toString","fchmodTags","pathTags","fdTags","chownTags","uid","gid","fchownTags","sym","description","scope","active","createWrapCb","tagMaker","makeTags","wrapFunction","fn","length","createWrap","wrapSyncFunction","defaultFlag","flags","service","_service","from","to","props","Object","getOwnPropertyDescriptors","hasOwnProperty","defineProperty","getFileHandlePrototype","fs","promises","__filename","fh","find","getPrototypeOf","patchClassicFunctions","tagMakerName","endsWith","substr","original","patchFileHandle","fileHandlePrototype","fName","desc","getOwnPropertyDescriptor","get","set","h","configurable","patchPromiseFunctions","patchDirFunctions","Dir","prototype","unpatchClassicFunctions","unpatchFileHandle","unpatchPromiseFunctions","unpatchDirFunctions","module","exports","patch","realpathNative","native","realpathSyncNative","realpathSync","call","unpatch"],"mappings":"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","sourcesContent":["'use strict'\n\nlet kDirReadPromisified\nlet kDirClosePromisified\nlet kHandle\n\nconst ddFhSym = Symbol('ddFileHandle')\n\nconst tagMakers = {\n  open: createOpenTags,\n  close: createCloseTags,\n  readFile: createReadFileTags,\n  writeFile: createWriteFileTags,\n  appendFile: createAppendFileTags,\n  access: createPathTags,\n  copyFile: createCopyFileTags,\n  stat: createPathTags,\n  lstat: createPathTags,\n  fstat: createFDTags,\n  readdir: createPathTags,\n  opendir: createPathTags,\n  read: createFDTags,\n  write: createFDTags,\n  writev: createFDTags,\n  chmod: createChmodTags,\n  lchmod: createChmodTags,\n  fchmod: createFchmodTags,\n  chown: createChownTags,\n  lchown: createChownTags,\n  fchown: createFchownTags,\n  realpath: createPathTags,\n  readlink: createPathTags,\n  unlink: createPathTags,\n  symlink: createCopyFileTags,\n  link: createCopyFileTags,\n  rmdir: createPathTags,\n  rename: createCopyFileTags,\n  fsync: createFDTags,\n  fdatasync: createFDTags,\n  mkdir: createPathTags,\n  truncate: createPathTags,\n  ftruncate: createFDTags,\n  utimes: createPathTags,\n  futimes: createFDTags,\n  mkdtemp: createPathTags\n}\n\nconst promisifiable = ['read', 'readv', 'write', 'writev']\n\nconst orphanable = false\n\nfunction createWrapCreateReadStream (config, tracer) {\n  return function wrapCreateReadStream (createReadStream) {\n    return function createReadStreamWithTrace (path, options) {\n      if (!hasParent(tracer)) {\n        return createReadStream.apply(this, arguments)\n      }\n      const tags = makeFSFlagTags('ReadStream', path, options, 'r', config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        const stream = createReadStream.apply(this, arguments)\n        stream.once('end', done)\n        stream.once('error', done)\n        return stream\n      })\n    }\n  }\n}\n\nfunction createWrapCreateWriteStream (config, tracer) {\n  return function wrapCreateWriteStream (createWriteStream) {\n    return function createWriteStreamWithTrace (path, options) {\n      const tags = makeFSFlagTags('WriteStream', path, options, 'w', config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        const stream = createWriteStream.apply(this, arguments)\n        stream.once('finish', done)\n        stream.once('error', done)\n        return stream\n      })\n    }\n  }\n}\n\nfunction createWrapExists (config, tracer) {\n  return function wrapExists (exists) {\n    const existsWithTrace = function existsWithTrace (path, cb) {\n      if (typeof cb !== 'function') {\n        return exists.apply(this, arguments)\n      }\n      const tags = makeFSTags('exists', path, null, config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span, done) => {\n        arguments[1] = function (result) {\n          done()\n          cb.apply(this, arguments)\n        }\n        return exists.apply(this, arguments)\n      })\n    }\n\n    copySymbols(exists, existsWithTrace)\n\n    return existsWithTrace\n  }\n}\n\nfunction createWrapDirRead (config, tracer, sync) {\n  const name = sync ? 'dir.readSync' : 'dir.read'\n  return function wrapDirRead (read) {\n    function options () {\n      const tags = makeFSTags(name, this.path, null, config, tracer)\n      return { tags, orphanable }\n    }\n    return tracer.wrap('fs.operation', options, read, true)\n  }\n}\n\nfunction createWrapDirClose (config, tracer, sync) {\n  const name = sync ? 'dir.closeSync' : 'dir.close'\n  return function wrapDirClose (close) {\n    function options () {\n      const tags = makeFSTags(name, this.path, null, config, tracer)\n      return { tags, orphanable }\n    }\n    return tracer.wrap('fs.operation', options, close, true)\n  }\n}\n\nfunction createWrapDirAsyncIterator (config, tracer, instrumenter) {\n  return function wrapDirAsyncIterator (asyncIterator) {\n    return function asyncIteratorWithTrace () {\n      if (!kDirReadPromisified) {\n        const keys = Reflect.ownKeys(this)\n        for (const key of keys) {\n          if (kDirReadPromisified && kDirClosePromisified) break\n          if (typeof key !== 'symbol') continue\n          if (!kDirReadPromisified && getSymbolName(key).includes('kDirReadPromisified')) {\n            kDirReadPromisified = key\n          }\n          if (!kDirClosePromisified && getSymbolName(key).includes('kDirClosePromisified')) {\n            kDirClosePromisified = key\n          }\n        }\n      }\n      instrumenter.wrap(this, kDirReadPromisified, createWrapDirRead(config, tracer))\n      instrumenter.wrap(this, kDirClosePromisified, createWrapKDirClose(config, tracer, instrumenter))\n      return asyncIterator.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapKDirClose (config, tracer, instrumenter) {\n  return function wrapKDirClose (kDirClose) {\n    return function kDirCloseWithTrace () {\n      const tags = makeFSTags('dir.close', this.path, null, config, tracer)\n      return tracer.trace('fs.operation', { tags, orphanable }, (span) => {\n        const p = kDirClose.apply(this, arguments)\n        const unwrapBoth = () => {\n          instrumenter.unwrap(this, kDirReadPromisified)\n          instrumenter.unwrap(this, kDirClosePromisified)\n        }\n        p.then(unwrapBoth, unwrapBoth)\n        return p\n      })\n    }\n  }\n}\n\nfunction createOpenTags (resourceName, config, tracer) {\n  return function openTags (path, flag, mode) {\n    if (!flag || typeof flag === 'function') {\n      flag = null\n    }\n    return makeFSFlagTags(resourceName, path, { flag }, 'r', config, tracer)\n  }\n}\n\nfunction createCloseTags (resourceName, config, tracer) {\n  return function closeTags (fd) {\n    if (typeof fd === 'undefined' && this && this[ddFhSym]) {\n      fd = this[ddFhSym].fd\n    }\n    if (typeof fd !== 'number' || !Number.isInteger(fd)) {\n      return\n    }\n    return makeFSTags(resourceName, fd, null, config, tracer)\n  }\n}\n\nfunction createReadFileTags (resourceName, config, tracer) {\n  return function readFileTags (path, options) {\n    return makeFSFlagTags(resourceName, path, options, 'r', config, tracer)\n  }\n}\n\nfunction createWriteFileTags (resourceName, config, tracer) {\n  return function writeFileTags (path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'w', config, tracer)\n  }\n}\n\nfunction createAppendFileTags (resourceName, config, tracer) {\n  return function appendFileTags (path, data, options) {\n    return makeFSFlagTags(resourceName, path, options, 'a', config, tracer)\n  }\n}\n\nfunction createCopyFileTags (resourceName, config, tracer) {\n  return function copyFileTags (src, dest, flag) {\n    return makeFSTags(resourceName, { src, dest }, null, config, tracer)\n  }\n}\n\nfunction createChmodTags (resourceName, config, tracer) {\n  return function chmodTags (fd, mode) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    tags['file.mode'] = mode.toString(8)\n    return tags\n  }\n}\n\nfunction createFchmodTags (resourceName, config, tracer) {\n  return function fchmodTags (fd, mode) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      mode = fd\n      fd = this.fd\n    }\n\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (mode) {\n      tags['file.mode'] = mode.toString(8)\n    }\n    return tags\n  }\n}\n\nfunction createPathTags (resourceName, config, tracer) {\n  return function pathTags (path) {\n    return makeFSTags(resourceName, path, null, config, tracer)\n  }\n}\n\nfunction createFDTags (resourceName, config, tracer) {\n  return function fdTags (fd) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      fd = this.fd\n    }\n    return makeFSTags(resourceName, fd, null, config, tracer)\n  }\n}\n\nfunction createChownTags (resourceName, config, tracer) {\n  return function chownTags (fd, uid, gid) {\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString()\n    }\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString()\n    }\n    return tags\n  }\n}\n\nfunction createFchownTags (resourceName, config, tracer) {\n  return function fchownTags (fd, uid, gid) {\n    if (typeof this === 'object' && this !== null && this.fd) {\n      gid = uid\n      uid = fd\n      fd = this.fd\n    }\n    const tags = makeFSTags(resourceName, fd, null, config, tracer)\n    if (typeof uid === 'number') {\n      tags['file.uid'] = uid.toString()\n    }\n    if (typeof gid === 'number') {\n      tags['file.gid'] = gid.toString()\n    }\n    return tags\n  }\n}\n\nfunction getSymbolName (sym) {\n  return sym.description || sym.toString()\n}\n\nfunction hasParent (tracer) {\n  return !!tracer.scope().active()\n}\n\nfunction createWrapCb (tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer)\n  return function wrapFunction (fn) {\n    return tracer.wrap('fs.operation', function () {\n      if (typeof arguments[arguments.length - 1] !== 'function') {\n        return\n      }\n      const tags = makeTags.apply(this, arguments)\n      return tags ? { tags, orphanable } : { orphanable }\n    }, fn, true)\n  }\n}\n\nfunction createWrap (tracer, config, name, tagMaker) {\n  const makeTags = tagMaker(name, config, tracer)\n\n  return function wrapSyncFunction (fn) {\n    return tracer.wrap('fs.operation', function () {\n      const tags = makeTags.apply(this, arguments)\n      return tags ? { tags, orphanable } : { orphanable }\n    }, fn, true)\n  }\n}\n\nfunction makeFSFlagTags (resourceName, path, options, defaultFlag, config, tracer) {\n  const tags = makeFSTags(resourceName, path, options, config, tracer)\n\n  if (tags) {\n    let flag = defaultFlag\n    if (typeof options === 'object' && options !== null) {\n      if (options.flag) {\n        flag = options.flag\n      } else if (options.flags) {\n        flag = options.flags\n      }\n    }\n    tags['file.flag'] = flag\n    return tags\n  }\n}\n\nfunction makeFSTags (resourceName, path, options, config, tracer) {\n  path = options && typeof options === 'object' && 'fd' in options ? options.fd : path\n  const tags = {\n    'component': 'fs',\n    'span.kind': 'internal',\n    'resource.name': resourceName,\n    'service.name': config.service || tracer._service\n  }\n\n  switch (typeof path) {\n    case 'object': {\n      if (path === null) return tags\n      const src = 'src' in path ? path.src : null\n      const dest = 'dest' in path ? path.dest : null\n      if (src || dest) {\n        tags['file.src'] = src\n        tags['file.dest'] = dest\n      } else {\n        tags['file.path'] = path\n      }\n      break\n    }\n    case 'string': {\n      tags['file.path'] = path\n      break\n    }\n    case 'number': {\n      tags['file.descriptor'] = path.toString()\n      break\n    }\n  }\n\n  return tags\n}\n\nfunction copySymbols (from, to) {\n  const props = Object.getOwnPropertyDescriptors(from)\n  const keys = Reflect.ownKeys(props)\n\n  for (const key of keys) {\n    if (typeof key !== 'symbol' || to.hasOwnProperty(key)) continue\n\n    Object.defineProperty(to, key, props[key])\n  }\n}\n\nfunction getFileHandlePrototype (fs) {\n  return fs.promises.open(__filename, 'r')\n    .then(fh => {\n      if (!kHandle) {\n        kHandle = Reflect.ownKeys(fh).find(key => typeof key === 'symbol' && key.toString().includes('kHandle'))\n      }\n      fh.close()\n\n      return Object.getPrototypeOf(fh)\n    })\n}\n\nfunction patchClassicFunctions (fs, tracer, config) {\n  for (const name in fs) {\n    if (!fs[name]) continue\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name\n    const original = fs[name]\n    if (tagMakerName in tagMakers) {\n      const tagMaker = tagMakers[tagMakerName]\n      if (name.endsWith('Sync')) {\n        this.wrap(fs, name, createWrap(tracer, config, name, tagMaker))\n      } else {\n        this.wrap(fs, name, createWrapCb(tracer, config, name, tagMaker))\n      }\n      if (name in promisifiable) {\n        copySymbols(original, fs[name])\n      }\n    }\n  }\n}\n\nfunction patchFileHandle (fs, tracer, config) {\n  getFileHandlePrototype(fs).then((fileHandlePrototype) => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue\n      }\n      let tagMaker\n      const fName = 'f' + name\n      if (fName in tagMakers) {\n        tagMaker = tagMakers[fName]\n      } else {\n        tagMaker = createFDTags\n      }\n\n      const instrumenter = this\n\n      const desc = Reflect.getOwnPropertyDescriptor(fileHandlePrototype, kHandle)\n      if (!desc || !desc.get) {\n        Reflect.defineProperty(fileHandlePrototype, kHandle, {\n          get () {\n            return this[ddFhSym]\n          },\n          set (h) {\n            this[ddFhSym] = h\n            instrumenter.wrap(this, 'close', createWrap(tracer, config, 'filehandle.close', tagMakers.close))\n          },\n          configurable: true\n        })\n      }\n\n      this.wrap(fileHandlePrototype, name, createWrap(tracer, config, 'filehandle.' + name, tagMaker))\n    }\n  })\n}\n\nfunction patchPromiseFunctions (fs, tracer, config) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      const tagMaker = tagMakers[name]\n      this.wrap(fs.promises, name, createWrap(tracer, config, 'promises.' + name, tagMaker))\n    }\n  }\n}\n\nfunction patchDirFunctions (fs, tracer, config) {\n  this.wrap(fs.Dir.prototype, 'close', createWrapDirClose(config, tracer))\n  this.wrap(fs.Dir.prototype, 'closeSync', createWrapDirClose(config, tracer, true))\n  this.wrap(fs.Dir.prototype, 'read', createWrapDirRead(config, tracer))\n  this.wrap(fs.Dir.prototype, 'readSync', createWrapDirRead(config, tracer, true))\n  this.wrap(fs.Dir.prototype, Symbol.asyncIterator, createWrapDirAsyncIterator(config, tracer, this))\n}\n\nfunction unpatchClassicFunctions (fs) {\n  for (const name in fs) {\n    if (!fs[name]) continue\n    const tagMakerName = name.endsWith('Sync') ? name.substr(0, name.length - 4) : name\n    if (tagMakerName in tagMakers) {\n      this.unwrap(fs, name)\n    }\n  }\n}\n\nfunction unpatchFileHandle (fs) {\n  getFileHandlePrototype(fs).then(fileHandlePrototype => {\n    for (const name of Reflect.ownKeys(fileHandlePrototype)) {\n      if (typeof name !== 'string' || name === 'constructor' || name === 'fd' || name === 'getAsyncId') {\n        continue\n      }\n      this.unwrap(fileHandlePrototype, name)\n    }\n    delete fileHandlePrototype[kHandle]\n  })\n}\n\nfunction unpatchPromiseFunctions (fs) {\n  for (const name in fs.promises) {\n    if (name in tagMakers) {\n      this.unwrap(fs.promises, name)\n    }\n  }\n}\n\nfunction unpatchDirFunctions (fs) {\n  this.unwrap(fs.Dir.prototype, 'close')\n  this.unwrap(fs.Dir.prototype, 'closeSync')\n  this.unwrap(fs.Dir.prototype, 'read')\n  this.unwrap(fs.Dir.prototype, 'readSync')\n  this.unwrap(fs.Dir.prototype, Symbol.asyncIterator)\n}\n\nmodule.exports = {\n  name: 'fs',\n  patch (fs, tracer, config) {\n    const realpathNative = fs.realpath.native\n    const realpathSyncNative = fs.realpathSync.native\n    patchClassicFunctions.call(this, fs, tracer, config)\n    if (fs.promises) {\n      patchFileHandle.call(this, fs, tracer, config)\n      patchPromiseFunctions.call(this, fs, tracer, config)\n    }\n    if (fs.Dir) {\n      patchDirFunctions.call(this, fs, tracer, config)\n    }\n    this.wrap(fs, 'createReadStream', createWrapCreateReadStream(config, tracer))\n    this.wrap(fs, 'createWriteStream', createWrapCreateWriteStream(config, tracer))\n    this.wrap(fs, 'existsSync', createWrap(tracer, config, 'existsSync', createPathTags))\n    this.wrap(fs, 'exists', createWrapExists(config, tracer))\n    if (realpathNative) {\n      fs.realpath.native = createWrapCb(tracer, config, 'realpath.native', createPathTags)(realpathNative)\n    }\n    if (realpathSyncNative) {\n      fs.realpathSync.native = createWrap(tracer, config, 'realpath.native', createPathTags)(realpathSyncNative)\n    }\n  },\n  unpatch (fs) {\n    unpatchClassicFunctions.call(this, fs)\n    if (fs.promises) {\n      unpatchFileHandle.call(this, fs)\n      unpatchPromiseFunctions.call(this, fs)\n    }\n    if (fs.Dir) {\n      unpatchDirFunctions.call(this, fs)\n    }\n    this.unwrap(fs, 'createReadStream')\n    this.unwrap(fs, 'createWriteStream')\n    this.unwrap(fs, 'existsSync')\n    this.unwrap(fs, 'exists')\n  }\n}\n\n/** TODO fs functions:\n\nunwatchFile\nwatch\nwatchFile\n*/\n"]},"metadata":{},"sourceType":"script"}