{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serializeHeapProfile = exports.serializeTimeProfile = void 0;\n\nconst profile_1 = require(\"../../proto/profile\");\n\nfunction isGeneratedLocation(location) {\n  return location.column !== undefined && location.line !== undefined && location.line > 0;\n}\n/**\n * Used to build string table and access strings and their ids within the table\n * when serializing a profile.\n */\n\n\nclass StringTable {\n  constructor() {\n    this.strings = [];\n    this.stringsMap = new Map();\n    this.getIndexOrAdd('');\n  }\n  /**\n   * @return index of str within the table. Also adds str to string table if\n   * str is not in the table already.\n   */\n\n\n  getIndexOrAdd(str) {\n    let idx = this.stringsMap.get(str);\n\n    if (idx !== undefined) {\n      return idx;\n    }\n\n    idx = this.strings.push(str) - 1;\n    this.stringsMap.set(str, idx);\n    return idx;\n  }\n\n}\n/**\n * Takes v8 profile and populates sample, location, and function fields of\n * profile.proto.\n *\n * @param profile - profile.proto with empty sample, location, and function\n * fields.\n * @param root - root of v8 profile tree describing samples to be appended\n * to profile.\n * @param appendToSamples - function which converts entry to sample(s)  and\n * appends these to end of an array of samples.\n * @param stringTable - string table for the existing profile.\n */\n\n\nfunction serialize(profile, root, appendToSamples, stringTable, ignoreSamplesPath, sourceMapper) {\n  const samples = [];\n  const locations = [];\n  const functions = [];\n  const functionIdMap = new Map();\n  const locationIdMap = new Map();\n  const entries = root.children.map(n => ({\n    node: n,\n    stack: []\n  }));\n\n  while (entries.length > 0) {\n    const entry = entries.pop();\n    const node = entry.node;\n\n    if (ignoreSamplesPath && node.scriptName.indexOf(ignoreSamplesPath) > -1) {\n      continue;\n    }\n\n    if (node.name === '(idle)' || node.name === '(program)') continue;\n    const stack = entry.stack;\n    const location = getLocation(node, sourceMapper);\n    stack.unshift(location.id);\n    appendToSamples(entry, samples);\n\n    for (const child of node.children) {\n      entries.push({\n        node: child,\n        stack: stack.slice()\n      });\n    }\n  }\n\n  profile.sample = samples;\n  profile.location = locations;\n  profile.function = functions;\n  profile.stringTable = stringTable.strings;\n\n  function getLocation(node, sourceMapper) {\n    let profLoc = {\n      file: node.scriptName || '',\n      line: node.lineNumber,\n      column: node.columnNumber,\n      name: node.name\n    };\n\n    if (profLoc.line) {\n      if (sourceMapper && isGeneratedLocation(profLoc)) {\n        profLoc = sourceMapper.mappingInfo(profLoc);\n      }\n    }\n\n    const keyStr = `${node.scriptId}:${profLoc.line}:${profLoc.column}:${profLoc.name}`;\n    let id = locationIdMap.get(keyStr);\n\n    if (id !== undefined) {\n      // id is index+1, since 0 is not valid id.\n      return locations[id - 1];\n    }\n\n    id = locations.length + 1;\n    locationIdMap.set(keyStr, id);\n    const line = getLine(node.scriptId, profLoc.file, profLoc.name, profLoc.line);\n    const location = new profile_1.perftools.profiles.Location({\n      id,\n      line: [line]\n    });\n    locations.push(location);\n    return location;\n  }\n\n  function getLine(scriptId, scriptName, name, line) {\n    return new profile_1.perftools.profiles.Line({\n      functionId: getFunction(scriptId, scriptName, name).id,\n      line\n    });\n  }\n\n  function getFunction(scriptId, scriptName, name) {\n    const keyStr = `${scriptId}:${name}`;\n    let id = functionIdMap.get(keyStr);\n\n    if (id !== undefined) {\n      // id is index+1, since 0 is not valid id.\n      return functions[id - 1];\n    }\n\n    id = functions.length + 1;\n    functionIdMap.set(keyStr, id);\n    const nameId = stringTable.getIndexOrAdd(name || '(anonymous)');\n    const f = new profile_1.perftools.profiles.Function({\n      id,\n      name: nameId,\n      systemName: nameId,\n      filename: stringTable.getIndexOrAdd(scriptName || '')\n    });\n    functions.push(f);\n    return f;\n  }\n}\n/**\n * @return value type for sample counts (type:sample, units:count), and\n * adds strings used in this value type to the table.\n */\n\n\nfunction createSampleCountValueType(table) {\n  return new profile_1.perftools.profiles.ValueType({\n    type: table.getIndexOrAdd('sample'),\n    unit: table.getIndexOrAdd('count')\n  });\n}\n/**\n * @return value type for time samples (type:wall, units:nanoseconds), and\n * adds strings used in this value type to the table.\n */\n\n\nfunction createTimeValueType(table) {\n  return new profile_1.perftools.profiles.ValueType({\n    type: table.getIndexOrAdd('wall'),\n    unit: table.getIndexOrAdd('nanoseconds')\n  });\n}\n/**\n * @return value type for object counts (type:objects, units:count), and\n * adds strings used in this value type to the table.\n */\n\n\nfunction createObjectCountValueType(table) {\n  return new profile_1.perftools.profiles.ValueType({\n    type: table.getIndexOrAdd('objects'),\n    unit: table.getIndexOrAdd('count')\n  });\n}\n/**\n * @return value type for memory allocations (type:space, units:bytes), and\n * adds strings used in this value type to the table.\n */\n\n\nfunction createAllocationValueType(table) {\n  return new profile_1.perftools.profiles.ValueType({\n    type: table.getIndexOrAdd('space'),\n    unit: table.getIndexOrAdd('bytes')\n  });\n}\n/**\n * Converts v8 time profile into into a profile proto.\n * (https://github.com/google/pprof/blob/master/proto/profile.proto)\n *\n * @param prof - profile to be converted.\n * @param intervalMicros - average time (microseconds) between samples.\n */\n\n\nfunction serializeTimeProfile(prof, intervalMicros, sourceMapper) {\n  const intervalNanos = intervalMicros * 1000;\n\n  const appendTimeEntryToSamples = (entry, samples) => {\n    if (entry.node.hitCount > 0) {\n      const sample = new profile_1.perftools.profiles.Sample({\n        locationId: entry.stack,\n        value: [entry.node.hitCount, entry.node.hitCount * intervalNanos]\n      });\n      samples.push(sample);\n    }\n  };\n\n  const stringTable = new StringTable();\n  const sampleValueType = createSampleCountValueType(stringTable);\n  const timeValueType = createTimeValueType(stringTable);\n  const profile = {\n    sampleType: [sampleValueType, timeValueType],\n    timeNanos: Date.now() * 1000 * 1000,\n    durationNanos: (prof.endTime - prof.startTime) * 1000,\n    periodType: timeValueType,\n    period: intervalMicros\n  };\n  serialize(profile, prof.topDownRoot, appendTimeEntryToSamples, stringTable, undefined, sourceMapper);\n  return profile;\n}\n\nexports.serializeTimeProfile = serializeTimeProfile;\n/**\n * Converts v8 heap profile into into a profile proto.\n * (https://github.com/google/pprof/blob/master/proto/profile.proto)\n *\n * @param prof - profile to be converted.\n * @param startTimeNanos - start time of profile, in nanoseconds (POSIX time).\n * @param durationsNanos - duration of the profile (wall clock time) in\n * nanoseconds.\n * @param intervalBytes - bytes allocated between samples.\n */\n\nfunction serializeHeapProfile(prof, startTimeNanos, intervalBytes, ignoreSamplesPath, sourceMapper) {\n  const appendHeapEntryToSamples = (entry, samples) => {\n    if (entry.node.allocations.length > 0) {\n      for (const alloc of entry.node.allocations) {\n        const sample = new profile_1.perftools.profiles.Sample({\n          locationId: entry.stack,\n          value: [alloc.count, alloc.sizeBytes * alloc.count] // TODO: add tag for allocation size\n\n        });\n        samples.push(sample);\n      }\n    }\n  };\n\n  const stringTable = new StringTable();\n  const sampleValueType = createObjectCountValueType(stringTable);\n  const allocationValueType = createAllocationValueType(stringTable);\n  const profile = {\n    sampleType: [sampleValueType, allocationValueType],\n    timeNanos: startTimeNanos,\n    periodType: allocationValueType,\n    period: intervalBytes\n  };\n  serialize(profile, prof, appendHeapEntryToSamples, stringTable, ignoreSamplesPath, sourceMapper);\n  return profile;\n}\n\nexports.serializeHeapProfile = serializeHeapProfile;","map":{"version":3,"sources":["../../ts/src/profile-serializer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.serializeHeapProfile = exports.serializeTimeProfile = void 0;\nconst profile_1 = require(\"../../proto/profile\");\nfunction isGeneratedLocation(location) {\n    return (location.column !== undefined &&\n        location.line !== undefined &&\n        location.line > 0);\n}\n/**\n * Used to build string table and access strings and their ids within the table\n * when serializing a profile.\n */\nclass StringTable {\n    constructor() {\n        this.strings = [];\n        this.stringsMap = new Map();\n        this.getIndexOrAdd('');\n    }\n    /**\n     * @return index of str within the table. Also adds str to string table if\n     * str is not in the table already.\n     */\n    getIndexOrAdd(str) {\n        let idx = this.stringsMap.get(str);\n        if (idx !== undefined) {\n            return idx;\n        }\n        idx = this.strings.push(str) - 1;\n        this.stringsMap.set(str, idx);\n        return idx;\n    }\n}\n/**\n * Takes v8 profile and populates sample, location, and function fields of\n * profile.proto.\n *\n * @param profile - profile.proto with empty sample, location, and function\n * fields.\n * @param root - root of v8 profile tree describing samples to be appended\n * to profile.\n * @param appendToSamples - function which converts entry to sample(s)  and\n * appends these to end of an array of samples.\n * @param stringTable - string table for the existing profile.\n */\nfunction serialize(profile, root, appendToSamples, stringTable, ignoreSamplesPath, sourceMapper) {\n    const samples = [];\n    const locations = [];\n    const functions = [];\n    const functionIdMap = new Map();\n    const locationIdMap = new Map();\n    const entries = root.children.map((n) => ({\n        node: n,\n        stack: [],\n    }));\n    while (entries.length > 0) {\n        const entry = entries.pop();\n        const node = entry.node;\n        if (ignoreSamplesPath && node.scriptName.indexOf(ignoreSamplesPath) > -1) {\n            continue;\n        }\n        if (node.name === '(idle)' || node.name === '(program)')\n            continue;\n        const stack = entry.stack;\n        const location = getLocation(node, sourceMapper);\n        stack.unshift(location.id);\n        appendToSamples(entry, samples);\n        for (const child of node.children) {\n            entries.push({ node: child, stack: stack.slice() });\n        }\n    }\n    profile.sample = samples;\n    profile.location = locations;\n    profile.function = functions;\n    profile.stringTable = stringTable.strings;\n    function getLocation(node, sourceMapper) {\n        let profLoc = {\n            file: node.scriptName || '',\n            line: node.lineNumber,\n            column: node.columnNumber,\n            name: node.name,\n        };\n        if (profLoc.line) {\n            if (sourceMapper && isGeneratedLocation(profLoc)) {\n                profLoc = sourceMapper.mappingInfo(profLoc);\n            }\n        }\n        const keyStr = `${node.scriptId}:${profLoc.line}:${profLoc.column}:${profLoc.name}`;\n        let id = locationIdMap.get(keyStr);\n        if (id !== undefined) {\n            // id is index+1, since 0 is not valid id.\n            return locations[id - 1];\n        }\n        id = locations.length + 1;\n        locationIdMap.set(keyStr, id);\n        const line = getLine(node.scriptId, profLoc.file, profLoc.name, profLoc.line);\n        const location = new profile_1.perftools.profiles.Location({ id, line: [line] });\n        locations.push(location);\n        return location;\n    }\n    function getLine(scriptId, scriptName, name, line) {\n        return new profile_1.perftools.profiles.Line({\n            functionId: getFunction(scriptId, scriptName, name).id,\n            line,\n        });\n    }\n    function getFunction(scriptId, scriptName, name) {\n        const keyStr = `${scriptId}:${name}`;\n        let id = functionIdMap.get(keyStr);\n        if (id !== undefined) {\n            // id is index+1, since 0 is not valid id.\n            return functions[id - 1];\n        }\n        id = functions.length + 1;\n        functionIdMap.set(keyStr, id);\n        const nameId = stringTable.getIndexOrAdd(name || '(anonymous)');\n        const f = new profile_1.perftools.profiles.Function({\n            id,\n            name: nameId,\n            systemName: nameId,\n            filename: stringTable.getIndexOrAdd(scriptName || ''),\n        });\n        functions.push(f);\n        return f;\n    }\n}\n/**\n * @return value type for sample counts (type:sample, units:count), and\n * adds strings used in this value type to the table.\n */\nfunction createSampleCountValueType(table) {\n    return new profile_1.perftools.profiles.ValueType({\n        type: table.getIndexOrAdd('sample'),\n        unit: table.getIndexOrAdd('count'),\n    });\n}\n/**\n * @return value type for time samples (type:wall, units:nanoseconds), and\n * adds strings used in this value type to the table.\n */\nfunction createTimeValueType(table) {\n    return new profile_1.perftools.profiles.ValueType({\n        type: table.getIndexOrAdd('wall'),\n        unit: table.getIndexOrAdd('nanoseconds'),\n    });\n}\n/**\n * @return value type for object counts (type:objects, units:count), and\n * adds strings used in this value type to the table.\n */\nfunction createObjectCountValueType(table) {\n    return new profile_1.perftools.profiles.ValueType({\n        type: table.getIndexOrAdd('objects'),\n        unit: table.getIndexOrAdd('count'),\n    });\n}\n/**\n * @return value type for memory allocations (type:space, units:bytes), and\n * adds strings used in this value type to the table.\n */\nfunction createAllocationValueType(table) {\n    return new profile_1.perftools.profiles.ValueType({\n        type: table.getIndexOrAdd('space'),\n        unit: table.getIndexOrAdd('bytes'),\n    });\n}\n/**\n * Converts v8 time profile into into a profile proto.\n * (https://github.com/google/pprof/blob/master/proto/profile.proto)\n *\n * @param prof - profile to be converted.\n * @param intervalMicros - average time (microseconds) between samples.\n */\nfunction serializeTimeProfile(prof, intervalMicros, sourceMapper) {\n    const intervalNanos = intervalMicros * 1000;\n    const appendTimeEntryToSamples = (entry, samples) => {\n        if (entry.node.hitCount > 0) {\n            const sample = new profile_1.perftools.profiles.Sample({\n                locationId: entry.stack,\n                value: [entry.node.hitCount, entry.node.hitCount * intervalNanos],\n            });\n            samples.push(sample);\n        }\n    };\n    const stringTable = new StringTable();\n    const sampleValueType = createSampleCountValueType(stringTable);\n    const timeValueType = createTimeValueType(stringTable);\n    const profile = {\n        sampleType: [sampleValueType, timeValueType],\n        timeNanos: Date.now() * 1000 * 1000,\n        durationNanos: (prof.endTime - prof.startTime) * 1000,\n        periodType: timeValueType,\n        period: intervalMicros,\n    };\n    serialize(profile, prof.topDownRoot, appendTimeEntryToSamples, stringTable, undefined, sourceMapper);\n    return profile;\n}\nexports.serializeTimeProfile = serializeTimeProfile;\n/**\n * Converts v8 heap profile into into a profile proto.\n * (https://github.com/google/pprof/blob/master/proto/profile.proto)\n *\n * @param prof - profile to be converted.\n * @param startTimeNanos - start time of profile, in nanoseconds (POSIX time).\n * @param durationsNanos - duration of the profile (wall clock time) in\n * nanoseconds.\n * @param intervalBytes - bytes allocated between samples.\n */\nfunction serializeHeapProfile(prof, startTimeNanos, intervalBytes, ignoreSamplesPath, sourceMapper) {\n    const appendHeapEntryToSamples = (entry, samples) => {\n        if (entry.node.allocations.length > 0) {\n            for (const alloc of entry.node.allocations) {\n                const sample = new profile_1.perftools.profiles.Sample({\n                    locationId: entry.stack,\n                    value: [alloc.count, alloc.sizeBytes * alloc.count],\n                    // TODO: add tag for allocation size\n                });\n                samples.push(sample);\n            }\n        }\n    };\n    const stringTable = new StringTable();\n    const sampleValueType = createObjectCountValueType(stringTable);\n    const allocationValueType = createAllocationValueType(stringTable);\n    const profile = {\n        sampleType: [sampleValueType, allocationValueType],\n        timeNanos: startTimeNanos,\n        periodType: allocationValueType,\n        period: intervalBytes,\n    };\n    serialize(profile, prof, appendHeapEntryToSamples, stringTable, ignoreSamplesPath, sourceMapper);\n    return profile;\n}\nexports.serializeHeapProfile = serializeHeapProfile;\n//# sourceMappingURL=profile-serializer.js.map"]},"metadata":{},"sourceType":"script"}