{"ast":null,"code":"'use strict';\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler');\n\nfunction createWrapCommand(tracer, config) {\n  return function wrapCommand(command) {\n    return function commandWithTrace(queryCompiler, server) {\n      const scope = tracer.scope();\n      const childOf = scope.active();\n      const span = tracer.startSpan('memcached.command', {\n        childOf,\n        tags: {\n          'span.kind': 'client',\n          'span.type': 'memcached',\n          'service.name': config.service || `${tracer._service}-memcached`\n        }\n      });\n      analyticsSampler.sample(span, config.measured);\n      arguments[0] = wrapQueryCompiler(queryCompiler, this, server, scope, span);\n      return scope.bind(command, span).apply(this, arguments);\n    };\n  };\n}\n\nfunction wrapQueryCompiler(original, client, server, scope, span) {\n  const parent = scope.active();\n  return function () {\n    const query = original.apply(this, arguments);\n    const callback = query.callback;\n    span.addTags({\n      'resource.name': query.type,\n      'memcached.command': query.command\n    });\n    addHost(span, client, server, query);\n    query.callback = scope.bind(function (err) {\n      addError(span, err);\n      span.finish();\n      return callback.apply(this, arguments);\n    }, parent);\n    return query;\n  };\n}\n\nfunction addHost(span, client, server, query) {\n  const address = getAddress(client, server, query);\n\n  if (address) {\n    span.addTags({\n      'out.host': address[0],\n      'out.port': address[1]\n    });\n  }\n}\n\nfunction addError(span, error) {\n  if (error) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    });\n  }\n\n  return error;\n}\n\nfunction getAddress(client, server, query) {\n  if (!server) {\n    if (client.servers.length === 1) {\n      server = client.servers[0];\n    } else {\n      let redundancy = client.redundancy && client.redundancy < client.servers.length;\n      const queryRedundancy = query.redundancyEnabled;\n\n      if (redundancy && queryRedundancy) {\n        redundancy = client.HashRing.range(query.key, client.redundancy + 1, true);\n        server = redundancy.shift();\n      } else {\n        server = client.HashRing.get(query.key);\n      }\n    }\n  }\n\n  return server && server.split(':');\n}\n\nmodule.exports = {\n  name: 'memcached',\n  versions: ['>=2.2'],\n\n  patch(Memcached, tracer, config) {\n    this.wrap(Memcached.prototype, 'command', createWrapCommand(tracer, config));\n  },\n\n  unpatch(Memcached) {\n    this.unwrap(Memcached.prototype, 'command');\n  }\n\n};","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-memcached/src/index.js"],"names":["analyticsSampler","require","createWrapCommand","tracer","config","wrapCommand","command","commandWithTrace","queryCompiler","server","scope","childOf","active","span","startSpan","tags","service","_service","sample","measured","arguments","wrapQueryCompiler","bind","apply","original","client","parent","query","callback","addTags","type","addHost","err","addError","finish","address","getAddress","error","name","message","stack","servers","length","redundancy","queryRedundancy","redundancyEnabled","HashRing","range","key","shift","get","split","module","exports","versions","patch","Memcached","wrap","prototype","unpatch","unwrap"],"mappings":"AAAA;;AAEA,MAAMA,gBAAgB,GAAGC,OAAO,CAAC,sCAAD,CAAhC;;AAEA,SAASC,iBAAT,CAA4BC,MAA5B,EAAoCC,MAApC,EAA4C;AAC1C,SAAO,SAASC,WAAT,CAAsBC,OAAtB,EAA+B;AACpC,WAAO,SAASC,gBAAT,CAA2BC,aAA3B,EAA0CC,MAA1C,EAAkD;AACvD,YAAMC,KAAK,GAAGP,MAAM,CAACO,KAAP,EAAd;AACA,YAAMC,OAAO,GAAGD,KAAK,CAACE,MAAN,EAAhB;AACA,YAAMC,IAAI,GAAGV,MAAM,CAACW,SAAP,CAAiB,mBAAjB,EAAsC;AACjDH,QAAAA,OADiD;AAEjDI,QAAAA,IAAI,EAAE;AACJ,uBAAa,QADT;AAEJ,uBAAa,WAFT;AAGJ,0BAAgBX,MAAM,CAACY,OAAP,IAAmB,GAAEb,MAAM,CAACc,QAAS;AAHjD;AAF2C,OAAtC,CAAb;AASAjB,MAAAA,gBAAgB,CAACkB,MAAjB,CAAwBL,IAAxB,EAA8BT,MAAM,CAACe,QAArC;AAEAC,MAAAA,SAAS,CAAC,CAAD,CAAT,GAAeC,iBAAiB,CAACb,aAAD,EAAgB,IAAhB,EAAsBC,MAAtB,EAA8BC,KAA9B,EAAqCG,IAArC,CAAhC;AAEA,aAAOH,KAAK,CAACY,IAAN,CAAWhB,OAAX,EAAoBO,IAApB,EAA0BU,KAA1B,CAAgC,IAAhC,EAAsCH,SAAtC,CAAP;AACD,KAjBD;AAkBD,GAnBD;AAoBD;;AAED,SAASC,iBAAT,CAA4BG,QAA5B,EAAsCC,MAAtC,EAA8ChB,MAA9C,EAAsDC,KAAtD,EAA6DG,IAA7D,EAAmE;AACjE,QAAMa,MAAM,GAAGhB,KAAK,CAACE,MAAN,EAAf;AAEA,SAAO,YAAY;AACjB,UAAMe,KAAK,GAAGH,QAAQ,CAACD,KAAT,CAAe,IAAf,EAAqBH,SAArB,CAAd;AACA,UAAMQ,QAAQ,GAAGD,KAAK,CAACC,QAAvB;AAEAf,IAAAA,IAAI,CAACgB,OAAL,CAAa;AACX,uBAAiBF,KAAK,CAACG,IADZ;AAEX,2BAAqBH,KAAK,CAACrB;AAFhB,KAAb;AAKAyB,IAAAA,OAAO,CAAClB,IAAD,EAAOY,MAAP,EAAehB,MAAf,EAAuBkB,KAAvB,CAAP;AAEAA,IAAAA,KAAK,CAACC,QAAN,GAAiBlB,KAAK,CAACY,IAAN,CAAW,UAAUU,GAAV,EAAe;AACzCC,MAAAA,QAAQ,CAACpB,IAAD,EAAOmB,GAAP,CAAR;AAEAnB,MAAAA,IAAI,CAACqB,MAAL;AAEA,aAAON,QAAQ,CAACL,KAAT,CAAe,IAAf,EAAqBH,SAArB,CAAP;AACD,KANgB,EAMdM,MANc,CAAjB;AAQA,WAAOC,KAAP;AACD,GApBD;AAqBD;;AAED,SAASI,OAAT,CAAkBlB,IAAlB,EAAwBY,MAAxB,EAAgChB,MAAhC,EAAwCkB,KAAxC,EAA+C;AAC7C,QAAMQ,OAAO,GAAGC,UAAU,CAACX,MAAD,EAAShB,MAAT,EAAiBkB,KAAjB,CAA1B;;AAEA,MAAIQ,OAAJ,EAAa;AACXtB,IAAAA,IAAI,CAACgB,OAAL,CAAa;AACX,kBAAYM,OAAO,CAAC,CAAD,CADR;AAEX,kBAAYA,OAAO,CAAC,CAAD;AAFR,KAAb;AAID;AACF;;AAED,SAASF,QAAT,CAAmBpB,IAAnB,EAAyBwB,KAAzB,EAAgC;AAC9B,MAAIA,KAAJ,EAAW;AACTxB,IAAAA,IAAI,CAACgB,OAAL,CAAa;AACX,oBAAcQ,KAAK,CAACC,IADT;AAEX,mBAAaD,KAAK,CAACE,OAFR;AAGX,qBAAeF,KAAK,CAACG;AAHV,KAAb;AAKD;;AAED,SAAOH,KAAP;AACD;;AAED,SAASD,UAAT,CAAqBX,MAArB,EAA6BhB,MAA7B,EAAqCkB,KAArC,EAA4C;AAC1C,MAAI,CAAClB,MAAL,EAAa;AACX,QAAIgB,MAAM,CAACgB,OAAP,CAAeC,MAAf,KAA0B,CAA9B,EAAiC;AAC/BjC,MAAAA,MAAM,GAAGgB,MAAM,CAACgB,OAAP,CAAe,CAAf,CAAT;AACD,KAFD,MAEO;AACL,UAAIE,UAAU,GAAGlB,MAAM,CAACkB,UAAP,IAAqBlB,MAAM,CAACkB,UAAP,GAAoBlB,MAAM,CAACgB,OAAP,CAAeC,MAAzE;AACA,YAAME,eAAe,GAAGjB,KAAK,CAACkB,iBAA9B;;AAEA,UAAIF,UAAU,IAAIC,eAAlB,EAAmC;AACjCD,QAAAA,UAAU,GAAGlB,MAAM,CAACqB,QAAP,CAAgBC,KAAhB,CAAsBpB,KAAK,CAACqB,GAA5B,EAAkCvB,MAAM,CAACkB,UAAP,GAAoB,CAAtD,EAA0D,IAA1D,CAAb;AACAlC,QAAAA,MAAM,GAAGkC,UAAU,CAACM,KAAX,EAAT;AACD,OAHD,MAGO;AACLxC,QAAAA,MAAM,GAAGgB,MAAM,CAACqB,QAAP,CAAgBI,GAAhB,CAAoBvB,KAAK,CAACqB,GAA1B,CAAT;AACD;AACF;AACF;;AAED,SAAOvC,MAAM,IAAIA,MAAM,CAAC0C,KAAP,CAAa,GAAb,CAAjB;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiB;AACff,EAAAA,IAAI,EAAE,WADS;AAEfgB,EAAAA,QAAQ,EAAE,CAAC,OAAD,CAFK;;AAGfC,EAAAA,KAAK,CAAEC,SAAF,EAAarD,MAAb,EAAqBC,MAArB,EAA6B;AAChC,SAAKqD,IAAL,CAAUD,SAAS,CAACE,SAApB,EAA+B,SAA/B,EAA0CxD,iBAAiB,CAACC,MAAD,EAASC,MAAT,CAA3D;AACD,GALc;;AAMfuD,EAAAA,OAAO,CAAEH,SAAF,EAAa;AAClB,SAAKI,MAAL,CAAYJ,SAAS,CAACE,SAAtB,EAAiC,SAAjC;AACD;;AARc,CAAjB","sourcesContent":["'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction createWrapCommand (tracer, config) {\n  return function wrapCommand (command) {\n    return function commandWithTrace (queryCompiler, server) {\n      const scope = tracer.scope()\n      const childOf = scope.active()\n      const span = tracer.startSpan('memcached.command', {\n        childOf,\n        tags: {\n          'span.kind': 'client',\n          'span.type': 'memcached',\n          'service.name': config.service || `${tracer._service}-memcached`\n        }\n      })\n\n      analyticsSampler.sample(span, config.measured)\n\n      arguments[0] = wrapQueryCompiler(queryCompiler, this, server, scope, span)\n\n      return scope.bind(command, span).apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapQueryCompiler (original, client, server, scope, span) {\n  const parent = scope.active()\n\n  return function () {\n    const query = original.apply(this, arguments)\n    const callback = query.callback\n\n    span.addTags({\n      'resource.name': query.type,\n      'memcached.command': query.command\n    })\n\n    addHost(span, client, server, query)\n\n    query.callback = scope.bind(function (err) {\n      addError(span, err)\n\n      span.finish()\n\n      return callback.apply(this, arguments)\n    }, parent)\n\n    return query\n  }\n}\n\nfunction addHost (span, client, server, query) {\n  const address = getAddress(client, server, query)\n\n  if (address) {\n    span.addTags({\n      'out.host': address[0],\n      'out.port': address[1]\n    })\n  }\n}\n\nfunction addError (span, error) {\n  if (error) {\n    span.addTags({\n      'error.type': error.name,\n      'error.msg': error.message,\n      'error.stack': error.stack\n    })\n  }\n\n  return error\n}\n\nfunction getAddress (client, server, query) {\n  if (!server) {\n    if (client.servers.length === 1) {\n      server = client.servers[0]\n    } else {\n      let redundancy = client.redundancy && client.redundancy < client.servers.length\n      const queryRedundancy = query.redundancyEnabled\n\n      if (redundancy && queryRedundancy) {\n        redundancy = client.HashRing.range(query.key, (client.redundancy + 1), true)\n        server = redundancy.shift()\n      } else {\n        server = client.HashRing.get(query.key)\n      }\n    }\n  }\n\n  return server && server.split(':')\n}\n\nmodule.exports = {\n  name: 'memcached',\n  versions: ['>=2.2'],\n  patch (Memcached, tracer, config) {\n    this.wrap(Memcached.prototype, 'command', createWrapCommand(tracer, config))\n  },\n  unpatch (Memcached) {\n    this.unwrap(Memcached.prototype, 'command')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}