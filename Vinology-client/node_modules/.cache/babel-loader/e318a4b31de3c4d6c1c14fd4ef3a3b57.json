{"ast":null,"code":"const fs = require('fs');\n/**\n * Replace any characters that can't be sent on with an underscore\n */\n\n\nfunction sanitizeTags(value, telegraf) {\n  const blacklist = telegraf ? /:|\\||,/g : /:|\\||@|,/g; // Replace reserved chars with underscores.\n\n  return String(value).replace(blacklist, '_');\n}\n/**\n * Format tags properly before sending on\n */\n\n\nfunction formatTags(tags, telegraf) {\n  if (Array.isArray(tags)) {\n    return tags;\n  } else {\n    return Object.keys(tags).map(key => {\n      return `${sanitizeTags(key, telegraf)}:${sanitizeTags(tags[key], telegraf)}`;\n    });\n  }\n}\n/**\n * Overrides tags in parent with tags from child with the same name (case sensitive) and return the result as new\n * array. parent and child are not mutated.\n */\n\n\nfunction overrideTags(parent, child, telegraf) {\n  const childCopy = {};\n  const toAppend = [];\n  formatTags(child, telegraf).forEach(tag => {\n    const idx = typeof tag === 'string' ? tag.indexOf(':') : -1;\n\n    if (idx < 1) {\n      // Not found or first character\n      toAppend.push(tag);\n    } else {\n      const key = tag.substring(0, idx);\n      const value = tag.substring(idx + 1);\n      childCopy[key] = childCopy[key] || [];\n      childCopy[key].push(value);\n    }\n  });\n  const result = parent.filter(tag => {\n    const idx = typeof tag === 'string' ? tag.indexOf(':') : -1;\n\n    if (idx < 1) {\n      // Not found or first character\n      return true;\n    }\n\n    const key = tag.substring(0, idx);\n    return !childCopy.hasOwnProperty(key);\n  });\n  Object.keys(childCopy).forEach(key => {\n    for (const value of childCopy[key]) {\n      result.push(`${key}:${value}`);\n    }\n  });\n  return result.concat(toAppend);\n}\n/**\n * Formats a date for use with DataDog\n */\n\n\nfunction formatDate(date) {\n  let timestamp;\n\n  if (date instanceof Date) {\n    // Datadog expects seconds.\n    timestamp = Math.round(date.getTime() / 1000);\n  } else if (date instanceof Number || typeof date === 'number') {\n    // Make sure it is an integer, not a float.\n    timestamp = Math.round(date);\n  }\n\n  return timestamp;\n}\n/**\n * Converts int to a string IP\n */\n\n\nfunction intToIP(int) {\n  const part1 = int & 255;\n  const part2 = int >> 8 & 255;\n  const part3 = int >> 16 & 255;\n  const part4 = int >> 24 & 255;\n  return `${part4}.${part3}.${part2}.${part1}`;\n}\n/**\n * Returns the system default interface on Linux\n */\n\n\nfunction getDefaultRoute() {\n  try {\n    const fileContents = fs.readFileSync('/proc/net/route', 'utf8'); // eslint-disable-line no-sync\n\n    const routes = fileContents.split('\\n');\n\n    for (const routeIdx in routes) {\n      const fields = routes[routeIdx].trim().split('\\t');\n\n      if (fields[1] === '00000000') {\n        const address = fields[2]; // Convert to little endian by splitting every 2 digits and reversing that list\n\n        const littleEndianAddress = address.match(/.{2}/g).reverse().join('');\n        return intToIP(parseInt(littleEndianAddress, 16));\n      }\n    }\n  } catch (e) {\n    console.error('Could not get default route from /proc/net/route');\n  }\n\n  return null;\n}\n\nmodule.exports = {\n  formatTags: formatTags,\n  overrideTags: overrideTags,\n  formatDate: formatDate,\n  getDefaultRoute: getDefaultRoute,\n  sanitizeTags: sanitizeTags\n};","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/hot-shots/lib/helpers.js"],"names":["fs","require","sanitizeTags","value","telegraf","blacklist","String","replace","formatTags","tags","Array","isArray","Object","keys","map","key","overrideTags","parent","child","childCopy","toAppend","forEach","tag","idx","indexOf","push","substring","result","filter","hasOwnProperty","concat","formatDate","date","timestamp","Date","Math","round","getTime","Number","intToIP","int","part1","part2","part3","part4","getDefaultRoute","fileContents","readFileSync","routes","split","routeIdx","fields","trim","address","littleEndianAddress","match","reverse","join","parseInt","e","console","error","module","exports"],"mappings":"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","sourcesContent":["const fs = require('fs');\n\n/**\n * Replace any characters that can't be sent on with an underscore\n */\nfunction sanitizeTags(value, telegraf) {\n  const blacklist = telegraf ? /:|\\||,/g : /:|\\||@|,/g;\n  // Replace reserved chars with underscores.\n  return String(value).replace(blacklist, '_');\n}\n\n/**\n * Format tags properly before sending on\n */\nfunction formatTags(tags, telegraf) {\n  if (Array.isArray(tags)) {\n    return tags;\n\n  } else {\n    return Object.keys(tags).map(key => {\n      return `${sanitizeTags(key, telegraf)}:${sanitizeTags(tags[key], telegraf)}`;\n    });\n  }\n}\n\n/**\n * Overrides tags in parent with tags from child with the same name (case sensitive) and return the result as new\n * array. parent and child are not mutated.\n */\nfunction overrideTags (parent, child, telegraf) {\n  const childCopy = {};\n  const toAppend = [];\n  formatTags(child, telegraf).forEach(tag => {\n    const idx = typeof tag === 'string' ? tag.indexOf(':') : -1;\n    if (idx < 1) { // Not found or first character\n      toAppend.push(tag);\n    } else {\n      const key = tag.substring(0, idx);\n      const value = tag.substring(idx + 1);\n      childCopy[key] = childCopy[key] || [];\n      childCopy[key].push(value);\n    }\n  });\n  const result = parent.filter(tag => {\n    const idx = typeof tag === 'string' ? tag.indexOf(':') : -1;\n    if (idx < 1) { // Not found or first character\n      return true;\n    }\n\n    const key = tag.substring(0, idx);\n\n    return !childCopy.hasOwnProperty(key);\n  });\n\n  Object.keys(childCopy).forEach(key => {\n    for (const value of childCopy[key]) {\n      result.push(`${key}:${value}`);\n    }\n  });\n  return result.concat(toAppend);\n}\n\n/**\n * Formats a date for use with DataDog\n */\nfunction formatDate(date) {\n  let timestamp;\n  if (date instanceof Date) {\n    // Datadog expects seconds.\n    timestamp = Math.round(date.getTime() / 1000);\n  } else if (date instanceof Number || typeof date === 'number') {\n    // Make sure it is an integer, not a float.\n    timestamp = Math.round(date);\n  }\n  return timestamp;\n}\n\n/**\n * Converts int to a string IP\n */\nfunction intToIP(int) {\n  const part1 = int & 255;\n  const part2 = ((int >> 8) & 255);\n  const part3 = ((int >> 16) & 255);\n  const part4 = ((int >> 24) & 255);\n\n  return `${part4}.${part3}.${part2}.${part1}`;\n}\n\n/**\n * Returns the system default interface on Linux\n */\nfunction getDefaultRoute() {\n  try {\n    const fileContents = fs.readFileSync('/proc/net/route', 'utf8'); // eslint-disable-line no-sync\n    const routes = fileContents.split('\\n');\n    for (const routeIdx in routes) {\n      const fields = routes[routeIdx].trim().split('\\t');\n      if (fields[1] === '00000000') {\n        const address = fields[2];\n        // Convert to little endian by splitting every 2 digits and reversing that list\n        const littleEndianAddress = address.match(/.{2}/g).reverse().join('');\n        return intToIP(parseInt(littleEndianAddress, 16));\n      }\n    }\n  } catch (e) {\n    console.error('Could not get default route from /proc/net/route');\n  }\n  return null;\n}\n\nmodule.exports = {\n  formatTags: formatTags,\n  overrideTags: overrideTags,\n  formatDate: formatDate,\n  getDefaultRoute: getDefaultRoute,\n  sanitizeTags: sanitizeTags\n};\n"]},"metadata":{},"sourceType":"script"}