{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scan = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\"); // TODO: Make this more precise.\n\n\nconst findit = require('findit2'); // TODO: Make this more precise.\n\n\nconst split = require('split');\n\nclass ScanResultsImpl {\n  /**\n   * Encapsulates the results of a filesystem scan with methods\n   * to easily select scan information or filenames for a\n   * specific subset of the files listed in the scan results.\n   *\n   * @param stats An object that contains filenames\n   *  as keys where each key maps to an object containing the\n   *  hash and number of lines for the specified file.  This\n   *  information is accessed via the `hash` and `lines`\n   *  attributes respectively\n   * @param hash A hashcode computed from the contents of all the files.\n   */\n  constructor(stats, errorMap, hash) {\n    this.stats = stats;\n    this.errorMap = errorMap;\n    this.hash = hash;\n  }\n\n  errors() {\n    return this.errorMap;\n  }\n  /**\n   * Used to get all of the file scan results.\n   */\n\n\n  all() {\n    return this.stats;\n  }\n  /**\n   * Used to get the only the file paths in the scan results\n   * where the filenames match the specified regex and are\n   * returned with the each relative to the specified base\n   * directory.\n   *\n   * @param {regex} regex The regex that tests a filename to\n   *  determine if the scan results for that filename should\n   *  be included in the returned results.\n   * @param {string} baseDir The absolute path to the directory\n   *  from which all of the returned paths should be relative\n   *  to.\n   */\n\n\n  selectFiles(regex, baseDir) {\n    // ensure the base directory has only a single trailing path separator\n    baseDir = path.normalize(baseDir + path.sep);\n    return Object.keys(this.stats).filter(file => {\n      return file && regex.test(file);\n    }).map(file => {\n      return path.normalize(file).replace(baseDir, '');\n    });\n  }\n\n}\n\nfunction scan(shouldHash, baseDir, regex) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const fileList = yield findFiles(baseDir, regex);\n    return computeStats(fileList, shouldHash);\n  });\n}\n\nexports.scan = scan;\n/**\n * This function accept an array of filenames and computes a unique hash-code\n * based on the contents.\n *\n * @param {!Array<string>} fileList array of filenames\n * @param {Boolean} shouldHash whether a hash should be computed\n * @param {!function(?Error, ?string, Object)} callback error-back style callback\n *    returning the hash-code and an object containing file statistics.\n */\n// TODO: Typescript: Fix the docs associated with this function to match the\n// call signature\n\nfunction computeStats(fileList, shouldHash) {\n  // eslint-disable-next-line no-async-promise-executor\n  return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n    // return a valid, if fake, result when there are no js files to hash.\n    if (fileList.length === 0) {\n      resolve(new ScanResultsImpl({}, new Map(), 'EMPTY-no-js-files'));\n      return;\n    } // TODO: Address the case where the array contains `undefined`.\n\n\n    const hashes = [];\n    const statistics = {};\n    const errors = new Map();\n\n    for (const filename of fileList) {\n      try {\n        const fileStats = yield statsForFile(filename, shouldHash);\n\n        if (shouldHash) {\n          hashes.push(fileStats.hash);\n        }\n\n        statistics[filename] = fileStats;\n      } catch (err) {\n        errors.set(filename, err);\n      }\n    }\n\n    let hash;\n\n    if (shouldHash) {\n      // Sort the hashes to get a deterministic order as the files may\n      // not be in the same order each time we scan the disk.\n      const buffer = hashes.sort().join();\n      const sha1 = crypto.createHash('sha1').update(buffer).digest('hex');\n      hash = 'SHA1-' + sha1;\n    }\n\n    resolve(new ScanResultsImpl(statistics, errors, hash));\n  }));\n}\n/**\n * Given a base-directory, this function scans the subtree and finds all the js\n * files. .git and node_module subdirectories are ignored.\n * @param {!string} baseDir top-level directory to scan\n * @param {!regex} regex the regular expression that specifies the types of\n *  files to find based on their filename\n * @param {!function(?Error, Array<string>)} callback error-back callback\n */\n\n\nfunction findFiles(baseDir, regex) {\n  return new Promise((resolve, reject) => {\n    let error;\n\n    if (!baseDir) {\n      reject(new Error('hasher.findJSFiles requires a baseDir argument'));\n      return;\n    }\n\n    const find = findit(baseDir);\n    const fileList = [];\n    find.on('error', err => {\n      error = err;\n      return;\n    });\n    find.on('directory', (dir, ignore, stop) => {\n      const base = path.basename(dir);\n\n      if (base === '.git' || base === 'node_modules') {\n        stop(); // do not descend\n      }\n    });\n    find.on('file', file => {\n      if (regex.test(file)) {\n        fileList.push(file);\n      }\n    });\n    find.on('end', () => {\n      // Note: the `end` event fires even after an error\n      if (error) {\n        reject(error);\n      } else {\n        resolve(fileList);\n      }\n    });\n  });\n}\n/**\n * Compute a sha hash for the given file and record line counts along the way.\n * @param {string} filename\n * @param {Boolean} shouldHash whether a hash should be computed\n * @param {function} cb errorback style callback which returns the sha string\n * @private\n */\n\n\nfunction statsForFile(filename, shouldHash) {\n  return new Promise((resolve, reject) => {\n    const reader = fs.createReadStream(filename);\n    reader.on('error', err => {\n      reject(err);\n    });\n    reader.on('open', () => {\n      let shasum;\n\n      if (shouldHash) {\n        shasum = crypto.createHash('sha1');\n      }\n\n      let lines = 0;\n      let error;\n      const byLine = reader.pipe(split());\n      byLine.on('error', e => {\n        error = e;\n      });\n      byLine.on('data', d => {\n        if (shouldHash) {\n          shasum.update(d);\n        }\n\n        lines++;\n      });\n      byLine.on('end', () => {\n        if (error) {\n          reject(error);\n        } else {\n          const hash = shouldHash ? shasum.digest('hex') : undefined;\n          resolve({\n            hash,\n            lines\n          });\n        }\n      });\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../../ts/third_party/cloud-debug-nodejs/src/agent/io/scanner.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scan = void 0;\nconst crypto = require(\"crypto\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n// TODO: Make this more precise.\nconst findit = require('findit2');\n// TODO: Make this more precise.\nconst split = require('split');\nclass ScanResultsImpl {\n    /**\n     * Encapsulates the results of a filesystem scan with methods\n     * to easily select scan information or filenames for a\n     * specific subset of the files listed in the scan results.\n     *\n     * @param stats An object that contains filenames\n     *  as keys where each key maps to an object containing the\n     *  hash and number of lines for the specified file.  This\n     *  information is accessed via the `hash` and `lines`\n     *  attributes respectively\n     * @param hash A hashcode computed from the contents of all the files.\n     */\n    constructor(stats, errorMap, hash) {\n        this.stats = stats;\n        this.errorMap = errorMap;\n        this.hash = hash;\n    }\n    errors() {\n        return this.errorMap;\n    }\n    /**\n     * Used to get all of the file scan results.\n     */\n    all() {\n        return this.stats;\n    }\n    /**\n     * Used to get the only the file paths in the scan results\n     * where the filenames match the specified regex and are\n     * returned with the each relative to the specified base\n     * directory.\n     *\n     * @param {regex} regex The regex that tests a filename to\n     *  determine if the scan results for that filename should\n     *  be included in the returned results.\n     * @param {string} baseDir The absolute path to the directory\n     *  from which all of the returned paths should be relative\n     *  to.\n     */\n    selectFiles(regex, baseDir) {\n        // ensure the base directory has only a single trailing path separator\n        baseDir = path.normalize(baseDir + path.sep);\n        return Object.keys(this.stats)\n            .filter(file => {\n            return file && regex.test(file);\n        })\n            .map(file => {\n            return path.normalize(file).replace(baseDir, '');\n        });\n    }\n}\nfunction scan(shouldHash, baseDir, regex) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const fileList = yield findFiles(baseDir, regex);\n        return computeStats(fileList, shouldHash);\n    });\n}\nexports.scan = scan;\n/**\n * This function accept an array of filenames and computes a unique hash-code\n * based on the contents.\n *\n * @param {!Array<string>} fileList array of filenames\n * @param {Boolean} shouldHash whether a hash should be computed\n * @param {!function(?Error, ?string, Object)} callback error-back style callback\n *    returning the hash-code and an object containing file statistics.\n */\n// TODO: Typescript: Fix the docs associated with this function to match the\n// call signature\nfunction computeStats(fileList, shouldHash) {\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n        // return a valid, if fake, result when there are no js files to hash.\n        if (fileList.length === 0) {\n            resolve(new ScanResultsImpl({}, new Map(), 'EMPTY-no-js-files'));\n            return;\n        }\n        // TODO: Address the case where the array contains `undefined`.\n        const hashes = [];\n        const statistics = {};\n        const errors = new Map();\n        for (const filename of fileList) {\n            try {\n                const fileStats = yield statsForFile(filename, shouldHash);\n                if (shouldHash) {\n                    hashes.push(fileStats.hash);\n                }\n                statistics[filename] = fileStats;\n            }\n            catch (err) {\n                errors.set(filename, err);\n            }\n        }\n        let hash;\n        if (shouldHash) {\n            // Sort the hashes to get a deterministic order as the files may\n            // not be in the same order each time we scan the disk.\n            const buffer = hashes.sort().join();\n            const sha1 = crypto.createHash('sha1').update(buffer).digest('hex');\n            hash = 'SHA1-' + sha1;\n        }\n        resolve(new ScanResultsImpl(statistics, errors, hash));\n    }));\n}\n/**\n * Given a base-directory, this function scans the subtree and finds all the js\n * files. .git and node_module subdirectories are ignored.\n * @param {!string} baseDir top-level directory to scan\n * @param {!regex} regex the regular expression that specifies the types of\n *  files to find based on their filename\n * @param {!function(?Error, Array<string>)} callback error-back callback\n */\nfunction findFiles(baseDir, regex) {\n    return new Promise((resolve, reject) => {\n        let error;\n        if (!baseDir) {\n            reject(new Error('hasher.findJSFiles requires a baseDir argument'));\n            return;\n        }\n        const find = findit(baseDir);\n        const fileList = [];\n        find.on('error', (err) => {\n            error = err;\n            return;\n        });\n        find.on('directory', (dir, ignore, stop) => {\n            const base = path.basename(dir);\n            if (base === '.git' || base === 'node_modules') {\n                stop(); // do not descend\n            }\n        });\n        find.on('file', (file) => {\n            if (regex.test(file)) {\n                fileList.push(file);\n            }\n        });\n        find.on('end', () => {\n            // Note: the `end` event fires even after an error\n            if (error) {\n                reject(error);\n            }\n            else {\n                resolve(fileList);\n            }\n        });\n    });\n}\n/**\n * Compute a sha hash for the given file and record line counts along the way.\n * @param {string} filename\n * @param {Boolean} shouldHash whether a hash should be computed\n * @param {function} cb errorback style callback which returns the sha string\n * @private\n */\nfunction statsForFile(filename, shouldHash) {\n    return new Promise((resolve, reject) => {\n        const reader = fs.createReadStream(filename);\n        reader.on('error', err => {\n            reject(err);\n        });\n        reader.on('open', () => {\n            let shasum;\n            if (shouldHash) {\n                shasum = crypto.createHash('sha1');\n            }\n            let lines = 0;\n            let error;\n            const byLine = reader.pipe(split());\n            byLine.on('error', (e) => {\n                error = e;\n            });\n            byLine.on('data', (d) => {\n                if (shouldHash) {\n                    shasum.update(d);\n                }\n                lines++;\n            });\n            byLine.on('end', () => {\n                if (error) {\n                    reject(error);\n                }\n                else {\n                    const hash = shouldHash ? shasum.digest('hex') : undefined;\n                    resolve({ hash, lines });\n                }\n            });\n        });\n    });\n}\n//# sourceMappingURL=scanner.js.map"]},"metadata":{},"sourceType":"script"}