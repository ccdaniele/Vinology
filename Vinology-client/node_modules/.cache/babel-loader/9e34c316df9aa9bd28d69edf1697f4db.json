{"ast":null,"code":"'use strict';\n\nconst METHODS = require('methods').concat('all');\n\nconst pathToRegExp = require('path-to-regexp');\n\nconst shimmer = require('../../datadog-shimmer');\n\nconst web = require('../../dd-trace/src/plugins/util/web');\n\nconst regexpCache = Object.create(null);\n\nfunction createWrapHandle(tracer, config) {\n  return function wrapHandle(handle) {\n    return function handleWithTrace(req, res, done) {\n      web.patch(req);\n      return handle.apply(this, arguments);\n    };\n  };\n}\n\nfunction wrapRouterMethod(original) {\n  return function methodWithTrace(fn) {\n    const offset = this.stack ? [].concat(this.stack).length : 0;\n    const router = original.apply(this, arguments);\n\n    if (typeof this.stack === 'function') {\n      this.stack = [{\n        handle: this.stack\n      }];\n    }\n\n    wrapStack(this.stack, offset, extractMatchers(fn));\n    return router;\n  };\n}\n\nfunction wrapLayerHandle(layer, handle) {\n  handle._name = handle._name || layer.name;\n  let wrapCallHandle;\n\n  if (handle.length === 4) {\n    wrapCallHandle = shimmer.wrap(handle, function (error, req, res, next) {\n      return callHandle(layer, handle, req, [error, req, res, wrapNext(layer, req, next)]);\n    });\n  } else {\n    wrapCallHandle = shimmer.wrap(handle, function (req, res, next) {\n      return callHandle(layer, handle, req, [req, res, wrapNext(layer, req, next)]);\n    });\n  } // This is a workaround for the `loopback` library so that it can find the correct express layer\n  // that contains the real handle function\n\n\n  wrapCallHandle._datadog_orig = handle;\n  return wrapCallHandle;\n}\n\nfunction wrapStack(stack, offset, matchers) {\n  [].concat(stack).slice(offset).forEach(layer => {\n    if (layer.__handle) {\n      // express-async-errors\n      layer.__handle = wrapLayerHandle(layer, layer.__handle);\n    } else {\n      layer.handle = wrapLayerHandle(layer, layer.handle);\n    }\n\n    layer._datadog_matchers = matchers;\n\n    if (layer.route) {\n      METHODS.forEach(method => {\n        if (typeof layer.route.stack === 'function') {\n          layer.route.stack = [{\n            handle: layer.route.stack\n          }];\n        }\n\n        layer.route[method] = wrapRouterMethod(layer.route[method]);\n      });\n    }\n  });\n}\n\nfunction wrapNext(layer, req, next) {\n  if (!next || !web.active(req)) return next;\n  const originalNext = next;\n  return function (error) {\n    if (!error && layer.path && !isFastStar(layer) && !isFastSlash(layer)) {\n      web.exitRoute(req);\n    }\n\n    web.finish(req, error);\n    originalNext.apply(null, arguments);\n  };\n}\n\nfunction callHandle(layer, handle, req, args) {\n  const matchers = layer._datadog_matchers;\n\n  if (web.active(req) && matchers) {\n    // Try to guess which path actually matched\n    for (let i = 0; i < matchers.length; i++) {\n      if (matchers[i].test(layer)) {\n        web.enterRoute(req, matchers[i].path);\n        break;\n      }\n    }\n  }\n\n  return web.wrapMiddleware(req, handle, 'express.middleware', () => {\n    return handle.apply(layer, args);\n  });\n}\n\nfunction extractMatchers(fn) {\n  const arg = flatten([].concat(fn));\n\n  if (typeof arg[0] === 'function') {\n    return [];\n  }\n\n  return arg.map(pattern => ({\n    path: pattern instanceof RegExp ? `(${pattern})` : pattern,\n    test: layer => !isFastStar(layer) && !isFastSlash(layer) && cachedPathToRegExp(pattern).test(layer.path)\n  }));\n}\n\nfunction isFastStar(layer) {\n  if (layer.regexp.fast_star !== undefined) {\n    return layer.regexp.fast_star;\n  }\n\n  return layer._datadog_matchers.some(matcher => matcher.path === '*');\n}\n\nfunction isFastSlash(layer) {\n  if (layer.regexp.fast_slash !== undefined) {\n    return layer.regexp.fast_slash;\n  }\n\n  return layer._datadog_matchers.some(matcher => matcher.path === '/');\n}\n\nfunction flatten(arr) {\n  return arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), []);\n}\n\nfunction cachedPathToRegExp(pattern) {\n  const maybeCached = regexpCache[pattern];\n\n  if (maybeCached) {\n    return maybeCached;\n  }\n\n  const regexp = pathToRegExp(pattern);\n  regexpCache[pattern] = regexp;\n  return regexp;\n}\n\nmodule.exports = {\n  name: 'router',\n  versions: ['>=1'],\n\n  patch(Router, tracer, config) {\n    this.wrap(Router.prototype, 'handle', createWrapHandle(tracer, config));\n    this.wrap(Router.prototype, 'use', wrapRouterMethod);\n    this.wrap(Router.prototype, 'route', wrapRouterMethod);\n  },\n\n  unpatch(Router) {\n    this.unwrap(Router.prototype, 'handle');\n    this.unwrap(Router.prototype, 'use');\n    this.unwrap(Router.prototype, 'route');\n  }\n\n};","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-router/src/index.js"],"names":["METHODS","require","concat","pathToRegExp","shimmer","web","regexpCache","Object","create","createWrapHandle","tracer","config","wrapHandle","handle","handleWithTrace","req","res","done","patch","apply","arguments","wrapRouterMethod","original","methodWithTrace","fn","offset","stack","length","router","wrapStack","extractMatchers","wrapLayerHandle","layer","_name","name","wrapCallHandle","wrap","error","next","callHandle","wrapNext","_datadog_orig","matchers","slice","forEach","__handle","_datadog_matchers","route","method","active","originalNext","path","isFastStar","isFastSlash","exitRoute","finish","args","i","test","enterRoute","wrapMiddleware","arg","flatten","map","pattern","RegExp","cachedPathToRegExp","regexp","fast_star","undefined","some","matcher","fast_slash","arr","reduce","acc","val","Array","isArray","maybeCached","module","exports","versions","Router","prototype","unpatch","unwrap"],"mappings":"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","sourcesContent":["'use strict'\n\nconst METHODS = require('methods').concat('all')\nconst pathToRegExp = require('path-to-regexp')\nconst shimmer = require('../../datadog-shimmer')\nconst web = require('../../dd-trace/src/plugins/util/web')\n\nconst regexpCache = Object.create(null)\n\nfunction createWrapHandle (tracer, config) {\n  return function wrapHandle (handle) {\n    return function handleWithTrace (req, res, done) {\n      web.patch(req)\n\n      return handle.apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapRouterMethod (original) {\n  return function methodWithTrace (fn) {\n    const offset = this.stack ? [].concat(this.stack).length : 0\n    const router = original.apply(this, arguments)\n\n    if (typeof this.stack === 'function') {\n      this.stack = [{ handle: this.stack }]\n    }\n\n    wrapStack(this.stack, offset, extractMatchers(fn))\n\n    return router\n  }\n}\n\nfunction wrapLayerHandle (layer, handle) {\n  handle._name = handle._name || layer.name\n\n  let wrapCallHandle\n\n  if (handle.length === 4) {\n    wrapCallHandle = shimmer.wrap(handle, function (error, req, res, next) {\n      return callHandle(layer, handle, req, [error, req, res, wrapNext(layer, req, next)])\n    })\n  } else {\n    wrapCallHandle = shimmer.wrap(handle, function (req, res, next) {\n      return callHandle(layer, handle, req, [req, res, wrapNext(layer, req, next)])\n    })\n  }\n\n  // This is a workaround for the `loopback` library so that it can find the correct express layer\n  // that contains the real handle function\n  wrapCallHandle._datadog_orig = handle\n\n  return wrapCallHandle\n}\n\nfunction wrapStack (stack, offset, matchers) {\n  [].concat(stack).slice(offset).forEach(layer => {\n    if (layer.__handle) { // express-async-errors\n      layer.__handle = wrapLayerHandle(layer, layer.__handle)\n    } else {\n      layer.handle = wrapLayerHandle(layer, layer.handle)\n    }\n\n    layer._datadog_matchers = matchers\n\n    if (layer.route) {\n      METHODS.forEach(method => {\n        if (typeof layer.route.stack === 'function') {\n          layer.route.stack = [{ handle: layer.route.stack }]\n        }\n\n        layer.route[method] = wrapRouterMethod(layer.route[method])\n      })\n    }\n  })\n}\n\nfunction wrapNext (layer, req, next) {\n  if (!next || !web.active(req)) return next\n\n  const originalNext = next\n\n  return function (error) {\n    if (!error && layer.path && !isFastStar(layer) && !isFastSlash(layer)) {\n      web.exitRoute(req)\n    }\n\n    web.finish(req, error)\n\n    originalNext.apply(null, arguments)\n  }\n}\n\nfunction callHandle (layer, handle, req, args) {\n  const matchers = layer._datadog_matchers\n\n  if (web.active(req) && matchers) {\n    // Try to guess which path actually matched\n    for (let i = 0; i < matchers.length; i++) {\n      if (matchers[i].test(layer)) {\n        web.enterRoute(req, matchers[i].path)\n\n        break\n      }\n    }\n  }\n\n  return web.wrapMiddleware(req, handle, 'express.middleware', () => {\n    return handle.apply(layer, args)\n  })\n}\n\nfunction extractMatchers (fn) {\n  const arg = flatten([].concat(fn))\n\n  if (typeof arg[0] === 'function') {\n    return []\n  }\n\n  return arg.map(pattern => ({\n    path: pattern instanceof RegExp ? `(${pattern})` : pattern,\n    test: layer => !isFastStar(layer) && !isFastSlash(layer) && cachedPathToRegExp(pattern).test(layer.path)\n  }))\n}\n\nfunction isFastStar (layer) {\n  if (layer.regexp.fast_star !== undefined) {\n    return layer.regexp.fast_star\n  }\n\n  return layer._datadog_matchers.some(matcher => matcher.path === '*')\n}\n\nfunction isFastSlash (layer) {\n  if (layer.regexp.fast_slash !== undefined) {\n    return layer.regexp.fast_slash\n  }\n\n  return layer._datadog_matchers.some(matcher => matcher.path === '/')\n}\n\nfunction flatten (arr) {\n  return arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten(val)) : acc.concat(val), [])\n}\n\nfunction cachedPathToRegExp (pattern) {\n  const maybeCached = regexpCache[pattern]\n  if (maybeCached) {\n    return maybeCached\n  }\n  const regexp = pathToRegExp(pattern)\n  regexpCache[pattern] = regexp\n  return regexp\n}\n\nmodule.exports = {\n  name: 'router',\n  versions: ['>=1'],\n  patch (Router, tracer, config) {\n    this.wrap(Router.prototype, 'handle', createWrapHandle(tracer, config))\n    this.wrap(Router.prototype, 'use', wrapRouterMethod)\n    this.wrap(Router.prototype, 'route', wrapRouterMethod)\n  },\n  unpatch (Router) {\n    this.unwrap(Router.prototype, 'handle')\n    this.unwrap(Router.prototype, 'use')\n    this.unwrap(Router.prototype, 'route')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}