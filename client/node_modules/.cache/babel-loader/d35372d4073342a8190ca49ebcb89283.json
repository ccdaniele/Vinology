{"ast":null,"code":"'use strict';\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler');\n\nconst dd = Symbol('datadog');\nconst circularBufferConstructor = Symbol('circularBufferConstructor');\nconst inFlightDeliveries = Symbol('inFlightDeliveries');\n\nfunction createWrapSend(tracer, config, instrumenter) {\n  return function wrapSend(send) {\n    return function sendWithTrace(msg, tag, format) {\n      if (!canTrace(this)) {\n        // we can't handle disconnects or ending spans, so we can't safely instrument\n        return send.apply(this, arguments);\n      }\n\n      const name = getResourceNameFromSender(this);\n      const {\n        host,\n        port\n      } = getHostAndPort(this.connection);\n      return tracer.trace('amqp.send', {\n        tags: {\n          'component': 'rhea',\n          'resource.name': name,\n          'service.name': config.service || `${tracer._service}-amqp-producer`,\n          'span.kind': 'producer',\n          'amqp.link.target.address': name,\n          'amqp.link.role': 'sender',\n          'out.host': host,\n          'out.port': port\n        }\n      }, (span, done) => {\n        analyticsSampler.sample(span, config.measured);\n        addDeliveryAnnotations(msg, tracer, span);\n        const delivery = send.apply(this, arguments);\n        delivery[dd] = {\n          done,\n          span\n        };\n        addToInFlightDeliveries(this.connection, delivery);\n        return delivery;\n      });\n    };\n  };\n}\n\nfunction createWrapConnectionDispatch(tracer, config) {\n  return function wrapDispatch(dispatch) {\n    return function dispatchWithTrace(eventName, obj) {\n      if (eventName === 'disconnected') {\n        const error = obj.error || this.saved_error;\n\n        if (this[inFlightDeliveries]) {\n          this[inFlightDeliveries].forEach(delivery => {\n            const {\n              span\n            } = delivery[dd];\n            span.addTags({\n              error\n            });\n            finish(delivery, null);\n          });\n        }\n      }\n\n      return dispatch.apply(this, arguments);\n    };\n  };\n}\n\nfunction createWrapReceiverDispatch(tracer, config, instrumenter) {\n  return function wrapDispatch(dispatch) {\n    return function dispatchWithTrace(eventName, msgObj) {\n      if (!canTrace(this)) {\n        // we can't handle disconnects or ending spans, so we can't safely instrument\n        return dispatch.apply(this, arguments);\n      }\n\n      if (eventName === 'message' && msgObj) {\n        const name = getResourceNameFromMessage(msgObj);\n        const childOf = getAnnotations(msgObj, tracer);\n        return tracer.trace('amqp.receive', {\n          type: 'worker',\n          tags: {\n            'component': 'rhea',\n            'resource.name': name,\n            'service.name': config.service || tracer._service,\n            'span.kind': 'consumer',\n            'amqp.link.source.address': name,\n            'amqp.link.role': 'receiver'\n          },\n          childOf\n        }, (span, done) => {\n          analyticsSampler.sample(span, config.measured, true);\n\n          if (msgObj.delivery) {\n            msgObj.delivery[dd] = {\n              done,\n              span\n            };\n            msgObj.delivery.update = wrapDeliveryUpdate(msgObj.delivery.update);\n            addToInFlightDeliveries(this.connection, msgObj.delivery);\n          }\n\n          return dispatch.apply(this, arguments);\n        });\n      }\n\n      return dispatch.apply(this, arguments);\n    };\n  };\n}\n\nfunction createWrapCircularBufferPopIf() {\n  return function wrapCircularBufferPopIf(popIf) {\n    return function wrappedPopIf(fn) {\n      arguments[0] = entry => {\n        const shouldPop = fn(entry);\n\n        if (shouldPop && entry[dd]) {\n          const remoteState = entry.remote_state;\n          const state = remoteState && remoteState.constructor ? entry.remote_state.constructor.composite_type : undefined;\n          finish(entry, state);\n        }\n\n        return shouldPop;\n      };\n\n      return popIf.apply(this, arguments);\n    };\n  };\n}\n\nfunction wrapDeliveryUpdate(update) {\n  return function wrappedUpdate(settled, stateData) {\n    if (this[dd]) {\n      const state = getStateFromData(stateData);\n      this[dd].span.setTag('amqp.delivery.state', state);\n    }\n\n    return update.apply(this, arguments);\n  };\n}\n\nfunction patchCircularBuffer(proto, instrumenter) {\n  Object.defineProperty(proto, 'outgoing', {\n    configurable: true,\n\n    get() {},\n\n    set(outgoing) {\n      delete proto.outgoing; // removes the setter on the prototype\n\n      this.outgoing = outgoing; // assigns on the instance, like normal\n\n      if (outgoing) {\n        let CircularBuffer;\n\n        if (outgoing.deliveries) {\n          CircularBuffer = outgoing.deliveries.constructor;\n        }\n\n        if (CircularBuffer && !CircularBuffer.prototype._datadog_patched) {\n          instrumenter.wrap(CircularBuffer.prototype, 'pop_if', createWrapCircularBufferPopIf());\n          CircularBuffer.prototype._datadog_patched = true;\n          const Session = proto.constructor;\n\n          if (Session) {\n            Session[circularBufferConstructor] = CircularBuffer;\n          }\n        }\n      }\n    }\n\n  });\n}\n\nfunction addToInFlightDeliveries(connection, delivery) {\n  let deliveries = connection[inFlightDeliveries];\n\n  if (!deliveries) {\n    deliveries = new Set();\n    connection[inFlightDeliveries] = deliveries;\n  }\n\n  deliveries.add(delivery);\n  delivery[dd].connection = connection;\n}\n\nfunction getHostAndPort(connection) {\n  let host;\n  let port;\n\n  if (connection && connection.options) {\n    host = connection.options.host;\n    port = connection.options.port;\n  }\n\n  return {\n    host,\n    port\n  };\n}\n\nfunction addDeliveryAnnotations(msg, tracer, span) {\n  if (msg) {\n    msg.delivery_annotations = msg.delivery_annotations || {};\n    tracer.inject(span, 'text_map', msg.delivery_annotations);\n  }\n}\n\nfunction getStateFromData(stateData) {\n  if (stateData && stateData.descriptor && stateData.descriptor) {\n    switch (stateData.descriptor.value) {\n      case 0x24:\n        return 'accepted';\n\n      case 0x25:\n        return 'rejected';\n\n      case 0x26:\n        return 'released';\n\n      case 0x27:\n        return 'modified';\n    }\n  }\n}\n\nfunction finish(delivery, state) {\n  if (delivery[dd]) {\n    if (state) {\n      delivery[dd].span.setTag('amqp.delivery.state', state);\n    }\n\n    delivery[dd].done();\n\n    if (delivery[dd].connection && delivery[dd].connection[inFlightDeliveries]) {\n      delivery[dd].connection[inFlightDeliveries].delete(delivery);\n    }\n\n    delete delivery[dd];\n  }\n}\n\nfunction getResourceNameFromMessage(msgObj) {\n  let resourceName = 'amq.topic';\n  let options = {};\n\n  if (msgObj.receiver && msgObj.receiver.options) {\n    options = msgObj.receiver.options;\n  }\n\n  if (options.source && options.source.address) {\n    resourceName = options.source.address;\n  }\n\n  return resourceName;\n}\n\nfunction getResourceNameFromSender(sender) {\n  let resourceName = 'amq.topic';\n\n  if (sender.options && sender.options.target && sender.options.target.address) {\n    resourceName = sender.options.target.address;\n  }\n\n  return resourceName;\n}\n\nfunction getAnnotations(msgObj, tracer) {\n  if (msgObj.message) {\n    return tracer.extract('text_map', msgObj.message.delivery_annotations);\n  }\n}\n\nfunction canTrace(link) {\n  return link.connection && link.session && link.session.outgoing;\n}\n\nmodule.exports = [{\n  name: 'rhea',\n  versions: ['>=1'],\n  file: 'lib/link.js',\n\n  patch({\n    Sender,\n    Receiver\n  }, tracer, config) {\n    this.wrap(Sender.prototype, 'send', createWrapSend(tracer, config, this));\n    this.wrap(Receiver.prototype, 'dispatch', createWrapReceiverDispatch(tracer, config, this));\n  },\n\n  unpatch({\n    Sender,\n    Receiver\n  }, tracer) {\n    this.unwrap(Sender.prototype, 'send');\n    this.unwrap(Receiver.prototype, 'dispatch');\n  }\n\n}, {\n  name: 'rhea',\n  versions: ['>=1'],\n  file: 'lib/connection.js',\n\n  patch(Connection, tracer, config) {\n    this.wrap(Connection.prototype, 'dispatch', createWrapConnectionDispatch(tracer, config));\n  },\n\n  unpatch(Connection, tracer) {\n    this.unwrap(Connection.prototype, 'dispatch');\n  }\n\n}, {\n  name: 'rhea',\n  versions: ['>=1'],\n  file: 'lib/session.js',\n\n  patch(Session, tracer, config) {\n    patchCircularBuffer(Session.prototype, this);\n  },\n\n  unpatch(Session, tracer) {\n    if (Session[circularBufferConstructor]) {\n      delete Session[circularBufferConstructor].prototype._datadog_patched;\n      this.unwrap(Session[circularBufferConstructor].prototype, 'pop_if');\n    }\n  }\n\n}];","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-rhea/src/index.js"],"names":["analyticsSampler","require","dd","Symbol","circularBufferConstructor","inFlightDeliveries","createWrapSend","tracer","config","instrumenter","wrapSend","send","sendWithTrace","msg","tag","format","canTrace","apply","arguments","name","getResourceNameFromSender","host","port","getHostAndPort","connection","trace","tags","service","_service","span","done","sample","measured","addDeliveryAnnotations","delivery","addToInFlightDeliveries","createWrapConnectionDispatch","wrapDispatch","dispatch","dispatchWithTrace","eventName","obj","error","saved_error","forEach","addTags","finish","createWrapReceiverDispatch","msgObj","getResourceNameFromMessage","childOf","getAnnotations","type","update","wrapDeliveryUpdate","createWrapCircularBufferPopIf","wrapCircularBufferPopIf","popIf","wrappedPopIf","fn","entry","shouldPop","remoteState","remote_state","state","constructor","composite_type","undefined","wrappedUpdate","settled","stateData","getStateFromData","setTag","patchCircularBuffer","proto","Object","defineProperty","configurable","get","set","outgoing","CircularBuffer","deliveries","prototype","_datadog_patched","wrap","Session","Set","add","options","delivery_annotations","inject","descriptor","value","delete","resourceName","receiver","source","address","sender","target","message","extract","link","session","module","exports","versions","file","patch","Sender","Receiver","unpatch","unwrap","Connection"],"mappings":"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","sourcesContent":["'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nconst dd = Symbol('datadog')\nconst circularBufferConstructor = Symbol('circularBufferConstructor')\nconst inFlightDeliveries = Symbol('inFlightDeliveries')\n\nfunction createWrapSend (tracer, config, instrumenter) {\n  return function wrapSend (send) {\n    return function sendWithTrace (msg, tag, format) {\n      if (!canTrace(this)) {\n        // we can't handle disconnects or ending spans, so we can't safely instrument\n        return send.apply(this, arguments)\n      }\n      const name = getResourceNameFromSender(this)\n      const { host, port } = getHostAndPort(this.connection)\n      return tracer.trace('amqp.send', {\n        tags: {\n          'component': 'rhea',\n          'resource.name': name,\n          'service.name': config.service || `${tracer._service}-amqp-producer`,\n          'span.kind': 'producer',\n          'amqp.link.target.address': name,\n          'amqp.link.role': 'sender',\n          'out.host': host,\n          'out.port': port\n        }\n      }, (span, done) => {\n        analyticsSampler.sample(span, config.measured)\n        addDeliveryAnnotations(msg, tracer, span)\n        const delivery = send.apply(this, arguments)\n        delivery[dd] = { done, span }\n        addToInFlightDeliveries(this.connection, delivery)\n        return delivery\n      })\n    }\n  }\n}\n\nfunction createWrapConnectionDispatch (tracer, config) {\n  return function wrapDispatch (dispatch) {\n    return function dispatchWithTrace (eventName, obj) {\n      if (eventName === 'disconnected') {\n        const error = obj.error || this.saved_error\n        if (this[inFlightDeliveries]) {\n          this[inFlightDeliveries].forEach(delivery => {\n            const { span } = delivery[dd]\n            span.addTags({ error })\n            finish(delivery, null)\n          })\n        }\n      }\n      return dispatch.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapReceiverDispatch (tracer, config, instrumenter) {\n  return function wrapDispatch (dispatch) {\n    return function dispatchWithTrace (eventName, msgObj) {\n      if (!canTrace(this)) {\n        // we can't handle disconnects or ending spans, so we can't safely instrument\n        return dispatch.apply(this, arguments)\n      }\n      if (eventName === 'message' && msgObj) {\n        const name = getResourceNameFromMessage(msgObj)\n        const childOf = getAnnotations(msgObj, tracer)\n        return tracer.trace('amqp.receive', {\n          type: 'worker',\n          tags: {\n            'component': 'rhea',\n            'resource.name': name,\n            'service.name': config.service || tracer._service,\n            'span.kind': 'consumer',\n            'amqp.link.source.address': name,\n            'amqp.link.role': 'receiver'\n          },\n          childOf\n        }, (span, done) => {\n          analyticsSampler.sample(span, config.measured, true)\n          if (msgObj.delivery) {\n            msgObj.delivery[dd] = { done, span }\n            msgObj.delivery.update = wrapDeliveryUpdate(msgObj.delivery.update)\n            addToInFlightDeliveries(this.connection, msgObj.delivery)\n          }\n          return dispatch.apply(this, arguments)\n        })\n      }\n\n      return dispatch.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapCircularBufferPopIf () {\n  return function wrapCircularBufferPopIf (popIf) {\n    return function wrappedPopIf (fn) {\n      arguments[0] = entry => {\n        const shouldPop = fn(entry)\n        if (shouldPop && entry[dd]) {\n          const remoteState = entry.remote_state\n          const state = remoteState && remoteState.constructor\n            ? entry.remote_state.constructor.composite_type : undefined\n          finish(entry, state)\n        }\n        return shouldPop\n      }\n      return popIf.apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapDeliveryUpdate (update) {\n  return function wrappedUpdate (settled, stateData) {\n    if (this[dd]) {\n      const state = getStateFromData(stateData)\n      this[dd].span.setTag('amqp.delivery.state', state)\n    }\n    return update.apply(this, arguments)\n  }\n}\n\nfunction patchCircularBuffer (proto, instrumenter) {\n  Object.defineProperty(proto, 'outgoing', {\n    configurable: true,\n    get () {},\n    set (outgoing) {\n      delete proto.outgoing // removes the setter on the prototype\n      this.outgoing = outgoing // assigns on the instance, like normal\n      if (outgoing) {\n        let CircularBuffer\n        if (outgoing.deliveries) {\n          CircularBuffer = outgoing.deliveries.constructor\n        }\n        if (CircularBuffer && !CircularBuffer.prototype._datadog_patched) {\n          instrumenter.wrap(CircularBuffer.prototype, 'pop_if', createWrapCircularBufferPopIf())\n          CircularBuffer.prototype._datadog_patched = true\n          const Session = proto.constructor\n          if (Session) {\n            Session[circularBufferConstructor] = CircularBuffer\n          }\n        }\n      }\n    }\n  })\n}\n\nfunction addToInFlightDeliveries (connection, delivery) {\n  let deliveries = connection[inFlightDeliveries]\n  if (!deliveries) {\n    deliveries = new Set()\n    connection[inFlightDeliveries] = deliveries\n  }\n  deliveries.add(delivery)\n  delivery[dd].connection = connection\n}\n\nfunction getHostAndPort (connection) {\n  let host\n  let port\n  if (connection && connection.options) {\n    host = connection.options.host\n    port = connection.options.port\n  }\n  return { host, port }\n}\n\nfunction addDeliveryAnnotations (msg, tracer, span) {\n  if (msg) {\n    msg.delivery_annotations = msg.delivery_annotations || {}\n    tracer.inject(span, 'text_map', msg.delivery_annotations)\n  }\n}\n\nfunction getStateFromData (stateData) {\n  if (stateData && stateData.descriptor && stateData.descriptor) {\n    switch (stateData.descriptor.value) {\n      case 0x24: return 'accepted'\n      case 0x25: return 'rejected'\n      case 0x26: return 'released'\n      case 0x27: return 'modified'\n    }\n  }\n}\n\nfunction finish (delivery, state) {\n  if (delivery[dd]) {\n    if (state) {\n      delivery[dd].span.setTag('amqp.delivery.state', state)\n    }\n    delivery[dd].done()\n    if (delivery[dd].connection && delivery[dd].connection[inFlightDeliveries]) {\n      delivery[dd].connection[inFlightDeliveries].delete(delivery)\n    }\n    delete delivery[dd]\n  }\n}\n\nfunction getResourceNameFromMessage (msgObj) {\n  let resourceName = 'amq.topic'\n  let options = {}\n  if (msgObj.receiver && msgObj.receiver.options) {\n    options = msgObj.receiver.options\n  }\n  if (options.source && options.source.address) {\n    resourceName = options.source.address\n  }\n  return resourceName\n}\n\nfunction getResourceNameFromSender (sender) {\n  let resourceName = 'amq.topic'\n  if (sender.options && sender.options.target && sender.options.target.address) {\n    resourceName = sender.options.target.address\n  }\n  return resourceName\n}\n\nfunction getAnnotations (msgObj, tracer) {\n  if (msgObj.message) {\n    return tracer.extract('text_map', msgObj.message.delivery_annotations)\n  }\n}\n\nfunction canTrace (link) {\n  return link.connection && link.session && link.session.outgoing\n}\n\nmodule.exports = [\n  {\n    name: 'rhea',\n    versions: ['>=1'],\n    file: 'lib/link.js',\n    patch ({ Sender, Receiver }, tracer, config) {\n      this.wrap(Sender.prototype, 'send', createWrapSend(tracer, config, this))\n      this.wrap(Receiver.prototype, 'dispatch', createWrapReceiverDispatch(tracer, config, this))\n    },\n    unpatch ({ Sender, Receiver }, tracer) {\n      this.unwrap(Sender.prototype, 'send')\n      this.unwrap(Receiver.prototype, 'dispatch')\n    }\n  },\n  {\n    name: 'rhea',\n    versions: ['>=1'],\n    file: 'lib/connection.js',\n    patch (Connection, tracer, config) {\n      this.wrap(Connection.prototype, 'dispatch', createWrapConnectionDispatch(tracer, config))\n    },\n    unpatch (Connection, tracer) {\n      this.unwrap(Connection.prototype, 'dispatch')\n    }\n  },\n  {\n    name: 'rhea',\n    versions: ['>=1'],\n    file: 'lib/session.js',\n    patch (Session, tracer, config) {\n      patchCircularBuffer(Session.prototype, this)\n    },\n    unpatch (Session, tracer) {\n      if (Session[circularBufferConstructor]) {\n        delete Session[circularBufferConstructor].prototype._datadog_patched\n        this.unwrap(Session[circularBufferConstructor].prototype, 'pop_if')\n      }\n    }\n  }\n]\n"]},"metadata":{},"sourceType":"script"}