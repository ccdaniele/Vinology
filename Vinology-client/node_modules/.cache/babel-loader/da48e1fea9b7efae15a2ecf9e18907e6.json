{"ast":null,"code":"'use strict'; // TODO: capture every second and flush every 10 seconds\n\nconst v8 = require('v8');\n\nconst os = require('os');\n\nconst Client = require('./dogstatsd');\n\nconst log = require('./log');\n\nconst Histogram = require('./histogram');\n\nconst INTERVAL = 10 * 1000;\nlet nativeMetrics = null;\nlet interval;\nlet client;\nlet time;\nlet cpuUsage;\nlet gauges;\nlet counters;\nlet histograms;\nreset();\nmodule.exports = {\n  start(config) {\n    const tags = [];\n    Object.keys(config.tags).filter(key => typeof config.tags[key] === 'string').filter(key => {\n      // Skip runtime-id unless enabled as cardinality may be too high\n      if (key !== 'runtime-id') return true;\n      return config.experimental && config.experimental.runtimeId;\n    }).forEach(key => {\n      // https://docs.datadoghq.com/tagging/#defining-tags\n      const value = config.tags[key].replace(/[^a-z0-9_:./-]/ig, '_');\n      tags.push(`${key}:${value}`);\n    });\n\n    try {\n      nativeMetrics = require('@datadog/native-metrics');\n      nativeMetrics.start();\n    } catch (e) {\n      log.error(e);\n      nativeMetrics = null;\n    }\n\n    client = new Client({\n      host: config.dogstatsd.hostname,\n      port: config.dogstatsd.port,\n      tags\n    });\n    time = process.hrtime();\n\n    if (nativeMetrics) {\n      interval = setInterval(() => {\n        captureCommonMetrics();\n        captureNativeMetrics();\n        client.flush();\n      }, INTERVAL);\n    } else {\n      cpuUsage = process.cpuUsage();\n      interval = setInterval(() => {\n        captureCommonMetrics();\n        captureCpuUsage();\n        captureHeapSpace();\n        client.flush();\n      }, INTERVAL);\n    }\n\n    interval.unref();\n  },\n\n  stop() {\n    if (nativeMetrics) {\n      nativeMetrics.stop();\n    }\n\n    clearInterval(interval);\n    reset();\n  },\n\n  track(span) {\n    if (nativeMetrics) {\n      const handle = nativeMetrics.track(span);\n      return {\n        finish: () => nativeMetrics.finish(handle)\n      };\n    }\n\n    return {\n      finish: () => {}\n    };\n  },\n\n  boolean(name, value, tag) {\n    this.gauge(name, value ? 1 : 0, tag);\n  },\n\n  histogram(name, value, tag) {\n    if (!client) return;\n    histograms[name] = histograms[name] || new Map();\n\n    if (!histograms[name].has(tag)) {\n      histograms[name].set(tag, new Histogram());\n    }\n\n    histograms[name].get(tag).record(value);\n  },\n\n  count(name, count, tag, monotonic = false) {\n    if (!client) return;\n\n    if (typeof tag === 'boolean') {\n      monotonic = tag;\n      tag = undefined;\n    }\n\n    const map = monotonic ? counters : gauges;\n    map[name] = map[name] || new Map();\n    const value = map[name].get(tag) || 0;\n    map[name].set(tag, value + count);\n  },\n\n  gauge(name, value, tag) {\n    if (!client) return;\n    gauges[name] = gauges[name] || new Map();\n    gauges[name].set(tag, value);\n  },\n\n  increment(name, tag, monotonic) {\n    this.count(name, 1, tag, monotonic);\n  },\n\n  decrement(name, tag) {\n    this.count(name, -1, tag);\n  }\n\n};\n\nfunction reset() {\n  interval = null;\n  client = null;\n  time = null;\n  cpuUsage = null;\n  gauges = {};\n  counters = {};\n  histograms = {};\n  nativeMetrics = null;\n}\n\nfunction captureCpuUsage() {\n  if (!process.cpuUsage) return;\n  const elapsedTime = process.hrtime(time);\n  const elapsedUsage = process.cpuUsage(cpuUsage);\n  time = process.hrtime();\n  cpuUsage = process.cpuUsage();\n  const elapsedMs = elapsedTime[0] * 1000 + elapsedTime[1] / 1000000;\n  const userPercent = 100 * elapsedUsage.user / 1000 / elapsedMs;\n  const systemPercent = 100 * elapsedUsage.system / 1000 / elapsedMs;\n  const totalPercent = userPercent + systemPercent;\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2));\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2));\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2));\n}\n\nfunction captureMemoryUsage() {\n  const stats = process.memoryUsage();\n  client.gauge('runtime.node.mem.heap_total', stats.heapTotal);\n  client.gauge('runtime.node.mem.heap_used', stats.heapUsed);\n  client.gauge('runtime.node.mem.rss', stats.rss);\n  client.gauge('runtime.node.mem.total', os.totalmem());\n  client.gauge('runtime.node.mem.free', os.freemem());\n  stats.external && client.gauge('runtime.node.mem.external', stats.external);\n}\n\nfunction captureProcess() {\n  client.gauge('runtime.node.process.uptime', Math.round(process.uptime()));\n}\n\nfunction captureHeapStats() {\n  const stats = v8.getHeapStatistics();\n  client.gauge('runtime.node.heap.total_heap_size', stats.total_heap_size);\n  client.gauge('runtime.node.heap.total_heap_size_executable', stats.total_heap_size_executable);\n  client.gauge('runtime.node.heap.total_physical_size', stats.total_physical_size);\n  client.gauge('runtime.node.heap.total_available_size', stats.total_available_size);\n  client.gauge('runtime.node.heap.heap_size_limit', stats.heap_size_limit);\n  stats.malloced_memory && client.gauge('runtime.node.heap.malloced_memory', stats.malloced_memory);\n  stats.peak_malloced_memory && client.gauge('runtime.node.heap.peak_malloced_memory', stats.peak_malloced_memory);\n}\n\nfunction captureHeapSpace() {\n  if (!v8.getHeapSpaceStatistics) return;\n  const stats = v8.getHeapSpaceStatistics();\n\n  for (let i = 0, l = stats.length; i < l; i++) {\n    const tags = [`space:${stats[i].space_name}`];\n    client.gauge('runtime.node.heap.size.by.space', stats[i].space_size, tags);\n    client.gauge('runtime.node.heap.used_size.by.space', stats[i].space_used_size, tags);\n    client.gauge('runtime.node.heap.available_size.by.space', stats[i].space_available_size, tags);\n    client.gauge('runtime.node.heap.physical_size.by.space', stats[i].physical_space_size, tags);\n  }\n}\n\nfunction captureGauges() {\n  Object.keys(gauges).forEach(name => {\n    gauges[name].forEach((value, tag) => {\n      client.gauge(name, value, tag && [tag]);\n    });\n  });\n}\n\nfunction captureCounters() {\n  Object.keys(counters).forEach(name => {\n    counters[name].forEach((value, tag) => {\n      client.increment(name, value, tag && [tag]);\n    });\n  });\n  counters = {};\n}\n\nfunction captureHistograms() {\n  Object.keys(histograms).forEach(name => {\n    histograms[name].forEach((stats, tag) => {\n      histogram(name, stats, tag && [tag]);\n      stats.reset();\n    });\n  });\n}\n\nfunction captureCommonMetrics() {\n  captureMemoryUsage();\n  captureProcess();\n  captureHeapStats();\n  captureGauges();\n  captureCounters();\n  captureHistograms();\n}\n\nfunction captureNativeMetrics() {\n  const stats = nativeMetrics.stats();\n  const spaces = stats.heap.spaces;\n  const elapsedTime = process.hrtime(time);\n  time = process.hrtime();\n  const elapsedUs = elapsedTime[0] * 1e6 + elapsedTime[1] / 1e3;\n  const userPercent = 100 * stats.cpu.user / elapsedUs;\n  const systemPercent = 100 * stats.cpu.system / elapsedUs;\n  const totalPercent = userPercent + systemPercent;\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2));\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2));\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2));\n  histogram('runtime.node.event_loop.delay', stats.eventLoop);\n  Object.keys(stats.gc).forEach(type => {\n    if (type === 'all') {\n      histogram('runtime.node.gc.pause', stats.gc[type]);\n    } else {\n      histogram('runtime.node.gc.pause.by.type', stats.gc[type], [`gc_type:${type}`]);\n    }\n  });\n\n  for (let i = 0, l = spaces.length; i < l; i++) {\n    const tags = [`heap_space:${spaces[i].space_name}`];\n    client.gauge('runtime.node.heap.size.by.space', spaces[i].space_size, tags);\n    client.gauge('runtime.node.heap.used_size.by.space', spaces[i].space_used_size, tags);\n    client.gauge('runtime.node.heap.available_size.by.space', spaces[i].space_available_size, tags);\n    client.gauge('runtime.node.heap.physical_size.by.space', spaces[i].physical_space_size, tags);\n  }\n}\n\nfunction histogram(name, stats, tags) {\n  tags = [].concat(tags);\n  client.gauge(`${name}.min`, stats.min, tags);\n  client.gauge(`${name}.max`, stats.max, tags);\n  client.increment(`${name}.sum`, stats.sum, tags);\n  client.increment(`${name}.total`, stats.sum, tags);\n  client.gauge(`${name}.avg`, stats.avg, tags);\n  client.increment(`${name}.count`, stats.count, tags);\n  client.gauge(`${name}.median`, stats.median, tags);\n  client.gauge(`${name}.95percentile`, stats.p95, tags);\n}","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/metrics.js"],"names":["v8","require","os","Client","log","Histogram","INTERVAL","nativeMetrics","interval","client","time","cpuUsage","gauges","counters","histograms","reset","module","exports","start","config","tags","Object","keys","filter","key","experimental","runtimeId","forEach","value","replace","push","e","error","host","dogstatsd","hostname","port","process","hrtime","setInterval","captureCommonMetrics","captureNativeMetrics","flush","captureCpuUsage","captureHeapSpace","unref","stop","clearInterval","track","span","handle","finish","boolean","name","tag","gauge","histogram","Map","has","set","get","record","count","monotonic","undefined","map","increment","decrement","elapsedTime","elapsedUsage","elapsedMs","userPercent","user","systemPercent","system","totalPercent","toFixed","captureMemoryUsage","stats","memoryUsage","heapTotal","heapUsed","rss","totalmem","freemem","external","captureProcess","Math","round","uptime","captureHeapStats","getHeapStatistics","total_heap_size","total_heap_size_executable","total_physical_size","total_available_size","heap_size_limit","malloced_memory","peak_malloced_memory","getHeapSpaceStatistics","i","l","length","space_name","space_size","space_used_size","space_available_size","physical_space_size","captureGauges","captureCounters","captureHistograms","spaces","heap","elapsedUs","cpu","eventLoop","gc","type","concat","min","max","sum","avg","median","p95"],"mappings":"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","sourcesContent":["'use strict'\n\n// TODO: capture every second and flush every 10 seconds\n\nconst v8 = require('v8')\nconst os = require('os')\nconst Client = require('./dogstatsd')\nconst log = require('./log')\nconst Histogram = require('./histogram')\n\nconst INTERVAL = 10 * 1000\n\nlet nativeMetrics = null\n\nlet interval\nlet client\nlet time\nlet cpuUsage\nlet gauges\nlet counters\nlet histograms\n\nreset()\n\nmodule.exports = {\n  start (config) {\n    const tags = []\n\n    Object.keys(config.tags)\n      .filter(key => typeof config.tags[key] === 'string')\n      .filter(key => {\n        // Skip runtime-id unless enabled as cardinality may be too high\n        if (key !== 'runtime-id') return true\n        return (config.experimental && config.experimental.runtimeId)\n      })\n      .forEach(key => {\n        // https://docs.datadoghq.com/tagging/#defining-tags\n        const value = config.tags[key].replace(/[^a-z0-9_:./-]/ig, '_')\n\n        tags.push(`${key}:${value}`)\n      })\n\n    try {\n      nativeMetrics = require('@datadog/native-metrics')\n      nativeMetrics.start()\n    } catch (e) {\n      log.error(e)\n      nativeMetrics = null\n    }\n\n    client = new Client({\n      host: config.dogstatsd.hostname,\n      port: config.dogstatsd.port,\n      tags\n    })\n\n    time = process.hrtime()\n\n    if (nativeMetrics) {\n      interval = setInterval(() => {\n        captureCommonMetrics()\n        captureNativeMetrics()\n        client.flush()\n      }, INTERVAL)\n    } else {\n      cpuUsage = process.cpuUsage()\n\n      interval = setInterval(() => {\n        captureCommonMetrics()\n        captureCpuUsage()\n        captureHeapSpace()\n        client.flush()\n      }, INTERVAL)\n    }\n\n    interval.unref()\n  },\n\n  stop () {\n    if (nativeMetrics) {\n      nativeMetrics.stop()\n    }\n\n    clearInterval(interval)\n    reset()\n  },\n\n  track (span) {\n    if (nativeMetrics) {\n      const handle = nativeMetrics.track(span)\n\n      return {\n        finish: () => nativeMetrics.finish(handle)\n      }\n    }\n\n    return { finish: () => {} }\n  },\n\n  boolean (name, value, tag) {\n    this.gauge(name, value ? 1 : 0, tag)\n  },\n\n  histogram (name, value, tag) {\n    if (!client) return\n\n    histograms[name] = histograms[name] || new Map()\n\n    if (!histograms[name].has(tag)) {\n      histograms[name].set(tag, new Histogram())\n    }\n\n    histograms[name].get(tag).record(value)\n  },\n\n  count (name, count, tag, monotonic = false) {\n    if (!client) return\n    if (typeof tag === 'boolean') {\n      monotonic = tag\n      tag = undefined\n    }\n\n    const map = monotonic ? counters : gauges\n\n    map[name] = map[name] || new Map()\n\n    const value = map[name].get(tag) || 0\n\n    map[name].set(tag, value + count)\n  },\n\n  gauge (name, value, tag) {\n    if (!client) return\n\n    gauges[name] = gauges[name] || new Map()\n    gauges[name].set(tag, value)\n  },\n\n  increment (name, tag, monotonic) {\n    this.count(name, 1, tag, monotonic)\n  },\n\n  decrement (name, tag) {\n    this.count(name, -1, tag)\n  }\n}\n\nfunction reset () {\n  interval = null\n  client = null\n  time = null\n  cpuUsage = null\n  gauges = {}\n  counters = {}\n  histograms = {}\n  nativeMetrics = null\n}\n\nfunction captureCpuUsage () {\n  if (!process.cpuUsage) return\n\n  const elapsedTime = process.hrtime(time)\n  const elapsedUsage = process.cpuUsage(cpuUsage)\n\n  time = process.hrtime()\n  cpuUsage = process.cpuUsage()\n\n  const elapsedMs = elapsedTime[0] * 1000 + elapsedTime[1] / 1000000\n  const userPercent = 100 * elapsedUsage.user / 1000 / elapsedMs\n  const systemPercent = 100 * elapsedUsage.system / 1000 / elapsedMs\n  const totalPercent = userPercent + systemPercent\n\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))\n}\n\nfunction captureMemoryUsage () {\n  const stats = process.memoryUsage()\n\n  client.gauge('runtime.node.mem.heap_total', stats.heapTotal)\n  client.gauge('runtime.node.mem.heap_used', stats.heapUsed)\n  client.gauge('runtime.node.mem.rss', stats.rss)\n  client.gauge('runtime.node.mem.total', os.totalmem())\n  client.gauge('runtime.node.mem.free', os.freemem())\n\n  stats.external && client.gauge('runtime.node.mem.external', stats.external)\n}\n\nfunction captureProcess () {\n  client.gauge('runtime.node.process.uptime', Math.round(process.uptime()))\n}\n\nfunction captureHeapStats () {\n  const stats = v8.getHeapStatistics()\n\n  client.gauge('runtime.node.heap.total_heap_size', stats.total_heap_size)\n  client.gauge('runtime.node.heap.total_heap_size_executable', stats.total_heap_size_executable)\n  client.gauge('runtime.node.heap.total_physical_size', stats.total_physical_size)\n  client.gauge('runtime.node.heap.total_available_size', stats.total_available_size)\n  client.gauge('runtime.node.heap.heap_size_limit', stats.heap_size_limit)\n\n  stats.malloced_memory && client.gauge('runtime.node.heap.malloced_memory', stats.malloced_memory)\n  stats.peak_malloced_memory && client.gauge('runtime.node.heap.peak_malloced_memory', stats.peak_malloced_memory)\n}\n\nfunction captureHeapSpace () {\n  if (!v8.getHeapSpaceStatistics) return\n\n  const stats = v8.getHeapSpaceStatistics()\n\n  for (let i = 0, l = stats.length; i < l; i++) {\n    const tags = [`space:${stats[i].space_name}`]\n\n    client.gauge('runtime.node.heap.size.by.space', stats[i].space_size, tags)\n    client.gauge('runtime.node.heap.used_size.by.space', stats[i].space_used_size, tags)\n    client.gauge('runtime.node.heap.available_size.by.space', stats[i].space_available_size, tags)\n    client.gauge('runtime.node.heap.physical_size.by.space', stats[i].physical_space_size, tags)\n  }\n}\n\nfunction captureGauges () {\n  Object.keys(gauges).forEach(name => {\n    gauges[name].forEach((value, tag) => {\n      client.gauge(name, value, tag && [tag])\n    })\n  })\n}\n\nfunction captureCounters () {\n  Object.keys(counters).forEach(name => {\n    counters[name].forEach((value, tag) => {\n      client.increment(name, value, tag && [tag])\n    })\n  })\n\n  counters = {}\n}\n\nfunction captureHistograms () {\n  Object.keys(histograms).forEach(name => {\n    histograms[name].forEach((stats, tag) => {\n      histogram(name, stats, tag && [tag])\n      stats.reset()\n    })\n  })\n}\n\nfunction captureCommonMetrics () {\n  captureMemoryUsage()\n  captureProcess()\n  captureHeapStats()\n  captureGauges()\n  captureCounters()\n  captureHistograms()\n}\n\nfunction captureNativeMetrics () {\n  const stats = nativeMetrics.stats()\n  const spaces = stats.heap.spaces\n  const elapsedTime = process.hrtime(time)\n\n  time = process.hrtime()\n\n  const elapsedUs = elapsedTime[0] * 1e6 + elapsedTime[1] / 1e3\n  const userPercent = 100 * stats.cpu.user / elapsedUs\n  const systemPercent = 100 * stats.cpu.system / elapsedUs\n  const totalPercent = userPercent + systemPercent\n\n  client.gauge('runtime.node.cpu.system', systemPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.user', userPercent.toFixed(2))\n  client.gauge('runtime.node.cpu.total', totalPercent.toFixed(2))\n\n  histogram('runtime.node.event_loop.delay', stats.eventLoop)\n\n  Object.keys(stats.gc).forEach(type => {\n    if (type === 'all') {\n      histogram('runtime.node.gc.pause', stats.gc[type])\n    } else {\n      histogram('runtime.node.gc.pause.by.type', stats.gc[type], [`gc_type:${type}`])\n    }\n  })\n\n  for (let i = 0, l = spaces.length; i < l; i++) {\n    const tags = [`heap_space:${spaces[i].space_name}`]\n\n    client.gauge('runtime.node.heap.size.by.space', spaces[i].space_size, tags)\n    client.gauge('runtime.node.heap.used_size.by.space', spaces[i].space_used_size, tags)\n    client.gauge('runtime.node.heap.available_size.by.space', spaces[i].space_available_size, tags)\n    client.gauge('runtime.node.heap.physical_size.by.space', spaces[i].physical_space_size, tags)\n  }\n}\n\nfunction histogram (name, stats, tags) {\n  tags = [].concat(tags)\n\n  client.gauge(`${name}.min`, stats.min, tags)\n  client.gauge(`${name}.max`, stats.max, tags)\n  client.increment(`${name}.sum`, stats.sum, tags)\n  client.increment(`${name}.total`, stats.sum, tags)\n  client.gauge(`${name}.avg`, stats.avg, tags)\n  client.increment(`${name}.count`, stats.count, tags)\n  client.gauge(`${name}.median`, stats.median, tags)\n  client.gauge(`${name}.95percentile`, stats.p95, tags)\n}\n"]},"metadata":{},"sourceType":"script"}