{"ast":null,"code":"const helpers = require('./helpers');\n/**\n * Separated out of statsd.js for clarity, these are the timing and other stats functions that are what are called the most\n * when using hot-shots\n */\n\n\nfunction applyStatsFns(Client) {\n  /**\n   * Represents the timing stat\n   * @param stat {String|Array} The stat(s) to send\n   * @param time {Number|Date} The time in milliseconds to send or Date object of which the difference is calculated\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.timing = function (stat, time, sampleRate, tags, callback) {\n    const t = time instanceof Date ? new Date() - time : time;\n    this.sendAll(stat, t, 'ms', sampleRate, tags, callback);\n  };\n  /**\n   * Represents the timing stat by recording the duration a function takes to run (in milliseconds)\n   * @param func {Function} The function to run\n   * @param stat {String|Array} The stat(s) to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n\n\n  Client.prototype.timer = function (func, stat, sampleRate, tags, callback) {\n    const _this = this;\n\n    return (...args) => {\n      const start = process.hrtime();\n\n      try {\n        return func(...args);\n      } finally {\n        // get duration in milliseconds\n        const durationComponents = process.hrtime(start);\n        const seconds = durationComponents[0];\n        const nanoseconds = durationComponents[1];\n        const duration = seconds * 1000 + nanoseconds / 1E6;\n\n        _this.timing(stat, duration, sampleRate, tags, callback);\n      }\n    };\n  };\n  /**\n   * Decorates an async function with timing recording behaviour.\n   *\n   * This version of `timer` will record the time take for the asynchronous action returned by `func`\n   * not just the execution time of `func` itself.\n   *\n   * @param func {<T,A>(...A):Promise<T>} The function to run\n   * @param stat {String|Array} The stat(s) to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n\n\n  Client.prototype.asyncTimer = function (func, stat, sampleRate, tags, callback) {\n    const self = this;\n    return (...args) => {\n      const end = hrtimer();\n      const p = func(...args);\n\n      const recordStat = () => {\n        self.timing(stat, end(), sampleRate, tags, callback);\n      };\n\n      p.then(recordStat, recordStat);\n      return p;\n    };\n  };\n  /**\n   * Decorates an async function with timing recording behaviour, reported as a distribution.\n   *\n   * This version of `timer` will record the time take for the asynchronous action returned by `func`\n   * not just the execution time of `func` itself.\n   *\n   * @param func {<T,A>(...A):Promise<T>} The function to run\n   * @param stat {String|Array} The stat(s) to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n\n\n  Client.prototype.asyncDistTimer = function (func, stat, sampleRate, tags, callback) {\n    const self = this;\n    return (...args) => {\n      const end = hrtimer();\n      const p = func(...args);\n\n      const recordStat = () => self.distribution(stat, end(), sampleRate, tags, callback);\n\n      p.then(recordStat, recordStat);\n      return p;\n    };\n  };\n  /**\n   * High-resolution timer\n   */\n\n\n  function hrtimer() {\n    const start = process.hrtime();\n    return () => {\n      const durationComponents = process.hrtime(start);\n      const seconds = durationComponents[0];\n      const nanoseconds = durationComponents[1];\n      const duration = seconds * 1000 + nanoseconds / 1E6;\n      return duration;\n    };\n  }\n  /**\n   * Increments a stat by a specified amount\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n\n\n  Client.prototype.increment = function (stat, value, sampleRate, tags, callback) {\n    // allow use of tags without explicit value or sampleRate\n    if (arguments.length < 3) {\n      if (typeof value !== 'number') {\n        tags = value;\n        value = undefined;\n      }\n    } // we explicitly check for undefined and null (and don't do a \"! value\" check)\n    // so that 0 values are allowed and sent through as-is\n\n\n    if (value === undefined || value === null) {\n      value = 1;\n    }\n\n    this.sendAll(stat, value, 'c', sampleRate, tags, callback);\n  };\n  /**\n   * Decrements a stat by a specified amount\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n\n\n  Client.prototype.decrement = function (stat, value, sampleRate, tags, callback) {\n    // allow use of tags without explicit value or sampleRate\n    if (arguments.length < 3) {\n      if (typeof value !== 'number') {\n        tags = value;\n        value = undefined;\n      }\n    } // we explicitly check for undefined and null (and don't do a \"! value\" check)\n    // so that 0 values are allowed and sent through as-is\n\n\n    if (value === undefined || value === null) {\n      value = 1;\n    }\n\n    this.sendAll(stat, -value, 'c', sampleRate, tags, callback);\n  };\n  /**\n   * Represents the histogram stat\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n\n\n  Client.prototype.histogram = function (stat, value, sampleRate, tags, callback) {\n    this.sendAll(stat, value, 'h', sampleRate, tags, callback);\n  };\n  /**\n   * Represents the distribution stat\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n\n\n  Client.prototype.distribution = function (stat, value, sampleRate, tags, callback) {\n    this.sendAll(stat, value, 'd', sampleRate, tags, callback);\n  };\n  /**\n   * Gauges a stat by a specified amount\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n\n\n  Client.prototype.gauge = function (stat, value, sampleRate, tags, callback) {\n    this.sendAll(stat, value, 'g', sampleRate, tags, callback);\n  };\n  /**\n   * Counts unique values by a specified amount\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n\n\n  Client.prototype.unique = Client.prototype.set = function (stat, value, sampleRate, tags, callback) {\n    this.sendAll(stat, value, 's', sampleRate, tags, callback);\n  };\n  /**\n   * Send a service check\n   * @param name {String} The name of the service check\n   * @param status {Number=} The status of the service check (0 to 3).\n   * @param options\n   *   @option date_happened {Date} Assign a timestamp to the event. Default is now.\n   *   @option hostname {String} Assign a hostname to the check.\n   *   @option message {String} Assign a message to the check.\n   * @param tags {Array=} The Array of tags to add to the check. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n\n\n  Client.prototype.check = function (name, status, options, tags, callback) {\n    if (this.telegraf) {\n      const err = new Error('Not supported by Telegraf / InfluxDB');\n\n      if (callback) {\n        return callback(err);\n      } else if (this.errorHandler) {\n        return this.errorHandler(err);\n      }\n\n      throw err;\n    }\n\n    const check = ['_sc', this.prefix + name + this.suffix, status],\n          metadata = options || {};\n\n    if (metadata.date_happened) {\n      const timestamp = helpers.formatDate(metadata.date_happened);\n\n      if (timestamp) {\n        check.push(`d:${timestamp}`);\n      }\n    }\n\n    if (metadata.hostname) {\n      check.push(`h:${metadata.hostname}`);\n    }\n\n    let mergedTags = this.globalTags;\n\n    if (tags && typeof tags === 'object') {\n      mergedTags = helpers.overrideTags(mergedTags, tags, this.telegraf);\n    }\n\n    if (mergedTags.length > 0) {\n      check.push(`#${mergedTags.join(',')}`);\n    } // message has to be the last part of a service check\n\n\n    if (metadata.message) {\n      check.push(`m:${metadata.message}`);\n    } // allow for tags to be omitted and callback to be used in its place\n\n\n    if (typeof tags === 'function' && callback === undefined) {\n      callback = tags;\n    }\n\n    const message = check.join('|'); // Service checks are unique in that message has to be the last element in\n    // the stat if provided, so we can't append tags like other checks. This\n    // directly calls the `_send` method to avoid appending tags, since we've\n    // already added them.\n\n    this._send(message, callback);\n  };\n  /**\n   * Send on an event\n   * @param title {String} The title of the event\n   * @param text {String} The description of the event.  Optional- title is used if not given.\n   * @param options\n   *   @option date_happened {Date} Assign a timestamp to the event. Default is now.\n   *   @option hostname {String} Assign a hostname to the event.\n   *   @option aggregation_key {String} Assign an aggregation key to the event, to group it with some others.\n   *   @option priority {String} Can be ‘normal’ or ‘low’. Default is 'normal'.\n   *   @option source_type_name {String} Assign a source type to the event.\n   *   @option alert_type {String} Can be ‘error’, ‘warning’, ‘info’ or ‘success’. Default is 'info'.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n\n\n  Client.prototype.event = function (title, text, options, tags, callback) {\n    if (this.telegraf) {\n      const err = new Error('Not supported by Telegraf / InfluxDB');\n\n      if (callback) {\n        return callback(err);\n      } else if (this.errorHandler) {\n        return this.errorHandler(err);\n      }\n\n      throw err;\n    } // Convert to strings\n\n\n    let message;\n    const msgTitle = String(title ? title : '');\n    let msgText = String(text ? text : msgTitle); // Escape new lines (unescaping is supported by DataDog)\n\n    msgText = msgText.replace(/\\n/g, '\\\\n'); // start out the message with the event-specific title and text info\n\n    message = `_e{${msgTitle.length},${msgText.length}}:${msgTitle}|${msgText}`; // add in the event-specific options\n\n    if (options) {\n      if (options.date_happened) {\n        const timestamp = helpers.formatDate(options.date_happened);\n\n        if (timestamp) {\n          message += `|d:${timestamp}`;\n        }\n      }\n\n      if (options.hostname) {\n        message += `|h:${options.hostname}`;\n      }\n\n      if (options.aggregation_key) {\n        message += `|k:${options.aggregation_key}`;\n      }\n\n      if (options.priority) {\n        message += `|p:${options.priority}`;\n      }\n\n      if (options.source_type_name) {\n        message += `|s:${options.source_type_name}`;\n      }\n\n      if (options.alert_type) {\n        message += `|t:${options.alert_type}`;\n      }\n    } // allow for tags to be omitted and callback to be used in its place\n\n\n    if (typeof tags === 'function' && callback === undefined) {\n      callback = tags;\n    }\n\n    this.send(message, tags, callback);\n  };\n}\n\nmodule.exports = applyStatsFns;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/hot-shots/lib/statsFunctions.js"],"names":["helpers","require","applyStatsFns","Client","prototype","timing","stat","time","sampleRate","tags","callback","t","Date","sendAll","timer","func","_this","args","start","process","hrtime","durationComponents","seconds","nanoseconds","duration","asyncTimer","self","end","hrtimer","p","recordStat","then","asyncDistTimer","distribution","increment","value","arguments","length","undefined","decrement","histogram","gauge","unique","set","check","name","status","options","telegraf","err","Error","errorHandler","prefix","suffix","metadata","date_happened","timestamp","formatDate","push","hostname","mergedTags","globalTags","overrideTags","join","message","_send","event","title","text","msgTitle","String","msgText","replace","aggregation_key","priority","source_type_name","alert_type","send","module","exports"],"mappings":"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","sourcesContent":["const helpers = require('./helpers');\n\n/**\n * Separated out of statsd.js for clarity, these are the timing and other stats functions that are what are called the most\n * when using hot-shots\n */\nfunction applyStatsFns (Client) {\n\n  /**\n   * Represents the timing stat\n   * @param stat {String|Array} The stat(s) to send\n   * @param time {Number|Date} The time in milliseconds to send or Date object of which the difference is calculated\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.timing = function (stat, time, sampleRate, tags, callback) {\n    const t = time instanceof Date ? new Date() - time : time;\n    this.sendAll(stat, t, 'ms', sampleRate, tags, callback);\n  };\n\n  /**\n   * Represents the timing stat by recording the duration a function takes to run (in milliseconds)\n   * @param func {Function} The function to run\n   * @param stat {String|Array} The stat(s) to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.timer = function (func, stat, sampleRate, tags, callback) {\n    const _this = this;\n\n    return (...args) => {\n      const start = process.hrtime();\n      try {\n        return func(...args);\n      } finally {\n        // get duration in milliseconds\n        const durationComponents = process.hrtime(start);\n        const seconds = durationComponents[0];\n        const nanoseconds = durationComponents[1];\n        const duration = (seconds * 1000) + (nanoseconds / 1E6);\n\n        _this.timing(\n          stat,\n          duration,\n          sampleRate,\n          tags,\n          callback\n        );\n      }\n    };\n  };\n\n  /**\n   * Decorates an async function with timing recording behaviour.\n   *\n   * This version of `timer` will record the time take for the asynchronous action returned by `func`\n   * not just the execution time of `func` itself.\n   *\n   * @param func {<T,A>(...A):Promise<T>} The function to run\n   * @param stat {String|Array} The stat(s) to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.asyncTimer = function (func, stat, sampleRate, tags, callback) {\n    const self = this;\n    return (...args) => {\n      const end = hrtimer();\n      const p = func(...args);\n      const recordStat = () => { self.timing(stat, end(), sampleRate, tags, callback); };\n      p.then(recordStat, recordStat);\n      return p;\n    };\n  };\n\n  /**\n   * Decorates an async function with timing recording behaviour, reported as a distribution.\n   *\n   * This version of `timer` will record the time take for the asynchronous action returned by `func`\n   * not just the execution time of `func` itself.\n   *\n   * @param func {<T,A>(...A):Promise<T>} The function to run\n   * @param stat {String|Array} The stat(s) to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.asyncDistTimer = function (func, stat, sampleRate, tags, callback) {\n    const self = this;\n    return (...args) => {\n      const end = hrtimer();\n      const p = func(...args);\n      const recordStat = () => self.distribution(stat, end(), sampleRate, tags, callback);\n      p.then(recordStat, recordStat);\n      return p;\n    };\n  };\n\n  /**\n   * High-resolution timer\n   */\n  function hrtimer() {\n    const start = process.hrtime();\n\n    return () => {\n      const durationComponents = process.hrtime(start);\n      const seconds = durationComponents[0];\n      const nanoseconds = durationComponents[1];\n      const duration = (seconds * 1000) + (nanoseconds / 1E6);\n      return duration;\n    };\n  }\n\n\n  /**\n   * Increments a stat by a specified amount\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.increment = function (stat, value, sampleRate, tags, callback) {\n    // allow use of tags without explicit value or sampleRate\n    if (arguments.length < 3) {\n      if (typeof value !== 'number') {\n        tags = value;\n        value = undefined;\n      }\n    }\n    // we explicitly check for undefined and null (and don't do a \"! value\" check)\n    // so that 0 values are allowed and sent through as-is\n    if (value === undefined || value === null) {\n      value = 1;\n    }\n    this.sendAll(stat, value, 'c', sampleRate, tags, callback);\n  };\n\n  /**\n   * Decrements a stat by a specified amount\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.decrement = function (stat, value, sampleRate, tags, callback) {\n    // allow use of tags without explicit value or sampleRate\n    if (arguments.length < 3) {\n      if (typeof value !== 'number') {\n        tags = value;\n        value = undefined;\n      }\n    }\n    // we explicitly check for undefined and null (and don't do a \"! value\" check)\n    // so that 0 values are allowed and sent through as-is\n    if (value === undefined || value === null) {\n      value = 1;\n    }\n\n    this.sendAll(stat, -value, 'c', sampleRate, tags, callback);\n  };\n\n  /**\n   * Represents the histogram stat\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.histogram = function (stat, value, sampleRate, tags, callback) {\n    this.sendAll(stat, value, 'h', sampleRate, tags, callback);\n  };\n\n  /**\n   * Represents the distribution stat\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.distribution = function (stat, value, sampleRate, tags, callback) {\n    this.sendAll(stat, value, 'd', sampleRate, tags, callback);\n  };\n\n\n  /**\n   * Gauges a stat by a specified amount\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.gauge = function (stat, value, sampleRate, tags, callback) {\n    this.sendAll(stat, value, 'g', sampleRate, tags, callback);\n  };\n\n  /**\n   * Counts unique values by a specified amount\n   * @param stat {String|Array} The stat(s) to send\n   * @param value The value to send\n   * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.unique = Client.prototype.set = function (stat, value, sampleRate, tags, callback) {\n    this.sendAll(stat, value, 's', sampleRate, tags, callback);\n  };\n\n  /**\n   * Send a service check\n   * @param name {String} The name of the service check\n   * @param status {Number=} The status of the service check (0 to 3).\n   * @param options\n   *   @option date_happened {Date} Assign a timestamp to the event. Default is now.\n   *   @option hostname {String} Assign a hostname to the check.\n   *   @option message {String} Assign a message to the check.\n   * @param tags {Array=} The Array of tags to add to the check. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.check = function (name, status, options, tags, callback) {\n    if (this.telegraf) {\n      const err = new Error('Not supported by Telegraf / InfluxDB');\n      if (callback) {\n        return callback(err);\n      }\n      else if (this.errorHandler) {\n        return this.errorHandler(err);\n      }\n\n      throw err;\n    }\n\n    const check = ['_sc', this.prefix + name + this.suffix, status], metadata = options || {};\n\n    if (metadata.date_happened) {\n      const timestamp = helpers.formatDate(metadata.date_happened);\n      if (timestamp) {\n        check.push(`d:${timestamp}`);\n      }\n    }\n    if (metadata.hostname) {\n      check.push(`h:${metadata.hostname}`);\n    }\n\n    let mergedTags = this.globalTags;\n    if (tags && typeof(tags) === 'object') {\n      mergedTags = helpers.overrideTags(mergedTags, tags, this.telegraf);\n    }\n    if (mergedTags.length > 0) {\n      check.push(`#${mergedTags.join(',')}`);\n    }\n\n    // message has to be the last part of a service check\n    if (metadata.message) {\n      check.push(`m:${metadata.message}`);\n    }\n\n    // allow for tags to be omitted and callback to be used in its place\n    if (typeof tags === 'function' && callback === undefined) {\n      callback = tags;\n    }\n\n    const message = check.join('|');\n    // Service checks are unique in that message has to be the last element in\n    // the stat if provided, so we can't append tags like other checks. This\n    // directly calls the `_send` method to avoid appending tags, since we've\n    // already added them.\n    this._send(message, callback);\n  };\n\n  /**\n   * Send on an event\n   * @param title {String} The title of the event\n   * @param text {String} The description of the event.  Optional- title is used if not given.\n   * @param options\n   *   @option date_happened {Date} Assign a timestamp to the event. Default is now.\n   *   @option hostname {String} Assign a hostname to the event.\n   *   @option aggregation_key {String} Assign an aggregation key to the event, to group it with some others.\n   *   @option priority {String} Can be ‘normal’ or ‘low’. Default is 'normal'.\n   *   @option source_type_name {String} Assign a source type to the event.\n   *   @option alert_type {String} Can be ‘error’, ‘warning’, ‘info’ or ‘success’. Default is 'info'.\n   * @param tags {Array=} The Array of tags to add to metrics. Optional.\n   * @param callback {Function=} Callback when message is done being delivered. Optional.\n   */\n  Client.prototype.event = function (title, text, options, tags, callback) {\n    if (this.telegraf) {\n      const err = new Error('Not supported by Telegraf / InfluxDB');\n      if (callback) {\n        return callback(err);\n      }\n      else if (this.errorHandler) {\n        return this.errorHandler(err);\n      }\n\n      throw err;\n    }\n\n    // Convert to strings\n    let message;\n\n    const msgTitle = String(title ? title : '');\n    let msgText = String(text ? text : msgTitle);\n    // Escape new lines (unescaping is supported by DataDog)\n    msgText = msgText.replace(/\\n/g, '\\\\n');\n\n    // start out the message with the event-specific title and text info\n    message = `_e{${msgTitle.length},${msgText.length}}:${msgTitle}|${msgText}`;\n\n    // add in the event-specific options\n    if (options) {\n      if (options.date_happened) {\n        const timestamp = helpers.formatDate(options.date_happened);\n        if (timestamp) {\n          message += `|d:${timestamp}`;\n        }\n      }\n      if (options.hostname) {\n        message += `|h:${options.hostname}`;\n      }\n      if (options.aggregation_key) {\n        message += `|k:${options.aggregation_key}`;\n      }\n      if (options.priority) {\n        message += `|p:${options.priority}`;\n      }\n      if (options.source_type_name) {\n        message += `|s:${options.source_type_name}`;\n      }\n      if (options.alert_type) {\n        message += `|t:${options.alert_type}`;\n      }\n    }\n\n    // allow for tags to be omitted and callback to be used in its place\n    if (typeof tags === 'function' && callback === undefined) {\n      callback = tags;\n    }\n\n    this.send(message, tags, callback);\n  };\n}\n\nmodule.exports = applyStatsFns;\n"]},"metadata":{},"sourceType":"script"}