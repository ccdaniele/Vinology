{"ast":null,"code":"'use strict';\n\nconst BaseTracer = require('opentracing').Tracer;\n\nconst NoopTracer = require('./noop/tracer');\n\nconst DatadogTracer = require('./tracer');\n\nconst Config = require('./config');\n\nconst Instrumenter = require('./instrumenter');\n\nconst metrics = require('./metrics');\n\nconst log = require('./log');\n\nconst {\n  setStartupLogInstrumenter\n} = require('./startup-log');\n\nconst noop = new NoopTracer();\n\nclass Tracer extends BaseTracer {\n  constructor() {\n    super();\n    this._tracer = noop;\n    this._instrumenter = new Instrumenter(this);\n\n    this._deprecate = method => log.deprecate(`tracer.${method}`, [`tracer.${method}() is deprecated.`, 'Please use tracer.startSpan() and tracer.scope() instead.', 'See: https://datadog.github.io/dd-trace-js/#manual-instrumentation.'].join(' '));\n  }\n\n  init(options) {\n    if (this._tracer === noop) {\n      try {\n        const config = new Config(options);\n        log.use(config.logger);\n        log.toggle(config.debug, config.logLevel, this);\n\n        if (config.hasOwnProperty('profiling') && config.profiling.enabled) {\n          // do not stop tracer initialization if the profiler fails to be imported\n          try {\n            const profiler = require('./profiler');\n\n            profiler.start(config);\n          } catch (e) {\n            log.error(e);\n          }\n        }\n\n        if (config.enabled) {\n          if (config.runtimeMetrics) {\n            metrics.start(config);\n          } // dirty require for now so zero appsec code is executed unless explicitly enabled\n\n\n          if (config.appsec.enabled) {\n            require('./appsec').enable(config);\n          }\n\n          this._tracer = new DatadogTracer(config);\n\n          this._instrumenter.enable(config);\n\n          setStartupLogInstrumenter(this._instrumenter);\n        }\n      } catch (e) {\n        log.error(e);\n      }\n    }\n\n    return this;\n  }\n\n  use() {\n    this._instrumenter.use.apply(this._instrumenter, arguments);\n\n    return this;\n  }\n\n  trace(name, options, fn) {\n    if (!fn) {\n      fn = options;\n      options = {};\n    }\n\n    if (typeof fn !== 'function') return;\n    options = options || {};\n    return this._tracer.trace(name, options, fn);\n  }\n\n  wrap(name, options, fn) {\n    if (!fn) {\n      fn = options;\n      options = {};\n    }\n\n    if (typeof fn !== 'function') return fn;\n    options = options || {};\n    return this._tracer.wrap(name, options, fn);\n  }\n\n  setUrl() {\n    this._tracer.setUrl.apply(this._tracer, arguments);\n\n    return this;\n  }\n\n  startSpan() {\n    return this._tracer.startSpan.apply(this._tracer, arguments);\n  }\n\n  inject() {\n    return this._tracer.inject.apply(this._tracer, arguments);\n  }\n\n  extract() {\n    return this._tracer.extract.apply(this._tracer, arguments);\n  }\n\n  scopeManager() {\n    this._deprecate('scopeManager');\n\n    return this._tracer.scopeManager.apply(this._tracer, arguments);\n  }\n\n  scope() {\n    return this._tracer.scope.apply(this._tracer, arguments);\n  }\n\n  currentSpan() {\n    this._deprecate('currentSpan');\n\n    return this._tracer.currentSpan.apply(this._tracer, arguments);\n  }\n\n  bind(callback) {\n    this._deprecate('bind');\n\n    return callback;\n  }\n\n  bindEmitter() {\n    this._deprecate('bindEmitter');\n  }\n\n  getRumData() {\n    return this._tracer.getRumData.apply(this._tracer, arguments);\n  }\n\n}\n\nmodule.exports = Tracer;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/proxy.js"],"names":["BaseTracer","require","Tracer","NoopTracer","DatadogTracer","Config","Instrumenter","metrics","log","setStartupLogInstrumenter","noop","constructor","_tracer","_instrumenter","_deprecate","method","deprecate","join","init","options","config","use","logger","toggle","debug","logLevel","hasOwnProperty","profiling","enabled","profiler","start","e","error","runtimeMetrics","appsec","enable","apply","arguments","trace","name","fn","wrap","setUrl","startSpan","inject","extract","scopeManager","scope","currentSpan","bind","callback","bindEmitter","getRumData","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst BaseTracer = require('opentracing').Tracer\nconst NoopTracer = require('./noop/tracer')\nconst DatadogTracer = require('./tracer')\nconst Config = require('./config')\nconst Instrumenter = require('./instrumenter')\nconst metrics = require('./metrics')\nconst log = require('./log')\nconst { setStartupLogInstrumenter } = require('./startup-log')\n\nconst noop = new NoopTracer()\n\nclass Tracer extends BaseTracer {\n  constructor () {\n    super()\n    this._tracer = noop\n    this._instrumenter = new Instrumenter(this)\n    this._deprecate = method => log.deprecate(`tracer.${method}`, [\n      `tracer.${method}() is deprecated.`,\n      'Please use tracer.startSpan() and tracer.scope() instead.',\n      'See: https://datadog.github.io/dd-trace-js/#manual-instrumentation.'\n    ].join(' '))\n  }\n\n  init (options) {\n    if (this._tracer === noop) {\n      try {\n        const config = new Config(options)\n\n        log.use(config.logger)\n        log.toggle(config.debug, config.logLevel, this)\n\n        if (config.hasOwnProperty('profiling') && config.profiling.enabled) {\n          // do not stop tracer initialization if the profiler fails to be imported\n          try {\n            const profiler = require('./profiler')\n            profiler.start(config)\n          } catch (e) {\n            log.error(e)\n          }\n        }\n\n        if (config.enabled) {\n          if (config.runtimeMetrics) {\n            metrics.start(config)\n          }\n\n          // dirty require for now so zero appsec code is executed unless explicitly enabled\n          if (config.appsec.enabled) {\n            require('./appsec').enable(config)\n          }\n\n          this._tracer = new DatadogTracer(config)\n          this._instrumenter.enable(config)\n          setStartupLogInstrumenter(this._instrumenter)\n        }\n      } catch (e) {\n        log.error(e)\n      }\n    }\n\n    return this\n  }\n\n  use () {\n    this._instrumenter.use.apply(this._instrumenter, arguments)\n    return this\n  }\n\n  trace (name, options, fn) {\n    if (!fn) {\n      fn = options\n      options = {}\n    }\n\n    if (typeof fn !== 'function') return\n\n    options = options || {}\n\n    return this._tracer.trace(name, options, fn)\n  }\n\n  wrap (name, options, fn) {\n    if (!fn) {\n      fn = options\n      options = {}\n    }\n\n    if (typeof fn !== 'function') return fn\n\n    options = options || {}\n\n    return this._tracer.wrap(name, options, fn)\n  }\n\n  setUrl () {\n    this._tracer.setUrl.apply(this._tracer, arguments)\n    return this\n  }\n\n  startSpan () {\n    return this._tracer.startSpan.apply(this._tracer, arguments)\n  }\n\n  inject () {\n    return this._tracer.inject.apply(this._tracer, arguments)\n  }\n\n  extract () {\n    return this._tracer.extract.apply(this._tracer, arguments)\n  }\n\n  scopeManager () {\n    this._deprecate('scopeManager')\n    return this._tracer.scopeManager.apply(this._tracer, arguments)\n  }\n\n  scope () {\n    return this._tracer.scope.apply(this._tracer, arguments)\n  }\n\n  currentSpan () {\n    this._deprecate('currentSpan')\n    return this._tracer.currentSpan.apply(this._tracer, arguments)\n  }\n\n  bind (callback) {\n    this._deprecate('bind')\n    return callback\n  }\n\n  bindEmitter () {\n    this._deprecate('bindEmitter')\n  }\n\n  getRumData () {\n    return this._tracer.getRumData.apply(this._tracer, arguments)\n  }\n}\n\nmodule.exports = Tracer\n"]},"metadata":{},"sourceType":"script"}