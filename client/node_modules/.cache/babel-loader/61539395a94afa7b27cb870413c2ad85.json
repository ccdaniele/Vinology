{"ast":null,"code":"'use strict';\n\nconst URL = require('url').URL;\n\nconst opentracing = require('opentracing');\n\nconst log = require('../../dd-trace/src/log');\n\nconst constants = require('../../dd-trace/src/constants');\n\nconst tags = require('../../../ext/tags');\n\nconst kinds = require('../../../ext/kinds');\n\nconst formats = require('../../../ext/formats');\n\nconst urlFilter = require('../../dd-trace/src/plugins/util/urlfilter');\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler');\n\nconst shimmer = require('../../datadog-shimmer');\n\nconst Reference = opentracing.Reference;\nconst HTTP_HEADERS = formats.HTTP_HEADERS;\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE;\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS;\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS;\nconst SPAN_KIND = tags.SPAN_KIND;\nconst CLIENT = kinds.CLIENT;\nconst REFERENCE_CHILD_OF = opentracing.REFERENCE_CHILD_OF;\nconst REFERENCE_NOOP = constants.REFERENCE_NOOP;\nconst HTTP2_HEADER_METHOD = ':method';\nconst HTTP2_HEADER_PATH = ':path';\nconst HTTP2_HEADER_STATUS = ':status';\nconst HTTP2_METHOD_GET = 'GET';\n\nfunction extractSessionDetails(authority, options) {\n  if (typeof authority === 'string') {\n    authority = new URL(authority);\n  }\n\n  const protocol = authority.protocol || options.protocol || 'https:';\n  let port = '' + (authority.port !== '' ? authority.port : authority.protocol === 'http:' ? 80 : 443);\n  let host = authority.hostname || authority.host || 'localhost';\n\n  if (protocol === 'https:' && options) {\n    port = options.port || port;\n    host = options.host || host;\n  }\n\n  return {\n    protocol,\n    port,\n    host\n  };\n}\n\nfunction getFormattedHostString(host, port) {\n  return [host, port].filter(val => val).join(':');\n}\n\nfunction getServiceName(tracer, config, sessionDetails) {\n  if (config.splitByDomain) {\n    return getFormattedHostString(sessionDetails.host, sessionDetails.port);\n  } else if (config.service) {\n    return config.service;\n  }\n\n  return `${tracer._service}-http-client`;\n}\n\nfunction hasAmazonSignature(headers, path) {\n  if (headers) {\n    headers = Object.keys(headers).reduce((prev, next) => Object.assign(prev, {\n      [next.toLowerCase()]: headers[next]\n    }), {});\n\n    if (headers['x-amz-signature']) {\n      return true;\n    }\n\n    if ([].concat(headers['authorization']).some(startsWith('AWS4-HMAC-SHA256'))) {\n      return true;\n    }\n  }\n\n  return path && path.toLowerCase().indexOf('x-amz-signature=') !== -1;\n}\n\nfunction startsWith(searchString) {\n  return value => String(value).startsWith(searchString);\n}\n\nfunction getStatusValidator(config) {\n  if (typeof config.validateStatus === 'function') {\n    return config.validateStatus;\n  } else if (config.hasOwnProperty('validateStatus')) {\n    log.error('Expected `validateStatus` to be a function.');\n  }\n\n  return code => code < 400 || code >= 500;\n}\n\nfunction getFilter(tracer, config) {\n  const blocklist = tracer._url ? [`${tracer._url.href}/v0.4/traces`] : [];\n  config = Object.assign({}, config, {\n    blocklist: blocklist.concat(config.blocklist || [])\n  });\n  return urlFilter.getFilter(config);\n}\n\nfunction normalizeConfig(tracer, config) {\n  config = config.client || config;\n  const validateStatus = getStatusValidator(config);\n  const filter = getFilter(tracer, config);\n  const headers = getHeaders(config);\n  return Object.assign({}, config, {\n    validateStatus,\n    filter,\n    headers\n  });\n}\n\nfunction addResponseTags(headers, span, config) {\n  const status = headers && headers[HTTP2_HEADER_STATUS];\n  span.setTag(HTTP_STATUS_CODE, status);\n\n  if (!config.validateStatus(status)) {\n    span.setTag('error', 1);\n  }\n\n  addHeaderTags(span, headers, HTTP_RESPONSE_HEADERS, config);\n}\n\nfunction addRequestTags(headers, span, config) {\n  addHeaderTags(span, headers, HTTP_REQUEST_HEADERS, config);\n}\n\nfunction addErrorTags(span, error) {\n  span.setTag('error', error);\n}\n\nfunction addHeaderTags(span, headers, prefix, config) {\n  if (!headers) return;\n  config.headers.forEach(key => {\n    const value = headers[key];\n\n    if (value) {\n      span.setTag(`${prefix}.${key}`, value);\n    }\n  });\n}\n\nfunction getHeaders(config) {\n  if (!Array.isArray(config.headers)) return [];\n  return config.headers.filter(key => typeof key === 'string').map(key => key.toLowerCase());\n}\n\nfunction startSpan(tracer, config, headers, sessionDetails) {\n  headers = headers || {};\n  const scope = tracer.scope();\n  const childOf = scope.active();\n  const path = headers[HTTP2_HEADER_PATH] || '/';\n  const method = headers[HTTP2_HEADER_METHOD] || HTTP2_METHOD_GET;\n  const url = `${sessionDetails.protocol}//${sessionDetails.host}:${sessionDetails.port}${path}`;\n  const type = config.filter(url) ? REFERENCE_CHILD_OF : REFERENCE_NOOP;\n  const span = tracer.startSpan('http.request', {\n    references: [new Reference(type, childOf)],\n    tags: {\n      [SPAN_KIND]: CLIENT,\n      'service.name': getServiceName(tracer, config, sessionDetails),\n      'resource.name': method,\n      'span.type': 'http',\n      'http.method': method,\n      'http.url': url.split('?')[0]\n    }\n  });\n\n  if (!hasAmazonSignature(headers, path)) {\n    tracer.inject(span, HTTP_HEADERS, headers);\n  }\n\n  analyticsSampler.sample(span, config.measured);\n  return span;\n}\n\nfunction createWrapEmit(tracer, config, span) {\n  return function wrapEmit(emit) {\n    return function emitWithTrace(event, arg1) {\n      switch (event) {\n        case 'response':\n          addResponseTags(arg1, span, config);\n          break;\n\n        case 'error':\n          addErrorTags(span, arg1);\n\n        case 'close':\n          // eslint-disable-line no-fallthrough\n          span.finish();\n          break;\n      }\n\n      return emit.apply(this, arguments);\n    };\n  };\n}\n\nfunction createWrapRequest(tracer, config, sessionDetails) {\n  return function wrapRequest(request) {\n    if (!sessionDetails) return request;\n    return function requestWithTrace(headers, options) {\n      const scope = tracer.scope();\n      const span = startSpan(tracer, config, headers, sessionDetails);\n      addRequestTags(headers, span, config);\n      const req = scope.bind(request, span).apply(this, arguments);\n      shimmer.wrap(req, 'emit', createWrapEmit(tracer, config, span));\n      scope.bind(req);\n      return req;\n    };\n  };\n}\n\nfunction createWrapConnect(tracer, config) {\n  config = normalizeConfig(tracer, config);\n  return function wrapConnect(connect) {\n    return function connectWithTrace(authority, options) {\n      const session = connect.apply(this, arguments);\n      const sessionDetails = extractSessionDetails(authority, options);\n      shimmer.wrap(session, 'request', createWrapRequest(tracer, config, sessionDetails));\n      return session;\n    };\n  };\n}\n\nmodule.exports = [{\n  name: 'http2',\n  patch: function (http2, tracer, config) {\n    if (config.client === false) return;\n    this.wrap(http2, 'connect', createWrapConnect(tracer, config));\n  },\n  unpatch: function (http2) {\n    this.unwrap(http2, 'connect');\n  }\n}];","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-http2/src/client.js"],"names":["URL","require","opentracing","log","constants","tags","kinds","formats","urlFilter","analyticsSampler","shimmer","Reference","HTTP_HEADERS","HTTP_STATUS_CODE","HTTP_REQUEST_HEADERS","HTTP_RESPONSE_HEADERS","SPAN_KIND","CLIENT","REFERENCE_CHILD_OF","REFERENCE_NOOP","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_STATUS","HTTP2_METHOD_GET","extractSessionDetails","authority","options","protocol","port","host","hostname","getFormattedHostString","filter","val","join","getServiceName","tracer","config","sessionDetails","splitByDomain","service","_service","hasAmazonSignature","headers","path","Object","keys","reduce","prev","next","assign","toLowerCase","concat","some","startsWith","indexOf","searchString","value","String","getStatusValidator","validateStatus","hasOwnProperty","error","code","getFilter","blocklist","_url","href","normalizeConfig","client","getHeaders","addResponseTags","span","status","setTag","addHeaderTags","addRequestTags","addErrorTags","prefix","forEach","key","Array","isArray","map","startSpan","scope","childOf","active","method","url","type","references","split","inject","sample","measured","createWrapEmit","wrapEmit","emit","emitWithTrace","event","arg1","finish","apply","arguments","createWrapRequest","wrapRequest","request","requestWithTrace","req","bind","wrap","createWrapConnect","wrapConnect","connect","connectWithTrace","session","module","exports","name","patch","http2","unpatch","unwrap"],"mappings":"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","sourcesContent":["'use strict'\n\nconst URL = require('url').URL\nconst opentracing = require('opentracing')\nconst log = require('../../dd-trace/src/log')\nconst constants = require('../../dd-trace/src/constants')\nconst tags = require('../../../ext/tags')\nconst kinds = require('../../../ext/kinds')\nconst formats = require('../../../ext/formats')\nconst urlFilter = require('../../dd-trace/src/plugins/util/urlfilter')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst shimmer = require('../../datadog-shimmer')\n\nconst Reference = opentracing.Reference\n\nconst HTTP_HEADERS = formats.HTTP_HEADERS\nconst HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE\nconst HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS\nconst HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS\nconst SPAN_KIND = tags.SPAN_KIND\nconst CLIENT = kinds.CLIENT\nconst REFERENCE_CHILD_OF = opentracing.REFERENCE_CHILD_OF\nconst REFERENCE_NOOP = constants.REFERENCE_NOOP\n\nconst HTTP2_HEADER_METHOD = ':method'\nconst HTTP2_HEADER_PATH = ':path'\nconst HTTP2_HEADER_STATUS = ':status'\nconst HTTP2_METHOD_GET = 'GET'\n\nfunction extractSessionDetails (authority, options) {\n  if (typeof authority === 'string') {\n    authority = new URL(authority)\n  }\n\n  const protocol = authority.protocol || options.protocol || 'https:'\n  let port = '' + (authority.port !== ''\n    ? authority.port : (authority.protocol === 'http:' ? 80 : 443))\n  let host = authority.hostname || authority.host || 'localhost'\n\n  if (protocol === 'https:' && options) {\n    port = options.port || port\n    host = options.host || host\n  }\n\n  return { protocol, port, host }\n}\n\nfunction getFormattedHostString (host, port) {\n  return [host, port].filter(val => val).join(':')\n}\n\nfunction getServiceName (tracer, config, sessionDetails) {\n  if (config.splitByDomain) {\n    return getFormattedHostString(sessionDetails.host, sessionDetails.port)\n  } else if (config.service) {\n    return config.service\n  }\n\n  return `${tracer._service}-http-client`\n}\n\nfunction hasAmazonSignature (headers, path) {\n  if (headers) {\n    headers = Object.keys(headers)\n      .reduce((prev, next) => Object.assign(prev, {\n        [next.toLowerCase()]: headers[next]\n      }), {})\n\n    if (headers['x-amz-signature']) {\n      return true\n    }\n\n    if ([].concat(headers['authorization']).some(startsWith('AWS4-HMAC-SHA256'))) {\n      return true\n    }\n  }\n\n  return path && path.toLowerCase().indexOf('x-amz-signature=') !== -1\n}\n\nfunction startsWith (searchString) {\n  return value => String(value).startsWith(searchString)\n}\n\nfunction getStatusValidator (config) {\n  if (typeof config.validateStatus === 'function') {\n    return config.validateStatus\n  } else if (config.hasOwnProperty('validateStatus')) {\n    log.error('Expected `validateStatus` to be a function.')\n  }\n  return code => code < 400 || code >= 500\n}\n\nfunction getFilter (tracer, config) {\n  const blocklist = tracer._url ? [`${tracer._url.href}/v0.4/traces`] : []\n\n  config = Object.assign({}, config, {\n    blocklist: blocklist.concat(config.blocklist || [])\n  })\n\n  return urlFilter.getFilter(config)\n}\n\nfunction normalizeConfig (tracer, config) {\n  config = config.client || config\n\n  const validateStatus = getStatusValidator(config)\n  const filter = getFilter(tracer, config)\n  const headers = getHeaders(config)\n\n  return Object.assign({}, config, {\n    validateStatus,\n    filter,\n    headers\n  })\n}\n\nfunction addResponseTags (headers, span, config) {\n  const status = headers && headers[HTTP2_HEADER_STATUS]\n\n  span.setTag(HTTP_STATUS_CODE, status)\n\n  if (!config.validateStatus(status)) {\n    span.setTag('error', 1)\n  }\n\n  addHeaderTags(span, headers, HTTP_RESPONSE_HEADERS, config)\n}\n\nfunction addRequestTags (headers, span, config) {\n  addHeaderTags(span, headers, HTTP_REQUEST_HEADERS, config)\n}\n\nfunction addErrorTags (span, error) {\n  span.setTag('error', error)\n}\n\nfunction addHeaderTags (span, headers, prefix, config) {\n  if (!headers) return\n\n  config.headers.forEach(key => {\n    const value = headers[key]\n\n    if (value) {\n      span.setTag(`${prefix}.${key}`, value)\n    }\n  })\n}\n\nfunction getHeaders (config) {\n  if (!Array.isArray(config.headers)) return []\n\n  return config.headers\n    .filter(key => typeof key === 'string')\n    .map(key => key.toLowerCase())\n}\n\nfunction startSpan (tracer, config, headers, sessionDetails) {\n  headers = headers || {}\n\n  const scope = tracer.scope()\n  const childOf = scope.active()\n\n  const path = headers[HTTP2_HEADER_PATH] || '/'\n  const method = headers[HTTP2_HEADER_METHOD] || HTTP2_METHOD_GET\n  const url = `${sessionDetails.protocol}//${sessionDetails.host}:${sessionDetails.port}${path}`\n\n  const type = config.filter(url) ? REFERENCE_CHILD_OF : REFERENCE_NOOP\n\n  const span = tracer.startSpan('http.request', {\n    references: [\n      new Reference(type, childOf)\n    ],\n    tags: {\n      [SPAN_KIND]: CLIENT,\n      'service.name': getServiceName(tracer, config, sessionDetails),\n      'resource.name': method,\n      'span.type': 'http',\n      'http.method': method,\n      'http.url': url.split('?')[0]\n    }\n  })\n\n  if (!hasAmazonSignature(headers, path)) {\n    tracer.inject(span, HTTP_HEADERS, headers)\n  }\n\n  analyticsSampler.sample(span, config.measured)\n  return span\n}\n\nfunction createWrapEmit (tracer, config, span) {\n  return function wrapEmit (emit) {\n    return function emitWithTrace (event, arg1) {\n      switch (event) {\n        case 'response':\n          addResponseTags(arg1, span, config)\n          break\n        case 'error':\n          addErrorTags(span, arg1)\n        case 'close': // eslint-disable-line no-fallthrough\n          span.finish()\n          break\n      }\n      return emit.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapRequest (tracer, config, sessionDetails) {\n  return function wrapRequest (request) {\n    if (!sessionDetails) return request\n\n    return function requestWithTrace (headers, options) {\n      const scope = tracer.scope()\n      const span = startSpan(tracer, config, headers, sessionDetails)\n\n      addRequestTags(headers, span, config)\n\n      const req = scope.bind(request, span).apply(this, arguments)\n\n      shimmer.wrap(req, 'emit', createWrapEmit(tracer, config, span))\n      scope.bind(req)\n\n      return req\n    }\n  }\n}\n\nfunction createWrapConnect (tracer, config) {\n  config = normalizeConfig(tracer, config)\n\n  return function wrapConnect (connect) {\n    return function connectWithTrace (authority, options) {\n      const session = connect.apply(this, arguments)\n\n      const sessionDetails = extractSessionDetails(authority, options)\n\n      shimmer.wrap(session, 'request', createWrapRequest(tracer, config, sessionDetails))\n      return session\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'http2',\n    patch: function (http2, tracer, config) {\n      if (config.client === false) return\n\n      this.wrap(http2, 'connect', createWrapConnect(tracer, config))\n    },\n    unpatch: function (http2) {\n      this.unwrap(http2, 'connect')\n    }\n  }\n]\n"]},"metadata":{},"sourceType":"script"}