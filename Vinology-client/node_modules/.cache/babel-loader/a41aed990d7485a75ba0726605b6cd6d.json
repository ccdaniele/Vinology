{"ast":null,"code":"'use strict';\n\nconst pick = require('lodash.pick');\n\nconst log = require('../../dd-trace/src/log');\n\nmodule.exports = {\n  addMethodTags(span, path, kind) {\n    if (typeof path !== 'string') return;\n    span.addTags({\n      'grpc.method.path': path,\n      'grpc.method.kind': kind\n    });\n    const methodParts = path.split('/');\n\n    if (methodParts.length > 2) {\n      const serviceParts = methodParts[1].split('.');\n      const name = methodParts[2];\n      const service = serviceParts.pop();\n      const pkg = serviceParts.join('.');\n      span.addTags({\n        'grpc.method.name': name,\n        'grpc.method.service': service,\n        'grpc.method.package': pkg\n      });\n    } else {\n      span.addTags({\n        'grpc.method.name': methodParts[methodParts.length - 1]\n      });\n    }\n  },\n\n  addMetadataTags(span, metadata, filter, type) {\n    if (!metadata || typeof metadata.getMap !== 'function') return;\n    const values = filter(metadata.getMap());\n\n    for (const key in values) {\n      span.setTag(`grpc.${type}.metadata.${key}`, values[key]);\n    }\n  },\n\n  // TODO: extract this to shared utils and add unit tests\n  getFilter(config, filter) {\n    if (typeof config[filter] === 'function') {\n      return config[filter];\n    }\n\n    if (config[filter] instanceof Array) {\n      return element => pick(element, config[filter]);\n    }\n\n    if (config.hasOwnProperty(filter)) {\n      log.error(`Expected '${filter}' to be an array or function.`);\n    }\n\n    return () => ({});\n  }\n\n};","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-grpc/src/util.js"],"names":["pick","require","log","module","exports","addMethodTags","span","path","kind","addTags","methodParts","split","length","serviceParts","name","service","pop","pkg","join","addMetadataTags","metadata","filter","type","getMap","values","key","setTag","getFilter","config","Array","element","hasOwnProperty","error"],"mappings":"AAAA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,aAAD,CAApB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,wBAAD,CAAnB;;AAEAE,MAAM,CAACC,OAAP,GAAiB;AACfC,EAAAA,aAAa,CAAEC,IAAF,EAAQC,IAAR,EAAcC,IAAd,EAAoB;AAC/B,QAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;AAE9BD,IAAAA,IAAI,CAACG,OAAL,CAAa;AACX,0BAAoBF,IADT;AAEX,0BAAoBC;AAFT,KAAb;AAKA,UAAME,WAAW,GAAGH,IAAI,CAACI,KAAL,CAAW,GAAX,CAApB;;AAEA,QAAID,WAAW,CAACE,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,YAAMC,YAAY,GAAGH,WAAW,CAAC,CAAD,CAAX,CAAeC,KAAf,CAAqB,GAArB,CAArB;AACA,YAAMG,IAAI,GAAGJ,WAAW,CAAC,CAAD,CAAxB;AACA,YAAMK,OAAO,GAAGF,YAAY,CAACG,GAAb,EAAhB;AACA,YAAMC,GAAG,GAAGJ,YAAY,CAACK,IAAb,CAAkB,GAAlB,CAAZ;AAEAZ,MAAAA,IAAI,CAACG,OAAL,CAAa;AACX,4BAAoBK,IADT;AAEX,+BAAuBC,OAFZ;AAGX,+BAAuBE;AAHZ,OAAb;AAKD,KAXD,MAWO;AACLX,MAAAA,IAAI,CAACG,OAAL,CAAa;AACX,4BAAoBC,WAAW,CAACA,WAAW,CAACE,MAAZ,GAAqB,CAAtB;AADpB,OAAb;AAGD;AACF,GA3Bc;;AA6BfO,EAAAA,eAAe,CAAEb,IAAF,EAAQc,QAAR,EAAkBC,MAAlB,EAA0BC,IAA1B,EAAgC;AAC7C,QAAI,CAACF,QAAD,IAAa,OAAOA,QAAQ,CAACG,MAAhB,KAA2B,UAA5C,EAAwD;AAExD,UAAMC,MAAM,GAAGH,MAAM,CAACD,QAAQ,CAACG,MAAT,EAAD,CAArB;;AAEA,SAAK,MAAME,GAAX,IAAkBD,MAAlB,EAA0B;AACxBlB,MAAAA,IAAI,CAACoB,MAAL,CAAa,QAAOJ,IAAK,aAAYG,GAAI,EAAzC,EAA4CD,MAAM,CAACC,GAAD,CAAlD;AACD;AACF,GArCc;;AAuCf;AACAE,EAAAA,SAAS,CAAEC,MAAF,EAAUP,MAAV,EAAkB;AACzB,QAAI,OAAOO,MAAM,CAACP,MAAD,CAAb,KAA0B,UAA9B,EAA0C;AACxC,aAAOO,MAAM,CAACP,MAAD,CAAb;AACD;;AAED,QAAIO,MAAM,CAACP,MAAD,CAAN,YAA0BQ,KAA9B,EAAqC;AACnC,aAAOC,OAAO,IAAI9B,IAAI,CAAC8B,OAAD,EAAUF,MAAM,CAACP,MAAD,CAAhB,CAAtB;AACD;;AAED,QAAIO,MAAM,CAACG,cAAP,CAAsBV,MAAtB,CAAJ,EAAmC;AACjCnB,MAAAA,GAAG,CAAC8B,KAAJ,CAAW,aAAYX,MAAO,+BAA9B;AACD;;AAED,WAAO,OAAO,EAAP,CAAP;AACD;;AAtDc,CAAjB","sourcesContent":["'use strict'\n\nconst pick = require('lodash.pick')\nconst log = require('../../dd-trace/src/log')\n\nmodule.exports = {\n  addMethodTags (span, path, kind) {\n    if (typeof path !== 'string') return\n\n    span.addTags({\n      'grpc.method.path': path,\n      'grpc.method.kind': kind\n    })\n\n    const methodParts = path.split('/')\n\n    if (methodParts.length > 2) {\n      const serviceParts = methodParts[1].split('.')\n      const name = methodParts[2]\n      const service = serviceParts.pop()\n      const pkg = serviceParts.join('.')\n\n      span.addTags({\n        'grpc.method.name': name,\n        'grpc.method.service': service,\n        'grpc.method.package': pkg\n      })\n    } else {\n      span.addTags({\n        'grpc.method.name': methodParts[methodParts.length - 1]\n      })\n    }\n  },\n\n  addMetadataTags (span, metadata, filter, type) {\n    if (!metadata || typeof metadata.getMap !== 'function') return\n\n    const values = filter(metadata.getMap())\n\n    for (const key in values) {\n      span.setTag(`grpc.${type}.metadata.${key}`, values[key])\n    }\n  },\n\n  // TODO: extract this to shared utils and add unit tests\n  getFilter (config, filter) {\n    if (typeof config[filter] === 'function') {\n      return config[filter]\n    }\n\n    if (config[filter] instanceof Array) {\n      return element => pick(element, config[filter])\n    }\n\n    if (config.hasOwnProperty(filter)) {\n      log.error(`Expected '${filter}' to be an array or function.`)\n    }\n\n    return () => ({})\n  }\n}\n"]},"metadata":{},"sourceType":"script"}