{"ast":null,"code":"const log = require('./log');\n\nconst format = require('./format');\n\nconst startedSpans = new WeakSet();\nconst finishedSpans = new WeakSet();\n\nclass SpanProcessor {\n  constructor(exporter, prioritySampler) {\n    this._exporter = exporter;\n    this._prioritySampler = prioritySampler;\n  }\n\n  process(span) {\n    const spanContext = span.context();\n    const trace = spanContext._trace;\n\n    if (trace.started.length === trace.finished.length) {\n      this._prioritySampler.sample(spanContext);\n\n      if (spanContext._traceFlags.sampled === false) {\n        log.debug(() => `Dropping trace due to user configured filtering: ${trace.started}`);\n\n        this._erase(trace);\n\n        return;\n      }\n\n      const formattedSpans = trace.finished.map(format);\n\n      this._exporter.export(formattedSpans);\n\n      this._erase(trace);\n    }\n  }\n\n  _erase(trace) {\n    if (process.env.DD_TRACE_EXPERIMENTAL_STATE_TRACKING === 'true') {\n      const started = new Set();\n      const startedIds = new Set();\n      const finished = new Set();\n      const finishedIds = new Set();\n\n      for (const span of trace.finished) {\n        const context = span.context();\n        const id = context.toSpanId();\n\n        if (finished.has(span)) {\n          log.error(`Span was already finished in the same trace: ${span}`);\n        } else {\n          finished.add(span);\n\n          if (finishedIds.has(id)) {\n            log.error(`Another span with the same ID was already finished in the same trace: ${span}`);\n          } else {\n            finishedIds.add(id);\n          }\n\n          if (context._trace !== trace) {\n            log.error(`A span was finished in the wrong trace: ${span}.`);\n          }\n\n          if (finishedSpans.has(span)) {\n            log.error(`Span was already finished in a different trace: ${span}`);\n          } else {\n            finishedSpans.add(span);\n          }\n        }\n      }\n\n      for (const span of trace.started) {\n        const context = span.context();\n        const id = context.toSpanId();\n\n        if (started.has(span)) {\n          log.error(`Span was already started in the same trace: ${span}`);\n        } else {\n          started.add(span);\n\n          if (startedIds.has(id)) {\n            log.error(`Another span with the same ID was already started in the same trace: ${span}`);\n          } else {\n            startedIds.add(id);\n          }\n\n          if (context._trace !== trace) {\n            log.error(`A span was started in the wrong trace: ${span}.`);\n          }\n\n          if (startedSpans.has(span)) {\n            log.error(`Span was already started in a different trace: ${span}`);\n          } else {\n            startedSpans.add(span);\n          }\n        }\n\n        if (!finished.has(span)) {\n          log.error(`Span started in one trace but was finished in another trace: ${span}`);\n        }\n      }\n\n      for (const span of trace.finished) {\n        if (!started.has(span)) {\n          log.error(`Span finished in one trace but was started in another trace: ${span}`);\n        }\n      }\n    }\n\n    for (const span of trace.finished) {\n      span.context()._tags = {};\n    }\n\n    trace.started = [];\n    trace.finished = [];\n  }\n\n}\n\nmodule.exports = SpanProcessor;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/span_processor.js"],"names":["log","require","format","startedSpans","WeakSet","finishedSpans","SpanProcessor","constructor","exporter","prioritySampler","_exporter","_prioritySampler","process","span","spanContext","context","trace","_trace","started","length","finished","sample","_traceFlags","sampled","debug","_erase","formattedSpans","map","export","env","DD_TRACE_EXPERIMENTAL_STATE_TRACKING","Set","startedIds","finishedIds","id","toSpanId","has","error","add","_tags","module","exports"],"mappings":"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","sourcesContent":["const log = require('./log')\nconst format = require('./format')\n\nconst startedSpans = new WeakSet()\nconst finishedSpans = new WeakSet()\n\nclass SpanProcessor {\n  constructor (exporter, prioritySampler) {\n    this._exporter = exporter\n    this._prioritySampler = prioritySampler\n  }\n\n  process (span) {\n    const spanContext = span.context()\n    const trace = spanContext._trace\n\n    if (trace.started.length === trace.finished.length) {\n      this._prioritySampler.sample(spanContext)\n\n      if (spanContext._traceFlags.sampled === false) {\n        log.debug(() => `Dropping trace due to user configured filtering: ${trace.started}`)\n        this._erase(trace)\n        return\n      }\n\n      const formattedSpans = trace.finished.map(format)\n      this._exporter.export(formattedSpans)\n      this._erase(trace)\n    }\n  }\n\n  _erase (trace) {\n    if (process.env.DD_TRACE_EXPERIMENTAL_STATE_TRACKING === 'true') {\n      const started = new Set()\n      const startedIds = new Set()\n      const finished = new Set()\n      const finishedIds = new Set()\n\n      for (const span of trace.finished) {\n        const context = span.context()\n        const id = context.toSpanId()\n\n        if (finished.has(span)) {\n          log.error(`Span was already finished in the same trace: ${span}`)\n        } else {\n          finished.add(span)\n\n          if (finishedIds.has(id)) {\n            log.error(`Another span with the same ID was already finished in the same trace: ${span}`)\n          } else {\n            finishedIds.add(id)\n          }\n\n          if (context._trace !== trace) {\n            log.error(`A span was finished in the wrong trace: ${span}.`)\n          }\n\n          if (finishedSpans.has(span)) {\n            log.error(`Span was already finished in a different trace: ${span}`)\n          } else {\n            finishedSpans.add(span)\n          }\n        }\n      }\n\n      for (const span of trace.started) {\n        const context = span.context()\n        const id = context.toSpanId()\n\n        if (started.has(span)) {\n          log.error(`Span was already started in the same trace: ${span}`)\n        } else {\n          started.add(span)\n\n          if (startedIds.has(id)) {\n            log.error(`Another span with the same ID was already started in the same trace: ${span}`)\n          } else {\n            startedIds.add(id)\n          }\n\n          if (context._trace !== trace) {\n            log.error(`A span was started in the wrong trace: ${span}.`)\n          }\n\n          if (startedSpans.has(span)) {\n            log.error(`Span was already started in a different trace: ${span}`)\n          } else {\n            startedSpans.add(span)\n          }\n        }\n\n        if (!finished.has(span)) {\n          log.error(`Span started in one trace but was finished in another trace: ${span}`)\n        }\n      }\n\n      for (const span of trace.finished) {\n        if (!started.has(span)) {\n          log.error(`Span finished in one trace but was started in another trace: ${span}`)\n        }\n      }\n    }\n\n    for (const span of trace.finished) {\n      span.context()._tags = {}\n    }\n\n    trace.started = []\n    trace.finished = []\n  }\n}\n\nmodule.exports = SpanProcessor\n"]},"metadata":{},"sourceType":"script"}