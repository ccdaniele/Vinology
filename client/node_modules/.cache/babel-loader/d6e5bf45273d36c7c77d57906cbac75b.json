{"ast":null,"code":"'use strict';\n\nconst constants = require('./constants');\n\nconst tags = require('../../../ext/tags');\n\nconst log = require('./log');\n\nconst id = require('./id');\n\nconst {\n  isError\n} = require('./util');\n\nconst SAMPLING_PRIORITY_KEY = constants.SAMPLING_PRIORITY_KEY;\nconst SAMPLING_RULE_DECISION = constants.SAMPLING_RULE_DECISION;\nconst SAMPLING_LIMIT_DECISION = constants.SAMPLING_LIMIT_DECISION;\nconst SAMPLING_AGENT_DECISION = constants.SAMPLING_AGENT_DECISION;\nconst MEASURED = tags.MEASURED;\nconst ORIGIN_KEY = constants.ORIGIN_KEY;\nconst HOSTNAME_KEY = constants.HOSTNAME_KEY;\nconst map = {\n  'service.name': 'service',\n  'span.type': 'type',\n  'resource.name': 'resource'\n};\n\nfunction format(span) {\n  const formatted = formatSpan(span);\n  extractError(formatted, span);\n  extractRootTags(formatted, span);\n  extractTags(formatted, span);\n  return formatted;\n}\n\nfunction formatSpan(span) {\n  const spanContext = span.context();\n  return {\n    trace_id: spanContext._traceId,\n    span_id: spanContext._spanId,\n    parent_id: spanContext._parentId || id('0'),\n    name: serialize(spanContext._name),\n    resource: serialize(spanContext._name),\n    error: 0,\n    meta: {},\n    metrics: {},\n    start: Math.round(span._startTime * 1e6),\n    duration: Math.round(span._duration * 1e6)\n  };\n}\n\nfunction extractTags(trace, span) {\n  const context = span.context();\n  const origin = context._trace.origin;\n  const tags = context._tags;\n  const hostname = context._hostname;\n  const priority = context._sampling.priority;\n\n  const internalErrors = span.tracer()._internalErrors;\n\n  if (tags['span.kind'] && tags['span.kind'] !== 'internal') {\n    addTag({}, trace.metrics, MEASURED, 1);\n  }\n\n  for (const tag in tags) {\n    switch (tag) {\n      case 'service.name':\n      case 'span.type':\n      case 'resource.name':\n        addTag(trace, {}, map[tag], tags[tag]);\n        break;\n      // HACK: remove when Datadog supports numeric status code\n\n      case 'http.status_code':\n        addTag(trace.meta, {}, tag, tags[tag] && String(tags[tag]));\n        break;\n\n      case HOSTNAME_KEY:\n      case MEASURED:\n        addTag({}, trace.metrics, tag, tags[tag] === undefined || tags[tag] ? 1 : 0);\n        break;\n\n      case 'error':\n        if (tags[tag] && (context._name !== 'fs.operation' || internalErrors)) {\n          trace.error = 1;\n        }\n\n        break;\n\n      case 'error.type':\n      case 'error.msg':\n      case 'error.stack':\n        // HACK: remove when implemented in the backend\n        if (context._name !== 'fs.operation' || internalErrors) {\n          trace.error = 1;\n        }\n\n      default:\n        // eslint-disable-line no-fallthrough\n        addTag(trace.meta, trace.metrics, tag, tags[tag]);\n    }\n  }\n\n  if (span.tracer()._service === tags['service.name']) {\n    addTag(trace.meta, trace.metrics, 'language', 'javascript');\n  }\n\n  addTag(trace.meta, trace.metrics, SAMPLING_PRIORITY_KEY, priority);\n  addTag(trace.meta, trace.metrics, ORIGIN_KEY, origin);\n  addTag(trace.meta, trace.metrics, HOSTNAME_KEY, hostname);\n}\n\nfunction extractRootTags(trace, span) {\n  const context = span.context();\n  const isLocalRoot = span === context._trace.started[0];\n  const parentId = context._parentId;\n  if (!isLocalRoot || parentId && parentId.toString(10) !== '0') return;\n  addTag({}, trace.metrics, SAMPLING_RULE_DECISION, context._trace[SAMPLING_RULE_DECISION]);\n  addTag({}, trace.metrics, SAMPLING_LIMIT_DECISION, context._trace[SAMPLING_LIMIT_DECISION]);\n  addTag({}, trace.metrics, SAMPLING_AGENT_DECISION, context._trace[SAMPLING_AGENT_DECISION]);\n}\n\nfunction extractError(trace, span) {\n  const error = span.context()._tags['error'];\n\n  if (isError(error)) {\n    addTag(trace.meta, trace.metrics, 'error.msg', error.message);\n    addTag(trace.meta, trace.metrics, 'error.type', error.name);\n    addTag(trace.meta, trace.metrics, 'error.stack', error.stack);\n  }\n}\n\nfunction addTag(meta, metrics, key, value, seen) {\n  switch (typeof value) {\n    case 'string':\n      if (!value) break;\n      meta[key] = value;\n      break;\n\n    case 'number':\n      if (isNaN(value)) break;\n      metrics[key] = value;\n      break;\n\n    case 'undefined':\n      break;\n\n    case 'object':\n      if (value === null) break; // Special case for Node.js Buffer and URL\n\n      if (isNodeBuffer(value) || isUrl(value)) {\n        metrics[key] = value.toString();\n        break;\n      }\n\n      if (!Array.isArray(value)) {\n        addObjectTag(meta, metrics, key, value, seen);\n        break;\n      }\n\n    default:\n      // eslint-disable-line no-fallthrough\n      addTag(meta, metrics, key, serialize(value));\n  }\n}\n\nfunction addObjectTag(meta, metrics, key, value, seen) {\n  seen = seen || [];\n\n  if (~seen.indexOf(value)) {\n    meta[key] = '[Circular]';\n    return;\n  }\n\n  seen.push(value);\n\n  for (const prop in value) {\n    addTag(meta, metrics, `${key}.${prop}`, value[prop], seen);\n  }\n\n  seen.pop();\n}\n\nfunction serialize(obj) {\n  try {\n    return obj && typeof obj.toString !== 'function' ? JSON.stringify(obj) : String(obj);\n  } catch (e) {\n    log.error(e);\n  }\n}\n\nfunction isNodeBuffer(obj) {\n  return obj.constructor && obj.constructor.name === 'Buffer' && typeof obj.readInt8 === 'function' && typeof obj.toString === 'function';\n}\n\nfunction isUrl(obj) {\n  return obj.constructor && obj.constructor.name === 'URL' && typeof obj.href === 'string' && typeof obj.toString === 'function';\n}\n\nmodule.exports = format;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/format.js"],"names":["constants","require","tags","log","id","isError","SAMPLING_PRIORITY_KEY","SAMPLING_RULE_DECISION","SAMPLING_LIMIT_DECISION","SAMPLING_AGENT_DECISION","MEASURED","ORIGIN_KEY","HOSTNAME_KEY","map","format","span","formatted","formatSpan","extractError","extractRootTags","extractTags","spanContext","context","trace_id","_traceId","span_id","_spanId","parent_id","_parentId","name","serialize","_name","resource","error","meta","metrics","start","Math","round","_startTime","duration","_duration","trace","origin","_trace","_tags","hostname","_hostname","priority","_sampling","internalErrors","tracer","_internalErrors","addTag","tag","String","undefined","_service","isLocalRoot","started","parentId","toString","message","stack","key","value","seen","isNaN","isNodeBuffer","isUrl","Array","isArray","addObjectTag","indexOf","push","prop","pop","obj","JSON","stringify","e","constructor","readInt8","href","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst constants = require('./constants')\nconst tags = require('../../../ext/tags')\nconst log = require('./log')\nconst id = require('./id')\nconst { isError } = require('./util')\n\nconst SAMPLING_PRIORITY_KEY = constants.SAMPLING_PRIORITY_KEY\nconst SAMPLING_RULE_DECISION = constants.SAMPLING_RULE_DECISION\nconst SAMPLING_LIMIT_DECISION = constants.SAMPLING_LIMIT_DECISION\nconst SAMPLING_AGENT_DECISION = constants.SAMPLING_AGENT_DECISION\nconst MEASURED = tags.MEASURED\nconst ORIGIN_KEY = constants.ORIGIN_KEY\nconst HOSTNAME_KEY = constants.HOSTNAME_KEY\n\nconst map = {\n  'service.name': 'service',\n  'span.type': 'type',\n  'resource.name': 'resource'\n}\n\nfunction format (span) {\n  const formatted = formatSpan(span)\n\n  extractError(formatted, span)\n  extractRootTags(formatted, span)\n  extractTags(formatted, span)\n\n  return formatted\n}\n\nfunction formatSpan (span) {\n  const spanContext = span.context()\n\n  return {\n    trace_id: spanContext._traceId,\n    span_id: spanContext._spanId,\n    parent_id: spanContext._parentId || id('0'),\n    name: serialize(spanContext._name),\n    resource: serialize(spanContext._name),\n    error: 0,\n    meta: {},\n    metrics: {},\n    start: Math.round(span._startTime * 1e6),\n    duration: Math.round(span._duration * 1e6)\n  }\n}\n\nfunction extractTags (trace, span) {\n  const context = span.context()\n  const origin = context._trace.origin\n  const tags = context._tags\n  const hostname = context._hostname\n  const priority = context._sampling.priority\n  const internalErrors = span.tracer()._internalErrors\n\n  if (tags['span.kind'] && tags['span.kind'] !== 'internal') {\n    addTag({}, trace.metrics, MEASURED, 1)\n  }\n\n  for (const tag in tags) {\n    switch (tag) {\n      case 'service.name':\n      case 'span.type':\n      case 'resource.name':\n        addTag(trace, {}, map[tag], tags[tag])\n        break\n      // HACK: remove when Datadog supports numeric status code\n      case 'http.status_code':\n        addTag(trace.meta, {}, tag, tags[tag] && String(tags[tag]))\n        break\n      case HOSTNAME_KEY:\n      case MEASURED:\n        addTag({}, trace.metrics, tag, tags[tag] === undefined || tags[tag] ? 1 : 0)\n        break\n      case 'error':\n        if (tags[tag] && (context._name !== 'fs.operation' || internalErrors)) {\n          trace.error = 1\n        }\n        break\n      case 'error.type':\n      case 'error.msg':\n      case 'error.stack':\n        // HACK: remove when implemented in the backend\n        if (context._name !== 'fs.operation' || internalErrors) {\n          trace.error = 1\n        }\n      default: // eslint-disable-line no-fallthrough\n        addTag(trace.meta, trace.metrics, tag, tags[tag])\n    }\n  }\n\n  if (span.tracer()._service === tags['service.name']) {\n    addTag(trace.meta, trace.metrics, 'language', 'javascript')\n  }\n\n  addTag(trace.meta, trace.metrics, SAMPLING_PRIORITY_KEY, priority)\n  addTag(trace.meta, trace.metrics, ORIGIN_KEY, origin)\n  addTag(trace.meta, trace.metrics, HOSTNAME_KEY, hostname)\n}\n\nfunction extractRootTags (trace, span) {\n  const context = span.context()\n  const isLocalRoot = span === context._trace.started[0]\n  const parentId = context._parentId\n\n  if (!isLocalRoot || (parentId && parentId.toString(10) !== '0')) return\n\n  addTag({}, trace.metrics, SAMPLING_RULE_DECISION, context._trace[SAMPLING_RULE_DECISION])\n  addTag({}, trace.metrics, SAMPLING_LIMIT_DECISION, context._trace[SAMPLING_LIMIT_DECISION])\n  addTag({}, trace.metrics, SAMPLING_AGENT_DECISION, context._trace[SAMPLING_AGENT_DECISION])\n}\n\nfunction extractError (trace, span) {\n  const error = span.context()._tags['error']\n  if (isError(error)) {\n    addTag(trace.meta, trace.metrics, 'error.msg', error.message)\n    addTag(trace.meta, trace.metrics, 'error.type', error.name)\n    addTag(trace.meta, trace.metrics, 'error.stack', error.stack)\n  }\n}\n\nfunction addTag (meta, metrics, key, value, seen) {\n  switch (typeof value) {\n    case 'string':\n      if (!value) break\n      meta[key] = value\n      break\n    case 'number':\n      if (isNaN(value)) break\n      metrics[key] = value\n      break\n    case 'undefined':\n      break\n    case 'object':\n      if (value === null) break\n\n      // Special case for Node.js Buffer and URL\n      if (isNodeBuffer(value) || isUrl(value)) {\n        metrics[key] = value.toString()\n        break\n      }\n\n      if (!Array.isArray(value)) {\n        addObjectTag(meta, metrics, key, value, seen)\n        break\n      }\n\n    default: // eslint-disable-line no-fallthrough\n      addTag(meta, metrics, key, serialize(value))\n  }\n}\n\nfunction addObjectTag (meta, metrics, key, value, seen) {\n  seen = seen || []\n\n  if (~seen.indexOf(value)) {\n    meta[key] = '[Circular]'\n    return\n  }\n\n  seen.push(value)\n\n  for (const prop in value) {\n    addTag(meta, metrics, `${key}.${prop}`, value[prop], seen)\n  }\n\n  seen.pop()\n}\n\nfunction serialize (obj) {\n  try {\n    return obj && typeof obj.toString !== 'function' ? JSON.stringify(obj) : String(obj)\n  } catch (e) {\n    log.error(e)\n  }\n}\n\nfunction isNodeBuffer (obj) {\n  return obj.constructor && obj.constructor.name === 'Buffer' &&\n    typeof obj.readInt8 === 'function' &&\n    typeof obj.toString === 'function'\n}\n\nfunction isUrl (obj) {\n  return obj.constructor && obj.constructor.name === 'URL' &&\n    typeof obj.href === 'string' &&\n    typeof obj.toString === 'function'\n}\n\nmodule.exports = format\n"]},"metadata":{},"sourceType":"script"}