{"ast":null,"code":"\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CollapsingLowestDenseStore = void 0;\n\nvar DenseStore_1 = require(\"./DenseStore\");\n\nvar util_1 = require(\"./util\");\n/**\n * `CollapsingLowestDenseStore` is a dense store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins\n * if the number of bins exceeds `binLimit`\n */\n\n\nvar CollapsingLowestDenseStore =\n/** @class */\nfunction (_super) {\n  __extends(CollapsingLowestDenseStore, _super);\n  /**\n   * Initialize a new CollapsingLowestDenseStore\n   *\n   * @param binLimit The maximum number of bins\n   * @param chunkSize The number of bins to add each time the bins grow (default 128)\n   */\n\n\n  function CollapsingLowestDenseStore(binLimit, chunkSize) {\n    var _this = _super.call(this, chunkSize) || this;\n\n    _this.binLimit = binLimit;\n    _this.isCollapsed = false;\n    return _this;\n  }\n  /**\n   * Merge the contents of the parameter `store` into this store\n   *\n   * @param store The store to merge into the caller store\n   */\n\n\n  CollapsingLowestDenseStore.prototype.merge = function (store) {\n    if (store.count === 0) {\n      return;\n    }\n\n    if (this.count === 0) {\n      this.copy(store);\n      return;\n    }\n\n    if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n      this._extendRange(store.minKey, store.maxKey);\n    }\n\n    var collapseStartIndex = store.minKey - store.offset;\n    var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;\n\n    if (collapseEndIndex > collapseStartIndex) {\n      var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);\n      this.bins[0] += collapseCount;\n    } else {\n      collapseEndIndex = collapseStartIndex;\n    }\n\n    for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {\n      this.bins[key - this.offset] += store.bins[key - store.offset];\n    }\n\n    this.count += store.count;\n  };\n  /**\n   * Directly clone the contents of the parameter `store` into this store\n   *\n   * @param store The store to be copied into the caller store\n   */\n\n\n  CollapsingLowestDenseStore.prototype.copy = function (store) {\n    _super.prototype.copy.call(this, store);\n\n    this.isCollapsed = store.isCollapsed;\n  };\n\n  CollapsingLowestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n    var desiredLength = newMaxKey - newMinKey + 1;\n    return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);\n  };\n  /**\n   * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n   * without resizing the bins, in order to try to make it fit the specified range.\n   * Collapse to the left if necessary\n   */\n\n\n  CollapsingLowestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n    if (newMaxKey - newMinKey + 1 > this.length()) {\n      // The range of keys is too wide, the lowest bins need to be collapsed\n      newMinKey = newMaxKey - this.length() + 1;\n\n      if (newMinKey >= this.maxKey) {\n        // Put everything in the first bin\n        this.offset = newMinKey;\n        this.minKey = newMinKey;\n        this.bins.fill(0);\n        this.bins[0] = this.count;\n      } else {\n        var shift = this.offset - newMinKey;\n\n        if (shift < 0) {\n          var collapseStartIndex = this.minKey - this.offset;\n          var collapseEndIndex = newMinKey - this.offset;\n          var collapsedCount = util_1.sumOfRange(this.bins, collapseStartIndex, collapseEndIndex);\n          this.bins.fill(0, collapseStartIndex, collapseEndIndex);\n          this.bins[collapseEndIndex] += collapsedCount;\n          this.minKey = newMinKey;\n\n          this._shiftBins(shift);\n        } else {\n          this.minKey = newMinKey; // Shift the buckets to make room for newMinKey\n\n          this._shiftBins(shift);\n        }\n      }\n\n      this.maxKey = newMaxKey;\n      this.isCollapsed = true;\n    } else {\n      this._centerBins(newMinKey, newMaxKey);\n\n      this.minKey = newMinKey;\n      this.maxKey = newMaxKey;\n    }\n  };\n  /** Calculate the bin index for the key, extending the range if necessary */\n\n\n  CollapsingLowestDenseStore.prototype._getIndex = function (key) {\n    if (key < this.minKey) {\n      if (this.isCollapsed) {\n        return 0;\n      }\n\n      this._extendRange(key);\n\n      if (this.isCollapsed) {\n        return 0;\n      }\n    } else if (key > this.maxKey) {\n      this._extendRange(key);\n    }\n\n    return key - this.offset;\n  };\n\n  return CollapsingLowestDenseStore;\n}(DenseStore_1.DenseStore);\n\nexports.CollapsingLowestDenseStore = CollapsingLowestDenseStore;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","defineProperty","exports","value","CollapsingLowestDenseStore","DenseStore_1","require","util_1","_super","binLimit","chunkSize","_this","isCollapsed","merge","store","count","copy","minKey","maxKey","_extendRange","collapseStartIndex","offset","collapseEndIndex","Math","min","collapseCount","sumOfRange","bins","key","_getNewLength","newMinKey","newMaxKey","desiredLength","ceil","_adjust","length","fill","shift","collapsedCount","_shiftBins","_centerBins","_getIndex","DenseStore"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CollapsingLowestDenseStore = void 0;\nvar DenseStore_1 = require(\"./DenseStore\");\nvar util_1 = require(\"./util\");\n/**\n * `CollapsingLowestDenseStore` is a dense store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`, but collapsing the left-most bins\n * if the number of bins exceeds `binLimit`\n */\nvar CollapsingLowestDenseStore = /** @class */ (function (_super) {\n    __extends(CollapsingLowestDenseStore, _super);\n    /**\n     * Initialize a new CollapsingLowestDenseStore\n     *\n     * @param binLimit The maximum number of bins\n     * @param chunkSize The number of bins to add each time the bins grow (default 128)\n     */\n    function CollapsingLowestDenseStore(binLimit, chunkSize) {\n        var _this = _super.call(this, chunkSize) || this;\n        _this.binLimit = binLimit;\n        _this.isCollapsed = false;\n        return _this;\n    }\n    /**\n     * Merge the contents of the parameter `store` into this store\n     *\n     * @param store The store to merge into the caller store\n     */\n    CollapsingLowestDenseStore.prototype.merge = function (store) {\n        if (store.count === 0) {\n            return;\n        }\n        if (this.count === 0) {\n            this.copy(store);\n            return;\n        }\n        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n            this._extendRange(store.minKey, store.maxKey);\n        }\n        var collapseStartIndex = store.minKey - store.offset;\n        var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;\n        if (collapseEndIndex > collapseStartIndex) {\n            var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);\n            this.bins[0] += collapseCount;\n        }\n        else {\n            collapseEndIndex = collapseStartIndex;\n        }\n        for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {\n            this.bins[key - this.offset] += store.bins[key - store.offset];\n        }\n        this.count += store.count;\n    };\n    /**\n     * Directly clone the contents of the parameter `store` into this store\n     *\n     * @param store The store to be copied into the caller store\n     */\n    CollapsingLowestDenseStore.prototype.copy = function (store) {\n        _super.prototype.copy.call(this, store);\n        this.isCollapsed = store.isCollapsed;\n    };\n    CollapsingLowestDenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n        var desiredLength = newMaxKey - newMinKey + 1;\n        return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);\n    };\n    /**\n     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n     * without resizing the bins, in order to try to make it fit the specified range.\n     * Collapse to the left if necessary\n     */\n    CollapsingLowestDenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n        if (newMaxKey - newMinKey + 1 > this.length()) {\n            // The range of keys is too wide, the lowest bins need to be collapsed\n            newMinKey = newMaxKey - this.length() + 1;\n            if (newMinKey >= this.maxKey) {\n                // Put everything in the first bin\n                this.offset = newMinKey;\n                this.minKey = newMinKey;\n                this.bins.fill(0);\n                this.bins[0] = this.count;\n            }\n            else {\n                var shift = this.offset - newMinKey;\n                if (shift < 0) {\n                    var collapseStartIndex = this.minKey - this.offset;\n                    var collapseEndIndex = newMinKey - this.offset;\n                    var collapsedCount = util_1.sumOfRange(this.bins, collapseStartIndex, collapseEndIndex);\n                    this.bins.fill(0, collapseStartIndex, collapseEndIndex);\n                    this.bins[collapseEndIndex] += collapsedCount;\n                    this.minKey = newMinKey;\n                    this._shiftBins(shift);\n                }\n                else {\n                    this.minKey = newMinKey;\n                    // Shift the buckets to make room for newMinKey\n                    this._shiftBins(shift);\n                }\n            }\n            this.maxKey = newMaxKey;\n            this.isCollapsed = true;\n        }\n        else {\n            this._centerBins(newMinKey, newMaxKey);\n            this.minKey = newMinKey;\n            this.maxKey = newMaxKey;\n        }\n    };\n    /** Calculate the bin index for the key, extending the range if necessary */\n    CollapsingLowestDenseStore.prototype._getIndex = function (key) {\n        if (key < this.minKey) {\n            if (this.isCollapsed) {\n                return 0;\n            }\n            this._extendRange(key);\n            if (this.isCollapsed) {\n                return 0;\n            }\n        }\n        else if (key > this.maxKey) {\n            this._extendRange(key);\n        }\n        return key - this.offset;\n    };\n    return CollapsingLowestDenseStore;\n}(DenseStore_1.DenseStore));\nexports.CollapsingLowestDenseStore = CollapsingLowestDenseStore;\n"]},"metadata":{},"sourceType":"script"}