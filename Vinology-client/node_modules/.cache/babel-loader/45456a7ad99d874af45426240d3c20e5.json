{"ast":null,"code":"\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DenseStore = void 0;\n\nvar util_1 = require(\"./util\");\n\nvar compiled_1 = require(\"../proto/compiled\");\n/** The default number of bins to grow when necessary */\n\n\nvar CHUNK_SIZE = 128;\n/**\n * `DenseStore` is a store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`.\n */\n\nvar DenseStore =\n/** @class */\nfunction () {\n  /**\n   * Initialize a new DenseStore\n   *\n   * @param chunkSize The number of bins to add each time the bins grow (default 128)\n   */\n  function DenseStore(chunkSize) {\n    if (chunkSize === void 0) {\n      chunkSize = CHUNK_SIZE;\n    }\n\n    this.chunkSize = chunkSize;\n    this.bins = [];\n    this.count = 0;\n    this.minKey = Infinity;\n    this.maxKey = -Infinity;\n    this.offset = 0;\n  }\n  /**\n   * Update the counter at the specified index key, growing the number of bins if necessary\n   *\n   * @param key The key of the index to update\n   * @param weight The amount to weight the key (default 1.0)\n   */\n\n\n  DenseStore.prototype.add = function (key, weight) {\n    if (weight === void 0) {\n      weight = 1;\n    }\n\n    var index = this._getIndex(key);\n\n    this.bins[index] += weight;\n    this.count += weight;\n  };\n  /**\n   * Return the key for the value at the given rank\n   *\n   * E.g., if the non-zero bins are [1, 1] for keys a, b with no offset\n   *\n   * if lower = True:\n   *     keyAtRank(x) = a for x in [0, 1)\n   *     keyAtRank(x) = b for x in [1, 2)\n   * if lower = False:\n   *     keyAtRank(x) = a for x in (-1, 0]\n   *     keyAtRank(x) = b for x in (0, 1]\n   *\n   * @param rank The rank at which to retrieve the key\n   */\n\n\n  DenseStore.prototype.keyAtRank = function (rank, lower) {\n    if (lower === void 0) {\n      lower = true;\n    }\n\n    var runningCount = 0;\n\n    for (var i = 0; i < this.length(); i++) {\n      var bin = this.bins[i];\n      runningCount += bin;\n\n      if (lower && runningCount > rank || !lower && runningCount >= rank + 1) {\n        return i + this.offset;\n      }\n    }\n\n    return this.maxKey;\n  };\n  /**\n   * Merge the contents of the parameter `store` into this store\n   *\n   * @param store The store to merge into the caller store\n   */\n\n\n  DenseStore.prototype.merge = function (store) {\n    if (store.count === 0) {\n      return;\n    }\n\n    if (this.count === 0) {\n      this.copy(store);\n      return;\n    }\n\n    if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n      this._extendRange(store.minKey, store.maxKey);\n    }\n\n    var collapseStartIndex = store.minKey - store.offset;\n    var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;\n\n    if (collapseEndIndex > collapseStartIndex) {\n      var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);\n      this.bins[0] += collapseCount;\n    } else {\n      collapseEndIndex = collapseStartIndex;\n    }\n\n    for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {\n      this.bins[key - this.offset] += store.bins[key - store.offset];\n    }\n\n    this.count += store.count;\n  };\n  /**\n   * Directly clone the contents of the parameter `store` into this store\n   *\n   * @param store The store to be copied into the caller store\n   */\n\n\n  DenseStore.prototype.copy = function (store) {\n    this.bins = __spreadArray([], store.bins);\n    this.count = store.count;\n    this.minKey = store.minKey;\n    this.maxKey = store.maxKey;\n    this.offset = store.offset;\n  };\n  /**\n   * Return the length of the underlying storage (`bins`)\n   */\n\n\n  DenseStore.prototype.length = function () {\n    return this.bins.length;\n  };\n\n  DenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n    var desiredLength = newMaxKey - newMinKey + 1;\n    return this.chunkSize * Math.ceil(desiredLength / this.chunkSize);\n  };\n  /**\n   * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n   * without resizing the bins, in order to try to make it fit the specified range.\n   * Collapse to the left if necessary\n   */\n\n\n  DenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n    this._centerBins(newMinKey, newMaxKey);\n\n    this.minKey = newMinKey;\n    this.maxKey = newMaxKey;\n  };\n  /** Shift the bins by `shift`. This changes the `offset` */\n\n\n  DenseStore.prototype._shiftBins = function (shift) {\n    var _a, _b;\n\n    if (shift > 0) {\n      this.bins = this.bins.slice(0, -shift);\n\n      (_a = this.bins).unshift.apply(_a, new Array(shift).fill(0));\n    } else {\n      this.bins = this.bins.slice(Math.abs(shift));\n\n      (_b = this.bins).push.apply(_b, new Array(Math.abs(shift)).fill(0));\n    }\n\n    this.offset -= shift;\n  };\n  /** Center the bins. This changes the `offset` */\n\n\n  DenseStore.prototype._centerBins = function (newMinKey, newMaxKey) {\n    var middleKey = newMinKey + Math.floor((newMaxKey - newMinKey + 1) / 2);\n\n    this._shiftBins(Math.floor(this.offset + this.length() / 2) - middleKey);\n  };\n  /** Grow the bins as necessary, and call _adjust */\n\n\n  DenseStore.prototype._extendRange = function (key, secondKey) {\n    var _a;\n\n    secondKey = secondKey || key;\n    var newMinKey = Math.min(key, secondKey, this.minKey);\n    var newMaxKey = Math.max(key, secondKey, this.maxKey);\n\n    if (this.length() === 0) {\n      this.bins = new Array(this._getNewLength(newMinKey, newMaxKey)).fill(0);\n      this.offset = newMinKey;\n\n      this._adjust(newMinKey, newMaxKey);\n    } else if (newMinKey >= this.minKey && newMaxKey < this.offset + this.length()) {\n      // No need to change the range, just update the min and max keys\n      this.minKey = newMinKey;\n      this.maxKey = newMaxKey;\n    } else {\n      // Grow the bins\n      var newLength = this._getNewLength(newMinKey, newMaxKey);\n\n      if (newLength > this.length()) {\n        (_a = this.bins).push.apply(_a, new Array(newLength - this.length()).fill(0));\n      }\n\n      this._adjust(newMinKey, newMaxKey);\n    }\n  };\n  /** Calculate the bin index for the key, extending the range if necessary */\n\n\n  DenseStore.prototype._getIndex = function (key) {\n    if (key < this.minKey) {\n      this._extendRange(key);\n    } else if (key > this.maxKey) {\n      this._extendRange(key);\n    }\n\n    return key - this.offset;\n  };\n\n  DenseStore.prototype.toProto = function () {\n    return compiled_1.Store.create({\n      contiguousBinCounts: this.bins,\n      contiguousBinIndexOffset: this.offset\n    });\n  };\n\n  DenseStore.fromProto = function (protoStore) {\n    if (!protoStore ||\n    /* Double equals (==) is intentional here to check for\n     * `null` | `undefined` without including `0` */\n    protoStore.contiguousBinCounts == null || protoStore.contiguousBinIndexOffset == null) {\n      throw Error('Failed to decode store from protobuf');\n    }\n\n    var store = new this();\n    var index = protoStore.contiguousBinIndexOffset;\n    store.offset = index;\n\n    for (var _i = 0, _a = protoStore.contiguousBinCounts; _i < _a.length; _i++) {\n      var count = _a[_i];\n      store.add(index, count);\n      index += 1;\n    }\n\n    return store;\n  };\n\n  return DenseStore;\n}();\n\nexports.DenseStore = DenseStore;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js"],"names":["__spreadArray","to","from","i","il","length","j","Object","defineProperty","exports","value","DenseStore","util_1","require","compiled_1","CHUNK_SIZE","chunkSize","bins","count","minKey","Infinity","maxKey","offset","prototype","add","key","weight","index","_getIndex","keyAtRank","rank","lower","runningCount","bin","merge","store","copy","_extendRange","collapseStartIndex","collapseEndIndex","Math","min","collapseCount","sumOfRange","_getNewLength","newMinKey","newMaxKey","desiredLength","ceil","_adjust","_centerBins","_shiftBins","shift","_a","_b","slice","unshift","apply","Array","fill","abs","push","middleKey","floor","secondKey","max","newLength","toProto","Store","create","contiguousBinCounts","contiguousBinIndexOffset","fromProto","protoStore","Error","_i"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DenseStore = void 0;\nvar util_1 = require(\"./util\");\nvar compiled_1 = require(\"../proto/compiled\");\n/** The default number of bins to grow when necessary */\nvar CHUNK_SIZE = 128;\n/**\n * `DenseStore` is a store that keeps all the bins between\n * the bin for the `minKey` and the `maxKey`.\n */\nvar DenseStore = /** @class */ (function () {\n    /**\n     * Initialize a new DenseStore\n     *\n     * @param chunkSize The number of bins to add each time the bins grow (default 128)\n     */\n    function DenseStore(chunkSize) {\n        if (chunkSize === void 0) { chunkSize = CHUNK_SIZE; }\n        this.chunkSize = chunkSize;\n        this.bins = [];\n        this.count = 0;\n        this.minKey = Infinity;\n        this.maxKey = -Infinity;\n        this.offset = 0;\n    }\n    /**\n     * Update the counter at the specified index key, growing the number of bins if necessary\n     *\n     * @param key The key of the index to update\n     * @param weight The amount to weight the key (default 1.0)\n     */\n    DenseStore.prototype.add = function (key, weight) {\n        if (weight === void 0) { weight = 1; }\n        var index = this._getIndex(key);\n        this.bins[index] += weight;\n        this.count += weight;\n    };\n    /**\n     * Return the key for the value at the given rank\n     *\n     * E.g., if the non-zero bins are [1, 1] for keys a, b with no offset\n     *\n     * if lower = True:\n     *     keyAtRank(x) = a for x in [0, 1)\n     *     keyAtRank(x) = b for x in [1, 2)\n     * if lower = False:\n     *     keyAtRank(x) = a for x in (-1, 0]\n     *     keyAtRank(x) = b for x in (0, 1]\n     *\n     * @param rank The rank at which to retrieve the key\n     */\n    DenseStore.prototype.keyAtRank = function (rank, lower) {\n        if (lower === void 0) { lower = true; }\n        var runningCount = 0;\n        for (var i = 0; i < this.length(); i++) {\n            var bin = this.bins[i];\n            runningCount += bin;\n            if ((lower && runningCount > rank) ||\n                (!lower && runningCount >= rank + 1)) {\n                return i + this.offset;\n            }\n        }\n        return this.maxKey;\n    };\n    /**\n     * Merge the contents of the parameter `store` into this store\n     *\n     * @param store The store to merge into the caller store\n     */\n    DenseStore.prototype.merge = function (store) {\n        if (store.count === 0) {\n            return;\n        }\n        if (this.count === 0) {\n            this.copy(store);\n            return;\n        }\n        if (store.minKey < this.minKey || store.maxKey > this.maxKey) {\n            this._extendRange(store.minKey, store.maxKey);\n        }\n        var collapseStartIndex = store.minKey - store.offset;\n        var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;\n        if (collapseEndIndex > collapseStartIndex) {\n            var collapseCount = util_1.sumOfRange(store.bins, collapseStartIndex, collapseEndIndex);\n            this.bins[0] += collapseCount;\n        }\n        else {\n            collapseEndIndex = collapseStartIndex;\n        }\n        for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {\n            this.bins[key - this.offset] += store.bins[key - store.offset];\n        }\n        this.count += store.count;\n    };\n    /**\n     * Directly clone the contents of the parameter `store` into this store\n     *\n     * @param store The store to be copied into the caller store\n     */\n    DenseStore.prototype.copy = function (store) {\n        this.bins = __spreadArray([], store.bins);\n        this.count = store.count;\n        this.minKey = store.minKey;\n        this.maxKey = store.maxKey;\n        this.offset = store.offset;\n    };\n    /**\n     * Return the length of the underlying storage (`bins`)\n     */\n    DenseStore.prototype.length = function () {\n        return this.bins.length;\n    };\n    DenseStore.prototype._getNewLength = function (newMinKey, newMaxKey) {\n        var desiredLength = newMaxKey - newMinKey + 1;\n        return this.chunkSize * Math.ceil(desiredLength / this.chunkSize);\n    };\n    /**\n     * Adjust the `bins`, the `offset`, the `minKey`, and the `maxKey`\n     * without resizing the bins, in order to try to make it fit the specified range.\n     * Collapse to the left if necessary\n     */\n    DenseStore.prototype._adjust = function (newMinKey, newMaxKey) {\n        this._centerBins(newMinKey, newMaxKey);\n        this.minKey = newMinKey;\n        this.maxKey = newMaxKey;\n    };\n    /** Shift the bins by `shift`. This changes the `offset` */\n    DenseStore.prototype._shiftBins = function (shift) {\n        var _a, _b;\n        if (shift > 0) {\n            this.bins = this.bins.slice(0, -shift);\n            (_a = this.bins).unshift.apply(_a, new Array(shift).fill(0));\n        }\n        else {\n            this.bins = this.bins.slice(Math.abs(shift));\n            (_b = this.bins).push.apply(_b, new Array(Math.abs(shift)).fill(0));\n        }\n        this.offset -= shift;\n    };\n    /** Center the bins. This changes the `offset` */\n    DenseStore.prototype._centerBins = function (newMinKey, newMaxKey) {\n        var middleKey = newMinKey + Math.floor((newMaxKey - newMinKey + 1) / 2);\n        this._shiftBins(Math.floor(this.offset + this.length() / 2) - middleKey);\n    };\n    /** Grow the bins as necessary, and call _adjust */\n    DenseStore.prototype._extendRange = function (key, secondKey) {\n        var _a;\n        secondKey = secondKey || key;\n        var newMinKey = Math.min(key, secondKey, this.minKey);\n        var newMaxKey = Math.max(key, secondKey, this.maxKey);\n        if (this.length() === 0) {\n            this.bins = new Array(this._getNewLength(newMinKey, newMaxKey)).fill(0);\n            this.offset = newMinKey;\n            this._adjust(newMinKey, newMaxKey);\n        }\n        else if (newMinKey >= this.minKey &&\n            newMaxKey < this.offset + this.length()) {\n            // No need to change the range, just update the min and max keys\n            this.minKey = newMinKey;\n            this.maxKey = newMaxKey;\n        }\n        else {\n            // Grow the bins\n            var newLength = this._getNewLength(newMinKey, newMaxKey);\n            if (newLength > this.length()) {\n                (_a = this.bins).push.apply(_a, new Array(newLength - this.length()).fill(0));\n            }\n            this._adjust(newMinKey, newMaxKey);\n        }\n    };\n    /** Calculate the bin index for the key, extending the range if necessary */\n    DenseStore.prototype._getIndex = function (key) {\n        if (key < this.minKey) {\n            this._extendRange(key);\n        }\n        else if (key > this.maxKey) {\n            this._extendRange(key);\n        }\n        return key - this.offset;\n    };\n    DenseStore.prototype.toProto = function () {\n        return compiled_1.Store.create({\n            contiguousBinCounts: this.bins,\n            contiguousBinIndexOffset: this.offset\n        });\n    };\n    DenseStore.fromProto = function (protoStore) {\n        if (!protoStore ||\n            /* Double equals (==) is intentional here to check for\n             * `null` | `undefined` without including `0` */\n            protoStore.contiguousBinCounts == null ||\n            protoStore.contiguousBinIndexOffset == null) {\n            throw Error('Failed to decode store from protobuf');\n        }\n        var store = new this();\n        var index = protoStore.contiguousBinIndexOffset;\n        store.offset = index;\n        for (var _i = 0, _a = protoStore.contiguousBinCounts; _i < _a.length; _i++) {\n            var count = _a[_i];\n            store.add(index, count);\n            index += 1;\n        }\n        return store;\n    };\n    return DenseStore;\n}());\nexports.DenseStore = DenseStore;\n"]},"metadata":{},"sourceType":"script"}