{"ast":null,"code":"'use strict';\n\nconst {\n  randomFillSync\n} = require('crypto');\n\nconst UINT_MAX = 4294967296;\nconst data = new Uint8Array(8 * 8192);\nconst zeroId = new Uint8Array(8);\nconst map = Array.prototype.map;\n\nconst pad = byte => `${byte < 16 ? '0' : ''}${byte.toString(16)}`;\n\nlet batch = 0; // Internal representation of a trace or span ID.\n\nclass Identifier {\n  constructor(value, radix) {\n    this._isUint64BE = true; // msgpack-lite compatibility\n\n    this._buffer = typeof radix === 'number' ? fromString(value, radix) : createBuffer(value);\n  }\n\n  toString(radix) {\n    return typeof radix === 'number' ? toNumberString(this._buffer, radix) : toHexString(this._buffer);\n  }\n\n  toBuffer() {\n    return this._buffer;\n  } // msgpack-lite compatibility\n\n\n  toArray() {\n    if (this._buffer.length === 8) {\n      return this._buffer;\n    }\n\n    return this._buffer.slice(-8);\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n} // Create a buffer, using an optional hexadecimal value if provided.\n\n\nfunction createBuffer(value) {\n  if (value === '0') return zeroId;\n  if (!value) return pseudoRandom();\n  const size = Math.ceil(value.length / 2);\n  const buffer = new Array(size);\n\n  for (let i = 0; i < size; i++) {\n    buffer[i] = parseInt(value.substring(i * 2, i * 2 + 2), 16);\n  }\n\n  return buffer;\n} // Convert a numerical string to a buffer using the specified radix.\n\n\nfunction fromString(str, raddix) {\n  const buffer = new Array(8);\n  const len = str.length;\n  let pos = 0;\n  let high = 0;\n  let low = 0;\n  if (str[0] === '-') pos++;\n  const sign = pos;\n\n  while (pos < len) {\n    const chr = parseInt(str[pos++], raddix);\n    if (!(chr >= 0)) break; // NaN\n\n    low = low * raddix + chr;\n    high = high * raddix + Math.floor(low / UINT_MAX);\n    low %= UINT_MAX;\n  }\n\n  if (sign) {\n    high = ~high;\n\n    if (low) {\n      low = UINT_MAX - low;\n    } else {\n      high++;\n    }\n  }\n\n  writeUInt32BE(buffer, high, 0);\n  writeUInt32BE(buffer, low, 4);\n  return buffer;\n} // Convert a buffer to a numerical string.\n\n\nfunction toNumberString(buffer, radix) {\n  let high = readInt32(buffer, 0);\n  let low = readInt32(buffer, 4);\n  let str = '';\n  radix = radix || 10;\n\n  while (1) {\n    const mod = high % radix * UINT_MAX + low;\n    high = Math.floor(high / radix);\n    low = Math.floor(mod / radix);\n    str = (mod % radix).toString(radix) + str;\n    if (!high && !low) break;\n  }\n\n  return str;\n} // Convert a buffer to a hexadecimal string.\n\n\nfunction toHexString(buffer) {\n  return map.call(buffer, pad).join('');\n} // Simple pseudo-random 64-bit ID generator.\n\n\nfunction pseudoRandom() {\n  if (batch === 0) {\n    randomFillSync(data);\n  }\n\n  batch = (batch + 1) % 8192;\n  const offset = batch * 8;\n  return [data[offset] & 0x7F, // only positive int64,\n  data[offset + 1], data[offset + 2], data[offset + 3], data[offset + 4], data[offset + 5], data[offset + 6], data[offset + 7]];\n} // Read a buffer to unsigned integer bytes.\n\n\nfunction readInt32(buffer, offset) {\n  return buffer[offset + 0] * 16777216 + (buffer[offset + 1] << 16) + (buffer[offset + 2] << 8) + buffer[offset + 3];\n} // Write unsigned integer bytes to a buffer.\n\n\nfunction writeUInt32BE(buffer, value, offset) {\n  buffer[3 + offset] = value & 255;\n  value = value >> 8;\n  buffer[2 + offset] = value & 255;\n  value = value >> 8;\n  buffer[1 + offset] = value & 255;\n  value = value >> 8;\n  buffer[0 + offset] = value & 255;\n}\n\nmodule.exports = (value, radix) => new Identifier(value, radix);","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/id.js"],"names":["randomFillSync","require","UINT_MAX","data","Uint8Array","zeroId","map","Array","prototype","pad","byte","toString","batch","Identifier","constructor","value","radix","_isUint64BE","_buffer","fromString","createBuffer","toNumberString","toHexString","toBuffer","toArray","length","slice","toJSON","pseudoRandom","size","Math","ceil","buffer","i","parseInt","substring","str","raddix","len","pos","high","low","sign","chr","floor","writeUInt32BE","readInt32","mod","call","join","offset","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { randomFillSync } = require('crypto')\n\nconst UINT_MAX = 4294967296\n\nconst data = new Uint8Array(8 * 8192)\nconst zeroId = new Uint8Array(8)\n\nconst map = Array.prototype.map\nconst pad = byte => `${byte < 16 ? '0' : ''}${byte.toString(16)}`\n\nlet batch = 0\n\n// Internal representation of a trace or span ID.\nclass Identifier {\n  constructor (value, radix) {\n    this._isUint64BE = true // msgpack-lite compatibility\n    this._buffer = typeof radix === 'number'\n      ? fromString(value, radix)\n      : createBuffer(value)\n  }\n\n  toString (radix) {\n    return typeof radix === 'number'\n      ? toNumberString(this._buffer, radix)\n      : toHexString(this._buffer)\n  }\n\n  toBuffer () {\n    return this._buffer\n  }\n\n  // msgpack-lite compatibility\n  toArray () {\n    if (this._buffer.length === 8) {\n      return this._buffer\n    }\n    return this._buffer.slice(-8)\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n}\n\n// Create a buffer, using an optional hexadecimal value if provided.\nfunction createBuffer (value) {\n  if (value === '0') return zeroId\n  if (!value) return pseudoRandom()\n\n  const size = Math.ceil(value.length / 2)\n  const buffer = new Array(size)\n\n  for (let i = 0; i < size; i++) {\n    buffer[i] = parseInt(value.substring(i * 2, i * 2 + 2), 16)\n  }\n\n  return buffer\n}\n\n// Convert a numerical string to a buffer using the specified radix.\nfunction fromString (str, raddix) {\n  const buffer = new Array(8)\n  const len = str.length\n\n  let pos = 0\n  let high = 0\n  let low = 0\n\n  if (str[0] === '-') pos++\n\n  const sign = pos\n\n  while (pos < len) {\n    const chr = parseInt(str[pos++], raddix)\n\n    if (!(chr >= 0)) break // NaN\n\n    low = low * raddix + chr\n    high = high * raddix + Math.floor(low / UINT_MAX)\n    low %= UINT_MAX\n  }\n\n  if (sign) {\n    high = ~high\n\n    if (low) {\n      low = UINT_MAX - low\n    } else {\n      high++\n    }\n  }\n\n  writeUInt32BE(buffer, high, 0)\n  writeUInt32BE(buffer, low, 4)\n\n  return buffer\n}\n\n// Convert a buffer to a numerical string.\nfunction toNumberString (buffer, radix) {\n  let high = readInt32(buffer, 0)\n  let low = readInt32(buffer, 4)\n  let str = ''\n\n  radix = radix || 10\n\n  while (1) {\n    const mod = (high % radix) * UINT_MAX + low\n\n    high = Math.floor(high / radix)\n    low = Math.floor(mod / radix)\n    str = (mod % radix).toString(radix) + str\n\n    if (!high && !low) break\n  }\n\n  return str\n}\n\n// Convert a buffer to a hexadecimal string.\nfunction toHexString (buffer) {\n  return map.call(buffer, pad).join('')\n}\n\n// Simple pseudo-random 64-bit ID generator.\nfunction pseudoRandom () {\n  if (batch === 0) {\n    randomFillSync(data)\n  }\n\n  batch = (batch + 1) % 8192\n\n  const offset = batch * 8\n\n  return [\n    data[offset] & 0x7F, // only positive int64,\n    data[offset + 1],\n    data[offset + 2],\n    data[offset + 3],\n    data[offset + 4],\n    data[offset + 5],\n    data[offset + 6],\n    data[offset + 7]\n  ]\n}\n\n// Read a buffer to unsigned integer bytes.\nfunction readInt32 (buffer, offset) {\n  return (buffer[offset + 0] * 16777216) +\n    (buffer[offset + 1] << 16) +\n    (buffer[offset + 2] << 8) +\n    buffer[offset + 3]\n}\n\n// Write unsigned integer bytes to a buffer.\nfunction writeUInt32BE (buffer, value, offset) {\n  buffer[3 + offset] = value & 255\n  value = value >> 8\n  buffer[2 + offset] = value & 255\n  value = value >> 8\n  buffer[1 + offset] = value & 255\n  value = value >> 8\n  buffer[0 + offset] = value & 255\n}\n\nmodule.exports = (value, radix) => new Identifier(value, radix)\n"]},"metadata":{},"sourceType":"script"}