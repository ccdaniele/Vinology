{"ast":null,"code":"'use strict';\n\nconst pick = require('lodash.pick');\n\nconst log = require('../../dd-trace/src/log');\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler');\n\nlet tools;\n\nfunction createWrapExecute(tracer, config, defaultFieldResolver) {\n  return function wrapExecute(execute) {\n    return function executeWithTrace() {\n      const args = normalizeArgs(arguments, tracer, config, defaultFieldResolver);\n      const schema = args.schema;\n      const document = args.document;\n      const source = document && document._datadog_source;\n      const contextValue = args.contextValue;\n      const operation = getOperation(document, args.operationName);\n\n      if (contextValue._datadog_graphql) {\n        return execute.apply(this, arguments);\n      }\n\n      if (schema) {\n        wrapFields(schema._queryType, tracer, config);\n        wrapFields(schema._mutationType, tracer, config);\n      }\n\n      const span = startExecutionSpan(tracer, config, operation, args);\n      contextValue._datadog_graphql = {\n        source,\n        span,\n        fields: {}\n      };\n      return call(execute, span, this, arguments, (err, res) => {\n        finishResolvers(contextValue, config);\n        setError(span, err || res && res.errors && res.errors[0]);\n        config.hooks.execute(span, args, res);\n        finish(span);\n      });\n    };\n  };\n}\n\nfunction createWrapParse(tracer, config) {\n  return function wrapParse(parse) {\n    return function parseWithTrace(source) {\n      const span = startSpan(tracer, config, 'parse');\n      analyticsSampler.sample(span, config.measured, true);\n      let document;\n\n      try {\n        document = parse.apply(this, arguments);\n        const operation = getOperation(document);\n        if (!operation) return document; // skip schema parsing\n\n        if (source) {\n          document._datadog_source = source.body || source;\n        }\n\n        addDocumentTags(span, document, config);\n        return document;\n      } catch (e) {\n        setError(span, e);\n        throw e;\n      } finally {\n        config.hooks.parse(span, source, document);\n        finish(span);\n      }\n    };\n  };\n}\n\nfunction createWrapValidate(tracer, config) {\n  return function wrapValidate(validate) {\n    return function validateWithTrace(schema, document, rules, typeInfo) {\n      const span = startSpan(tracer, config, 'validate');\n      analyticsSampler.sample(span, config.measured, true); // skip for schema stitching nested validation\n\n      if (document && document.loc) {\n        addDocumentTags(span, document, config);\n      }\n\n      let errors;\n\n      try {\n        errors = validate.apply(this, arguments);\n        setError(span, errors && errors[0]);\n        return errors;\n      } catch (e) {\n        setError(span, e);\n        throw e;\n      } finally {\n        config.hooks.validate(span, document, errors);\n        finish(span);\n      }\n    };\n  };\n}\n\nfunction wrapFields(type, tracer, config) {\n  if (!type || !type._fields || type._datadog_patched) {\n    return;\n  }\n\n  type._datadog_patched = true;\n  Object.keys(type._fields).forEach(key => {\n    const field = type._fields[key];\n    wrapFieldResolve(field, tracer, config);\n    wrapFieldType(field, tracer, config);\n  });\n}\n\nfunction wrapFieldResolve(field, tracer, config) {\n  if (!field || !field.resolve) return;\n  field.resolve = wrapResolve(field.resolve, tracer, config);\n}\n\nfunction wrapFieldType(field, tracer, config) {\n  if (!field || !field.type) return;\n  let unwrappedType = field.type;\n\n  while (unwrappedType.ofType) {\n    unwrappedType = unwrappedType.ofType;\n  }\n\n  wrapFields(unwrappedType, tracer, config);\n}\n\nfunction wrapResolve(resolve, tracer, config) {\n  if (resolve._datadog_patched || typeof resolve !== 'function') return resolve;\n  const responsePathAsArray = config.collapse ? withCollapse(pathToArray) : pathToArray;\n\n  function resolveWithTrace(source, args, contextValue, info) {\n    if (!contextValue._datadog_graphql) return resolve.apply(this, arguments);\n    const path = responsePathAsArray(info && info.path);\n\n    if (config.depth >= 0) {\n      const depth = path.filter(item => typeof item === 'string').length;\n\n      if (config.depth < depth) {\n        const parent = getParentField(tracer, contextValue, path);\n        return call(resolve, parent.span, this, arguments);\n      }\n    }\n\n    const field = assertField(tracer, config, contextValue, info, path);\n    return call(resolve, field.span, this, arguments, err => updateField(field, err));\n  }\n\n  resolveWithTrace._datadog_patched = true;\n  return resolveWithTrace;\n}\n\nfunction call(fn, span, thisArg, args, callback) {\n  const scope = span.tracer().scope();\n\n  callback = callback || (() => {});\n\n  try {\n    const result = scope.activate(span, () => fn.apply(thisArg, args));\n\n    if (result && typeof result.then === 'function') {\n      result.then(res => callback(null, res), err => callback(err));\n    } else {\n      callback(null, result);\n    }\n\n    return result;\n  } catch (e) {\n    callback(e);\n    throw e;\n  }\n}\n\nfunction getParentField(tracer, contextValue, path) {\n  for (let i = path.length - 1; i > 0; i--) {\n    const field = getField(contextValue, path.slice(0, i));\n\n    if (field) {\n      return field;\n    }\n  }\n\n  return {\n    span: contextValue._datadog_graphql.span\n  };\n}\n\nfunction getField(contextValue, path) {\n  return contextValue._datadog_graphql.fields[path.join('.')];\n}\n\nfunction normalizeArgs(args, tracer, config, defaultFieldResolver) {\n  if (args.length !== 1) return normalizePositional(args, tracer, config, defaultFieldResolver);\n  args[0].contextValue = args[0].contextValue || {};\n  args[0].fieldResolver = wrapResolve(args[0].fieldResolver || defaultFieldResolver, tracer, config);\n  return args[0];\n}\n\nfunction normalizePositional(args, tracer, config, defaultFieldResolver) {\n  args[3] = args[3] || {}; // contextValue\n\n  args[6] = wrapResolve(args[6] || defaultFieldResolver, tracer, config); // fieldResolver\n\n  args.length = Math.max(args.length, 7);\n  return {\n    schema: args[0],\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    fieldResolver: args[6]\n  };\n}\n\nfunction startExecutionSpan(tracer, config, operation, args) {\n  const span = startSpan(tracer, config, 'execute');\n  addExecutionTags(span, config, operation, args.document, args.operationName);\n  addDocumentTags(span, args.document, config);\n  addVariableTags(tracer, config, span, args.variableValues);\n  analyticsSampler.sample(span, config.measured, true);\n  return span;\n}\n\nfunction addExecutionTags(span, config, operation, document, operationName) {\n  const type = operation && operation.operation;\n  const name = operation && operation.name && operation.name.value;\n  const tags = {\n    'resource.name': getSignature(document, name, type, config.signature)\n  };\n\n  if (type) {\n    tags['graphql.operation.type'] = type;\n  }\n\n  if (name) {\n    tags['graphql.operation.name'] = name;\n  }\n\n  span.addTags(tags);\n}\n\nfunction addDocumentTags(span, document, config) {\n  const tags = {};\n\n  if (config.source && document && document._datadog_source) {\n    tags['graphql.source'] = document._datadog_source;\n  }\n\n  span.addTags(tags);\n}\n\nfunction addVariableTags(tracer, config, span, variableValues) {\n  const tags = {};\n\n  if (variableValues && config.variables) {\n    const variables = config.variables(variableValues);\n\n    for (const param in variables) {\n      tags[`graphql.variables.${param}`] = variables[param];\n    }\n  }\n\n  span.addTags(tags);\n}\n\nfunction startSpan(tracer, config, name, options) {\n  options = options || {};\n  return tracer.startSpan(`graphql.${name}`, {\n    childOf: options.childOf || tracer.scope().active(),\n    startTime: options.startTime,\n    tags: {\n      'service.name': getService(tracer, config),\n      'span.type': 'graphql'\n    }\n  });\n}\n\nfunction startResolveSpan(tracer, config, childOf, path, info, contextValue) {\n  const span = startSpan(tracer, config, 'resolve', {\n    childOf\n  });\n  const document = contextValue._datadog_graphql.source;\n  const fieldNode = info.fieldNodes.find(fieldNode => fieldNode.kind === 'Field');\n  analyticsSampler.sample(span, config.measured);\n  span.addTags({\n    'resource.name': `${info.fieldName}:${info.returnType}`,\n    'graphql.field.name': info.fieldName,\n    'graphql.field.path': path.join('.'),\n    'graphql.field.type': info.returnType.name\n  });\n\n  if (fieldNode) {\n    if (config.source && document && fieldNode.loc) {\n      span.setTag('graphql.source', document.substring(fieldNode.loc.start, fieldNode.loc.end));\n    }\n\n    if (config.variables && fieldNode.arguments) {\n      const variables = config.variables(info.variableValues);\n      fieldNode.arguments.filter(arg => arg.value && arg.value.kind === 'Variable').filter(arg => arg.value.name && variables[arg.value.name.value]).map(arg => arg.value.name.value).forEach(name => {\n        span.setTag(`graphql.variables.${name}`, variables[name]);\n      });\n    }\n  }\n\n  return span;\n}\n\nfunction setError(span, error) {\n  if (error) {\n    span.setTag('error', error);\n  }\n}\n\nfunction finish(span, finishTime) {\n  span.finish(finishTime);\n}\n\nfunction finishResolvers(contextValue) {\n  const fields = contextValue._datadog_graphql.fields;\n  Object.keys(fields).reverse().forEach(key => {\n    const field = fields[key];\n    setError(field.span, field.error);\n    finish(field.span, field.finishTime);\n  });\n}\n\nfunction updateField(field, error) {\n  // TODO: update this to also work with no-op spans without a hack\n  field.finishTime = field.span._getTime ? field.span._getTime() : 0;\n  field.error = field.error || error;\n}\n\nfunction withCollapse(responsePathAsArray) {\n  return function () {\n    return responsePathAsArray.apply(this, arguments).map(segment => typeof segment === 'number' ? '*' : segment);\n  };\n}\n\nfunction assertField(tracer, config, contextValue, info, path) {\n  const pathString = path.join('.');\n  const fields = contextValue._datadog_graphql.fields;\n  let field = fields[pathString];\n\n  if (!field) {\n    const parent = getParentField(tracer, contextValue, path);\n    field = fields[pathString] = {\n      parent,\n      span: startResolveSpan(tracer, config, parent.span, path, info, contextValue),\n      error: null\n    };\n  }\n\n  return field;\n}\n\nfunction getService(tracer, config) {\n  return config.service || tracer._service;\n}\n\nfunction getOperation(document, operationName) {\n  if (!document || !Array.isArray(document.definitions)) {\n    return;\n  }\n\n  const definitions = document.definitions.filter(def => def);\n  const types = ['query', 'mutation', 'subscription'];\n\n  if (operationName) {\n    return definitions.filter(def => types.indexOf(def.operation) !== -1).find(def => operationName === (def.name && def.name.value));\n  } else {\n    return definitions.find(def => types.indexOf(def.operation) !== -1);\n  }\n}\n\nfunction validateConfig(config) {\n  return Object.assign({}, config, {\n    depth: getDepth(config),\n    variables: getVariablesFilter(config),\n    collapse: config.collapse === undefined || !!config.collapse,\n    hooks: getHooks(config)\n  });\n}\n\nfunction getDepth(config) {\n  if (typeof config.depth === 'number') {\n    return config.depth;\n  } else if (config.hasOwnProperty('depth')) {\n    log.error('Expected `depth` to be a integer.');\n  }\n\n  return -1;\n}\n\nfunction getVariablesFilter(config) {\n  if (typeof config.variables === 'function') {\n    return config.variables;\n  } else if (config.variables instanceof Array) {\n    return variables => pick(variables, config.variables);\n  } else if (config.hasOwnProperty('variables')) {\n    log.error('Expected `variables` to be an array or function.');\n  }\n\n  return null;\n}\n\nfunction getSignature(document, operationName, operationType, calculate) {\n  if (calculate !== false && tools !== false) {\n    try {\n      try {\n        tools = tools || require('./tools');\n      } catch (e) {\n        tools = false;\n        throw e;\n      }\n\n      return tools.defaultEngineReportingSignature(document, operationName);\n    } catch (e) {// safety net\n    }\n  }\n\n  return [operationType, operationName].filter(val => val).join(' ');\n}\n\nfunction pathToArray(path) {\n  const flattened = [];\n  let curr = path;\n\n  while (curr) {\n    flattened.push(curr.key);\n    curr = curr.prev;\n  }\n\n  return flattened.reverse();\n}\n\nfunction getHooks(config) {\n  const noop = () => {};\n\n  const execute = config.hooks && config.hooks.execute || noop;\n  const parse = config.hooks && config.hooks.parse || noop;\n  const validate = config.hooks && config.hooks.validate || noop;\n  return {\n    execute,\n    parse,\n    validate\n  };\n}\n\nmodule.exports = [{\n  name: 'graphql',\n  file: 'execution/execute.js',\n  versions: ['>=0.10'],\n\n  patch(execute, tracer, config) {\n    this.wrap(execute, 'execute', createWrapExecute(tracer, validateConfig(config), execute.defaultFieldResolver));\n  },\n\n  unpatch(execute) {\n    this.unwrap(execute, 'execute');\n  }\n\n}, {\n  name: 'graphql',\n  file: 'language/parser.js',\n  versions: ['>=0.10'],\n\n  patch(parser, tracer, config) {\n    this.wrap(parser, 'parse', createWrapParse(tracer, validateConfig(config)));\n  },\n\n  unpatch(parser) {\n    this.unwrap(parser, 'parse');\n  }\n\n}, {\n  name: 'graphql',\n  file: 'validation/validate.js',\n  versions: ['>=0.10'],\n\n  patch(validate, tracer, config) {\n    this.wrap(validate, 'validate', createWrapValidate(tracer, validateConfig(config)));\n  },\n\n  unpatch(validate) {\n    this.unwrap(validate, 'validate');\n  }\n\n}];","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-graphql/src/index.js"],"names":["pick","require","log","analyticsSampler","tools","createWrapExecute","tracer","config","defaultFieldResolver","wrapExecute","execute","executeWithTrace","args","normalizeArgs","arguments","schema","document","source","_datadog_source","contextValue","operation","getOperation","operationName","_datadog_graphql","apply","wrapFields","_queryType","_mutationType","span","startExecutionSpan","fields","call","err","res","finishResolvers","setError","errors","hooks","finish","createWrapParse","wrapParse","parse","parseWithTrace","startSpan","sample","measured","body","addDocumentTags","e","createWrapValidate","wrapValidate","validate","validateWithTrace","rules","typeInfo","loc","type","_fields","_datadog_patched","Object","keys","forEach","key","field","wrapFieldResolve","wrapFieldType","resolve","wrapResolve","unwrappedType","ofType","responsePathAsArray","collapse","withCollapse","pathToArray","resolveWithTrace","info","path","depth","filter","item","length","parent","getParentField","assertField","updateField","fn","thisArg","callback","scope","result","activate","then","i","getField","slice","join","normalizePositional","fieldResolver","Math","max","rootValue","variableValues","addExecutionTags","addVariableTags","name","value","tags","getSignature","signature","addTags","variables","param","options","childOf","active","startTime","getService","startResolveSpan","fieldNode","fieldNodes","find","kind","fieldName","returnType","setTag","substring","start","end","arg","map","error","finishTime","reverse","_getTime","segment","pathString","service","_service","Array","isArray","definitions","def","types","indexOf","validateConfig","assign","getDepth","getVariablesFilter","undefined","getHooks","hasOwnProperty","operationType","calculate","defaultEngineReportingSignature","val","flattened","curr","push","prev","noop","module","exports","file","versions","patch","wrap","unpatch","unwrap","parser"],"mappings":"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","sourcesContent":["'use strict'\n\nconst pick = require('lodash.pick')\nconst log = require('../../dd-trace/src/log')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nlet tools\n\nfunction createWrapExecute (tracer, config, defaultFieldResolver) {\n  return function wrapExecute (execute) {\n    return function executeWithTrace () {\n      const args = normalizeArgs(arguments, tracer, config, defaultFieldResolver)\n      const schema = args.schema\n      const document = args.document\n      const source = document && document._datadog_source\n      const contextValue = args.contextValue\n      const operation = getOperation(document, args.operationName)\n\n      if (contextValue._datadog_graphql) {\n        return execute.apply(this, arguments)\n      }\n\n      if (schema) {\n        wrapFields(schema._queryType, tracer, config)\n        wrapFields(schema._mutationType, tracer, config)\n      }\n\n      const span = startExecutionSpan(tracer, config, operation, args)\n\n      contextValue._datadog_graphql = { source, span, fields: {} }\n\n      return call(execute, span, this, arguments, (err, res) => {\n        finishResolvers(contextValue, config)\n\n        setError(span, err || (res && res.errors && res.errors[0]))\n        config.hooks.execute(span, args, res)\n        finish(span)\n      })\n    }\n  }\n}\n\nfunction createWrapParse (tracer, config) {\n  return function wrapParse (parse) {\n    return function parseWithTrace (source) {\n      const span = startSpan(tracer, config, 'parse')\n\n      analyticsSampler.sample(span, config.measured, true)\n\n      let document\n      try {\n        document = parse.apply(this, arguments)\n        const operation = getOperation(document)\n\n        if (!operation) return document // skip schema parsing\n\n        if (source) {\n          document._datadog_source = source.body || source\n        }\n\n        addDocumentTags(span, document, config)\n\n        return document\n      } catch (e) {\n        setError(span, e)\n        throw e\n      } finally {\n        config.hooks.parse(span, source, document)\n        finish(span)\n      }\n    }\n  }\n}\n\nfunction createWrapValidate (tracer, config) {\n  return function wrapValidate (validate) {\n    return function validateWithTrace (schema, document, rules, typeInfo) {\n      const span = startSpan(tracer, config, 'validate')\n\n      analyticsSampler.sample(span, config.measured, true)\n\n      // skip for schema stitching nested validation\n      if (document && document.loc) {\n        addDocumentTags(span, document, config)\n      }\n\n      let errors\n      try {\n        errors = validate.apply(this, arguments)\n\n        setError(span, errors && errors[0])\n\n        return errors\n      } catch (e) {\n        setError(span, e)\n        throw e\n      } finally {\n        config.hooks.validate(span, document, errors)\n        finish(span)\n      }\n    }\n  }\n}\n\nfunction wrapFields (type, tracer, config) {\n  if (!type || !type._fields || type._datadog_patched) {\n    return\n  }\n\n  type._datadog_patched = true\n\n  Object.keys(type._fields).forEach(key => {\n    const field = type._fields[key]\n\n    wrapFieldResolve(field, tracer, config)\n    wrapFieldType(field, tracer, config)\n  })\n}\n\nfunction wrapFieldResolve (field, tracer, config) {\n  if (!field || !field.resolve) return\n\n  field.resolve = wrapResolve(field.resolve, tracer, config)\n}\n\nfunction wrapFieldType (field, tracer, config) {\n  if (!field || !field.type) return\n\n  let unwrappedType = field.type\n\n  while (unwrappedType.ofType) {\n    unwrappedType = unwrappedType.ofType\n  }\n\n  wrapFields(unwrappedType, tracer, config)\n}\n\nfunction wrapResolve (resolve, tracer, config) {\n  if (resolve._datadog_patched || typeof resolve !== 'function') return resolve\n\n  const responsePathAsArray = config.collapse\n    ? withCollapse(pathToArray)\n    : pathToArray\n\n  function resolveWithTrace (source, args, contextValue, info) {\n    if (!contextValue._datadog_graphql) return resolve.apply(this, arguments)\n\n    const path = responsePathAsArray(info && info.path)\n\n    if (config.depth >= 0) {\n      const depth = path.filter(item => typeof item === 'string').length\n\n      if (config.depth < depth) {\n        const parent = getParentField(tracer, contextValue, path)\n\n        return call(resolve, parent.span, this, arguments)\n      }\n    }\n\n    const field = assertField(tracer, config, contextValue, info, path)\n\n    return call(resolve, field.span, this, arguments, err => updateField(field, err))\n  }\n\n  resolveWithTrace._datadog_patched = true\n\n  return resolveWithTrace\n}\n\nfunction call (fn, span, thisArg, args, callback) {\n  const scope = span.tracer().scope()\n\n  callback = callback || (() => {})\n\n  try {\n    const result = scope.activate(span, () => fn.apply(thisArg, args))\n\n    if (result && typeof result.then === 'function') {\n      result.then(\n        res => callback(null, res),\n        err => callback(err)\n      )\n    } else {\n      callback(null, result)\n    }\n\n    return result\n  } catch (e) {\n    callback(e)\n    throw e\n  }\n}\n\nfunction getParentField (tracer, contextValue, path) {\n  for (let i = path.length - 1; i > 0; i--) {\n    const field = getField(contextValue, path.slice(0, i))\n\n    if (field) {\n      return field\n    }\n  }\n\n  return {\n    span: contextValue._datadog_graphql.span\n  }\n}\n\nfunction getField (contextValue, path) {\n  return contextValue._datadog_graphql.fields[path.join('.')]\n}\n\nfunction normalizeArgs (args, tracer, config, defaultFieldResolver) {\n  if (args.length !== 1) return normalizePositional(args, tracer, config, defaultFieldResolver)\n\n  args[0].contextValue = args[0].contextValue || {}\n  args[0].fieldResolver = wrapResolve(args[0].fieldResolver || defaultFieldResolver, tracer, config)\n\n  return args[0]\n}\n\nfunction normalizePositional (args, tracer, config, defaultFieldResolver) {\n  args[3] = args[3] || {} // contextValue\n  args[6] = wrapResolve(args[6] || defaultFieldResolver, tracer, config) // fieldResolver\n  args.length = Math.max(args.length, 7)\n\n  return {\n    schema: args[0],\n    document: args[1],\n    rootValue: args[2],\n    contextValue: args[3],\n    variableValues: args[4],\n    operationName: args[5],\n    fieldResolver: args[6]\n  }\n}\n\nfunction startExecutionSpan (tracer, config, operation, args) {\n  const span = startSpan(tracer, config, 'execute')\n\n  addExecutionTags(span, config, operation, args.document, args.operationName)\n  addDocumentTags(span, args.document, config)\n  addVariableTags(tracer, config, span, args.variableValues)\n\n  analyticsSampler.sample(span, config.measured, true)\n\n  return span\n}\n\nfunction addExecutionTags (span, config, operation, document, operationName) {\n  const type = operation && operation.operation\n  const name = operation && operation.name && operation.name.value\n  const tags = {\n    'resource.name': getSignature(document, name, type, config.signature)\n  }\n\n  if (type) {\n    tags['graphql.operation.type'] = type\n  }\n\n  if (name) {\n    tags['graphql.operation.name'] = name\n  }\n\n  span.addTags(tags)\n}\n\nfunction addDocumentTags (span, document, config) {\n  const tags = {}\n\n  if (config.source && document && document._datadog_source) {\n    tags['graphql.source'] = document._datadog_source\n  }\n\n  span.addTags(tags)\n}\n\nfunction addVariableTags (tracer, config, span, variableValues) {\n  const tags = {}\n\n  if (variableValues && config.variables) {\n    const variables = config.variables(variableValues)\n    for (const param in variables) {\n      tags[`graphql.variables.${param}`] = variables[param]\n    }\n  }\n\n  span.addTags(tags)\n}\n\nfunction startSpan (tracer, config, name, options) {\n  options = options || {}\n\n  return tracer.startSpan(`graphql.${name}`, {\n    childOf: options.childOf || tracer.scope().active(),\n    startTime: options.startTime,\n    tags: {\n      'service.name': getService(tracer, config),\n      'span.type': 'graphql'\n    }\n  })\n}\n\nfunction startResolveSpan (tracer, config, childOf, path, info, contextValue) {\n  const span = startSpan(tracer, config, 'resolve', { childOf })\n  const document = contextValue._datadog_graphql.source\n  const fieldNode = info.fieldNodes.find(fieldNode => fieldNode.kind === 'Field')\n\n  analyticsSampler.sample(span, config.measured)\n\n  span.addTags({\n    'resource.name': `${info.fieldName}:${info.returnType}`,\n    'graphql.field.name': info.fieldName,\n    'graphql.field.path': path.join('.'),\n    'graphql.field.type': info.returnType.name\n  })\n\n  if (fieldNode) {\n    if (config.source && document && fieldNode.loc) {\n      span.setTag('graphql.source', document.substring(fieldNode.loc.start, fieldNode.loc.end))\n    }\n\n    if (config.variables && fieldNode.arguments) {\n      const variables = config.variables(info.variableValues)\n\n      fieldNode.arguments\n        .filter(arg => arg.value && arg.value.kind === 'Variable')\n        .filter(arg => arg.value.name && variables[arg.value.name.value])\n        .map(arg => arg.value.name.value)\n        .forEach(name => {\n          span.setTag(`graphql.variables.${name}`, variables[name])\n        })\n    }\n  }\n\n  return span\n}\n\nfunction setError (span, error) {\n  if (error) {\n    span.setTag('error', error)\n  }\n}\n\nfunction finish (span, finishTime) {\n  span.finish(finishTime)\n}\n\nfunction finishResolvers (contextValue) {\n  const fields = contextValue._datadog_graphql.fields\n\n  Object.keys(fields).reverse().forEach(key => {\n    const field = fields[key]\n\n    setError(field.span, field.error)\n    finish(field.span, field.finishTime)\n  })\n}\n\nfunction updateField (field, error) {\n  // TODO: update this to also work with no-op spans without a hack\n  field.finishTime = field.span._getTime ? field.span._getTime() : 0\n  field.error = field.error || error\n}\n\nfunction withCollapse (responsePathAsArray) {\n  return function () {\n    return responsePathAsArray.apply(this, arguments)\n      .map(segment => typeof segment === 'number' ? '*' : segment)\n  }\n}\n\nfunction assertField (tracer, config, contextValue, info, path) {\n  const pathString = path.join('.')\n  const fields = contextValue._datadog_graphql.fields\n\n  let field = fields[pathString]\n\n  if (!field) {\n    const parent = getParentField(tracer, contextValue, path)\n\n    field = fields[pathString] = {\n      parent,\n      span: startResolveSpan(tracer, config, parent.span, path, info, contextValue),\n      error: null\n    }\n  }\n\n  return field\n}\n\nfunction getService (tracer, config) {\n  return config.service || tracer._service\n}\n\nfunction getOperation (document, operationName) {\n  if (!document || !Array.isArray(document.definitions)) {\n    return\n  }\n\n  const definitions = document.definitions.filter(def => def)\n  const types = ['query', 'mutation', 'subscription']\n\n  if (operationName) {\n    return definitions\n      .filter(def => types.indexOf(def.operation) !== -1)\n      .find(def => operationName === (def.name && def.name.value))\n  } else {\n    return definitions.find(def => types.indexOf(def.operation) !== -1)\n  }\n}\n\nfunction validateConfig (config) {\n  return Object.assign({}, config, {\n    depth: getDepth(config),\n    variables: getVariablesFilter(config),\n    collapse: config.collapse === undefined || !!config.collapse,\n    hooks: getHooks(config)\n  })\n}\n\nfunction getDepth (config) {\n  if (typeof config.depth === 'number') {\n    return config.depth\n  } else if (config.hasOwnProperty('depth')) {\n    log.error('Expected `depth` to be a integer.')\n  }\n  return -1\n}\n\nfunction getVariablesFilter (config) {\n  if (typeof config.variables === 'function') {\n    return config.variables\n  } else if (config.variables instanceof Array) {\n    return variables => pick(variables, config.variables)\n  } else if (config.hasOwnProperty('variables')) {\n    log.error('Expected `variables` to be an array or function.')\n  }\n  return null\n}\n\nfunction getSignature (document, operationName, operationType, calculate) {\n  if (calculate !== false && tools !== false) {\n    try {\n      try {\n        tools = tools || require('./tools')\n      } catch (e) {\n        tools = false\n        throw e\n      }\n\n      return tools.defaultEngineReportingSignature(document, operationName)\n    } catch (e) {\n      // safety net\n    }\n  }\n\n  return [operationType, operationName].filter(val => val).join(' ')\n}\n\nfunction pathToArray (path) {\n  const flattened = []\n  let curr = path\n  while (curr) {\n    flattened.push(curr.key)\n    curr = curr.prev\n  }\n  return flattened.reverse()\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const execute = (config.hooks && config.hooks.execute) || noop\n  const parse = (config.hooks && config.hooks.parse) || noop\n  const validate = (config.hooks && config.hooks.validate) || noop\n\n  return { execute, parse, validate }\n}\n\nmodule.exports = [\n  {\n    name: 'graphql',\n    file: 'execution/execute.js',\n    versions: ['>=0.10'],\n    patch (execute, tracer, config) {\n      this.wrap(execute, 'execute', createWrapExecute(\n        tracer,\n        validateConfig(config),\n        execute.defaultFieldResolver\n      ))\n    },\n    unpatch (execute) {\n      this.unwrap(execute, 'execute')\n    }\n  },\n  {\n    name: 'graphql',\n    file: 'language/parser.js',\n    versions: ['>=0.10'],\n    patch (parser, tracer, config) {\n      this.wrap(parser, 'parse', createWrapParse(tracer, validateConfig(config)))\n    },\n    unpatch (parser) {\n      this.unwrap(parser, 'parse')\n    }\n  },\n  {\n    name: 'graphql',\n    file: 'validation/validate.js',\n    versions: ['>=0.10'],\n    patch (validate, tracer, config) {\n      this.wrap(validate, 'validate', createWrapValidate(tracer, validateConfig(config)))\n    },\n    unpatch (validate) {\n      this.unwrap(validate, 'validate')\n    }\n  }\n]\n"]},"metadata":{},"sourceType":"script"}