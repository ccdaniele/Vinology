{"ast":null,"code":"'use strict';\n\nconst tx = require('../../dd-trace/src/plugins/util/promise');\n\nfunction createWrapCollectionAddQueue(tracer, config) {\n  return function wrapAddQueue(addQueue) {\n    return function addQueueWithTrace(name) {\n      const scope = tracer.scope();\n\n      if (typeof name === 'function') {\n        arguments[0] = scope.bind(name);\n      } else if (typeof this[name] === 'function') {\n        arguments[0] = scope.bind((...args) => this[name](...args));\n      }\n\n      return addQueue.apply(this, arguments);\n    };\n  };\n}\n\nfunction createWrapWrapCallback(tracer, config) {\n  return function wrapWrapCallback($wrapCallback) {\n    return function $wrapCallbackWithTrace(cb) {\n      arguments[0] = tracer.scope().bind(cb);\n      return $wrapCallback.apply(this, arguments);\n    };\n  };\n}\n\nmodule.exports = [{\n  name: 'mongoose',\n  versions: ['>=4.6.4'],\n\n  patch(mongoose, tracer, config) {\n    if (mongoose.Promise !== global.Promise) {\n      this.wrap(mongoose.Promise.prototype, 'then', tx.createWrapThen(tracer, config));\n    }\n\n    this.wrap(mongoose.Collection.prototype, 'addQueue', createWrapCollectionAddQueue(tracer, config));\n    this.wrap(mongoose.Model, '$wrapCallback', createWrapWrapCallback(tracer, config));\n  },\n\n  unpatch(mongoose) {\n    if (mongoose.Promise !== global.Promise) {\n      this.unwrap(mongoose.Promise.prototype, 'then');\n    }\n\n    this.unwrap(mongoose.Collection.prototype, 'addQueue');\n    this.unwrap(mongoose.Model, '$wrapCallback');\n  }\n\n}];","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-mongoose/src/index.js"],"names":["tx","require","createWrapCollectionAddQueue","tracer","config","wrapAddQueue","addQueue","addQueueWithTrace","name","scope","arguments","bind","args","apply","createWrapWrapCallback","wrapWrapCallback","$wrapCallback","$wrapCallbackWithTrace","cb","module","exports","versions","patch","mongoose","Promise","global","wrap","prototype","createWrapThen","Collection","Model","unpatch","unwrap"],"mappings":"AAAA;;AAEA,MAAMA,EAAE,GAAGC,OAAO,CAAC,yCAAD,CAAlB;;AAEA,SAASC,4BAAT,CAAuCC,MAAvC,EAA+CC,MAA/C,EAAuD;AACrD,SAAO,SAASC,YAAT,CAAuBC,QAAvB,EAAiC;AACtC,WAAO,SAASC,iBAAT,CAA4BC,IAA5B,EAAkC;AACvC,YAAMC,KAAK,GAAGN,MAAM,CAACM,KAAP,EAAd;;AAEA,UAAI,OAAOD,IAAP,KAAgB,UAApB,EAAgC;AAC9BE,QAAAA,SAAS,CAAC,CAAD,CAAT,GAAeD,KAAK,CAACE,IAAN,CAAWH,IAAX,CAAf;AACD,OAFD,MAEO,IAAI,OAAO,KAAKA,IAAL,CAAP,KAAsB,UAA1B,EAAsC;AAC3CE,QAAAA,SAAS,CAAC,CAAD,CAAT,GAAeD,KAAK,CAACE,IAAN,CAAW,CAAC,GAAGC,IAAJ,KAAa,KAAKJ,IAAL,EAAW,GAAGI,IAAd,CAAxB,CAAf;AACD;;AAED,aAAON,QAAQ,CAACO,KAAT,CAAe,IAAf,EAAqBH,SAArB,CAAP;AACD,KAVD;AAWD,GAZD;AAaD;;AAED,SAASI,sBAAT,CAAiCX,MAAjC,EAAyCC,MAAzC,EAAiD;AAC/C,SAAO,SAASW,gBAAT,CAA2BC,aAA3B,EAA0C;AAC/C,WAAO,SAASC,sBAAT,CAAiCC,EAAjC,EAAqC;AAC1CR,MAAAA,SAAS,CAAC,CAAD,CAAT,GAAeP,MAAM,CAACM,KAAP,GAAeE,IAAf,CAAoBO,EAApB,CAAf;AACA,aAAOF,aAAa,CAACH,KAAd,CAAoB,IAApB,EAA0BH,SAA1B,CAAP;AACD,KAHD;AAID,GALD;AAMD;;AAEDS,MAAM,CAACC,OAAP,GAAiB,CACf;AACEZ,EAAAA,IAAI,EAAE,UADR;AAEEa,EAAAA,QAAQ,EAAE,CAAC,SAAD,CAFZ;;AAGEC,EAAAA,KAAK,CAAEC,QAAF,EAAYpB,MAAZ,EAAoBC,MAApB,EAA4B;AAC/B,QAAImB,QAAQ,CAACC,OAAT,KAAqBC,MAAM,CAACD,OAAhC,EAAyC;AACvC,WAAKE,IAAL,CAAUH,QAAQ,CAACC,OAAT,CAAiBG,SAA3B,EAAsC,MAAtC,EAA8C3B,EAAE,CAAC4B,cAAH,CAAkBzB,MAAlB,EAA0BC,MAA1B,CAA9C;AACD;;AAED,SAAKsB,IAAL,CAAUH,QAAQ,CAACM,UAAT,CAAoBF,SAA9B,EAAyC,UAAzC,EAAqDzB,4BAA4B,CAACC,MAAD,EAASC,MAAT,CAAjF;AACA,SAAKsB,IAAL,CAAUH,QAAQ,CAACO,KAAnB,EAA0B,eAA1B,EAA2ChB,sBAAsB,CAACX,MAAD,EAASC,MAAT,CAAjE;AACD,GAVH;;AAWE2B,EAAAA,OAAO,CAAER,QAAF,EAAY;AACjB,QAAIA,QAAQ,CAACC,OAAT,KAAqBC,MAAM,CAACD,OAAhC,EAAyC;AACvC,WAAKQ,MAAL,CAAYT,QAAQ,CAACC,OAAT,CAAiBG,SAA7B,EAAwC,MAAxC;AACD;;AAED,SAAKK,MAAL,CAAYT,QAAQ,CAACM,UAAT,CAAoBF,SAAhC,EAA2C,UAA3C;AACA,SAAKK,MAAL,CAAYT,QAAQ,CAACO,KAArB,EAA4B,eAA5B;AACD;;AAlBH,CADe,CAAjB","sourcesContent":["'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/promise')\n\nfunction createWrapCollectionAddQueue (tracer, config) {\n  return function wrapAddQueue (addQueue) {\n    return function addQueueWithTrace (name) {\n      const scope = tracer.scope()\n\n      if (typeof name === 'function') {\n        arguments[0] = scope.bind(name)\n      } else if (typeof this[name] === 'function') {\n        arguments[0] = scope.bind((...args) => this[name](...args))\n      }\n\n      return addQueue.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapWrapCallback (tracer, config) {\n  return function wrapWrapCallback ($wrapCallback) {\n    return function $wrapCallbackWithTrace (cb) {\n      arguments[0] = tracer.scope().bind(cb)\n      return $wrapCallback.apply(this, arguments)\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'mongoose',\n    versions: ['>=4.6.4'],\n    patch (mongoose, tracer, config) {\n      if (mongoose.Promise !== global.Promise) {\n        this.wrap(mongoose.Promise.prototype, 'then', tx.createWrapThen(tracer, config))\n      }\n\n      this.wrap(mongoose.Collection.prototype, 'addQueue', createWrapCollectionAddQueue(tracer, config))\n      this.wrap(mongoose.Model, '$wrapCallback', createWrapWrapCallback(tracer, config))\n    },\n    unpatch (mongoose) {\n      if (mongoose.Promise !== global.Promise) {\n        this.unwrap(mongoose.Promise.prototype, 'then')\n      }\n\n      this.unwrap(mongoose.Collection.prototype, 'addQueue')\n      this.unwrap(mongoose.Model, '$wrapCallback')\n    }\n  }\n]\n"]},"metadata":{},"sourceType":"script"}