{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst {\n  validateBoolean,\n  validateObject,\n  codes: {\n    ERR_OPERATION_FAILED\n  }\n} = require('./validators');\n\nconst {\n  randomFillSync\n} = crypto; // This is a non-cryptographically secure replacement for the native version\n// of the `secureBuffer` function used in Node.js core. This means `randomUUID`\n// should not be used where cryptographically secure uuids are important.\n//\n// Node.js core uses a native version which uses `OPENSSL_secure_malloc`\n// rather than `randomFillSync`.\n\nfunction secureBuffer(size) {\n  const buf = Buffer.alloc(size);\n  return randomFillSync(buf);\n} // Implements an RFC 4122 version 4 random UUID.\n// To improve performance, random data is generated in batches\n// large enough to cover kBatchSize UUID's at a time. The uuidData\n// buffer is reused. Each call to randomUUID() consumes 16 bytes\n// from the buffer.\n\n\nconst kBatchSize = 128;\nlet uuidData;\nlet uuidNotBuffered;\nlet uuidBatch = 0;\nlet hexBytesCache;\n\nfunction getHexBytes() {\n  if (hexBytesCache === undefined) {\n    hexBytesCache = new Array(256);\n\n    for (let i = 0; i < hexBytesCache.length; i++) {\n      const hex = i.toString(16);\n      hexBytesCache[i] = hex.padStart(2, '0');\n    }\n  }\n\n  return hexBytesCache;\n}\n\nfunction serializeUUID(buf, offset = 0) {\n  const kHexBytes = getHexBytes(); // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n\n  return kHexBytes[buf[offset]] + kHexBytes[buf[offset + 1]] + kHexBytes[buf[offset + 2]] + kHexBytes[buf[offset + 3]] + '-' + kHexBytes[buf[offset + 4]] + kHexBytes[buf[offset + 5]] + '-' + kHexBytes[buf[offset + 6] & 0x0f | 0x40] + kHexBytes[buf[offset + 7]] + '-' + kHexBytes[buf[offset + 8] & 0x3f | 0x80] + kHexBytes[buf[offset + 9]] + '-' + kHexBytes[buf[offset + 10]] + kHexBytes[buf[offset + 11]] + kHexBytes[buf[offset + 12]] + kHexBytes[buf[offset + 13]] + kHexBytes[buf[offset + 14]] + kHexBytes[buf[offset + 15]];\n}\n\nfunction getBufferedUUID() {\n  if (!uuidData) uuidData = secureBuffer(16 * kBatchSize);\n  if (uuidData === undefined) throw new ERR_OPERATION_FAILED('Out of memory');\n  if (uuidBatch === 0) randomFillSync(uuidData);\n  uuidBatch = (uuidBatch + 1) % kBatchSize;\n  return serializeUUID(uuidData, uuidBatch * 16);\n}\n\nfunction getUnbufferedUUID() {\n  if (!uuidNotBuffered) uuidNotBuffered = secureBuffer(16 * kBatchSize);\n  if (uuidNotBuffered === undefined) throw new ERR_OPERATION_FAILED('Out of memory');\n  randomFillSync(uuidNotBuffered);\n  return serializeUUID(uuidNotBuffered);\n}\n\nfunction randomUUID(options) {\n  if (options !== undefined) validateObject(options, 'options');\n  const {\n    disableEntropyCache = false\n  } = options || {};\n  validateBoolean(disableEntropyCache, 'options.disableEntropyCache');\n  return disableEntropyCache ? getUnbufferedUUID() : getBufferedUUID();\n}\n\nmodule.exports = randomUUID;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/crypto-randomuuid/polyfill.js"],"names":["crypto","require","validateBoolean","validateObject","codes","ERR_OPERATION_FAILED","randomFillSync","secureBuffer","size","buf","Buffer","alloc","kBatchSize","uuidData","uuidNotBuffered","uuidBatch","hexBytesCache","getHexBytes","undefined","Array","i","length","hex","toString","padStart","serializeUUID","offset","kHexBytes","getBufferedUUID","getUnbufferedUUID","randomUUID","options","disableEntropyCache","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst crypto = require('crypto');\n\nconst {\n  validateBoolean,\n  validateObject,\n  codes: {\n    ERR_OPERATION_FAILED\n  }\n} = require('./validators');\n\nconst { randomFillSync } = crypto;\n\n// This is a non-cryptographically secure replacement for the native version\n// of the `secureBuffer` function used in Node.js core. This means `randomUUID`\n// should not be used where cryptographically secure uuids are important.\n//\n// Node.js core uses a native version which uses `OPENSSL_secure_malloc`\n// rather than `randomFillSync`.\nfunction secureBuffer (size) {\n  const buf = Buffer.alloc(size);\n  return randomFillSync(buf);\n}\n\n// Implements an RFC 4122 version 4 random UUID.\n// To improve performance, random data is generated in batches\n// large enough to cover kBatchSize UUID's at a time. The uuidData\n// buffer is reused. Each call to randomUUID() consumes 16 bytes\n// from the buffer.\n\nconst kBatchSize = 128;\nlet uuidData;\nlet uuidNotBuffered;\nlet uuidBatch = 0;\n\nlet hexBytesCache;\nfunction getHexBytes () {\n  if (hexBytesCache === undefined) {\n    hexBytesCache = new Array(256);\n    for (let i = 0; i < hexBytesCache.length; i++) {\n      const hex = i.toString(16);\n      hexBytesCache[i] = hex.padStart(2, '0');\n    }\n  }\n  return hexBytesCache;\n}\n\nfunction serializeUUID (buf, offset = 0) {\n  const kHexBytes = getHexBytes();\n  // xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\n  return kHexBytes[buf[offset]] +\n    kHexBytes[buf[offset + 1]] +\n    kHexBytes[buf[offset + 2]] +\n    kHexBytes[buf[offset + 3]] +\n    '-' +\n    kHexBytes[buf[offset + 4]] +\n    kHexBytes[buf[offset + 5]] +\n    '-' +\n    kHexBytes[(buf[offset + 6] & 0x0f) | 0x40] +\n    kHexBytes[buf[offset + 7]] +\n    '-' +\n    kHexBytes[(buf[offset + 8] & 0x3f) | 0x80] +\n    kHexBytes[buf[offset + 9]] +\n    '-' +\n    kHexBytes[buf[offset + 10]] +\n    kHexBytes[buf[offset + 11]] +\n    kHexBytes[buf[offset + 12]] +\n    kHexBytes[buf[offset + 13]] +\n    kHexBytes[buf[offset + 14]] +\n    kHexBytes[buf[offset + 15]];\n}\n\nfunction getBufferedUUID () {\n  if (!uuidData) uuidData = secureBuffer(16 * kBatchSize);\n  if (uuidData === undefined)\n    throw new ERR_OPERATION_FAILED('Out of memory');\n\n  if (uuidBatch === 0) randomFillSync(uuidData);\n  uuidBatch = (uuidBatch + 1) % kBatchSize;\n  return serializeUUID(uuidData, uuidBatch * 16);\n}\n\nfunction getUnbufferedUUID () {\n  if (!uuidNotBuffered) uuidNotBuffered = secureBuffer(16 * kBatchSize);\n  if (uuidNotBuffered === undefined)\n    throw new ERR_OPERATION_FAILED('Out of memory');\n  randomFillSync(uuidNotBuffered);\n  return serializeUUID(uuidNotBuffered);\n}\n\nfunction randomUUID (options) {\n  if (options !== undefined)\n    validateObject(options, 'options');\n  const {\n    disableEntropyCache = false,\n  } = options || {};\n\n  validateBoolean(disableEntropyCache, 'options.disableEntropyCache');\n\n  return disableEntropyCache ? getUnbufferedUUID() : getBufferedUUID();\n}\n\nmodule.exports = randomUUID;\n"]},"metadata":{},"sourceType":"script"}