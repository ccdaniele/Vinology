{"ast":null,"code":"\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KeyMapping = void 0;\n\nvar index_1 = require(\"./index\");\n\nvar compiled_1 = require(\"../proto/compiled\"); // 1.1125369292536007e-308\n\n\nvar MIN_SAFE_FLOAT = Math.pow(2, -1023);\nvar MAX_SAFE_FLOAT = Number.MAX_VALUE;\n/**\n * A mapping between values and integer indices that imposes relative accuracy\n * guarantees. Specifically, for any value `minPossible() < value <\n * maxPossible` implementations of `KeyMapping` must be such that\n * `value(key(v))` is close to `v` with a relative error that is less than\n * `relativeAccuracy`.\n *\n * In implementations of KeyMapping, there is generally a trade-off between the\n * cost of computing the key and the number of keys that are required to cover a\n * given range of values (memory optimality). The most memory-optimal mapping is\n * the LogarithmicMapping, but it requires the costly evaluation of the logarithm\n * when computing the index. Other mappings can approximate the logarithmic\n * mapping, while being less computationally costly.\n */\n\nvar KeyMapping =\n/** @class */\nfunction () {\n  function KeyMapping(relativeAccuracy, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    if (relativeAccuracy <= 0 || relativeAccuracy >= 1) {\n      throw Error('Relative accuracy must be between 0 and 1 when initializing a KeyMapping');\n    }\n\n    this.relativeAccuracy = relativeAccuracy;\n    this._offset = offset;\n    var gammaMantissa = 2 * relativeAccuracy / (1 - relativeAccuracy);\n    this.gamma = 1 + gammaMantissa;\n    this._multiplier = 1 / Math.log1p(gammaMantissa);\n    this.minPossible = MIN_SAFE_FLOAT * this.gamma;\n    this.maxPossible = MAX_SAFE_FLOAT / this.gamma;\n  }\n\n  KeyMapping.fromGammaOffset = function (gamma, indexOffset) {\n    var relativeAccuracy = (gamma - 1) / (gamma + 1);\n    return new this(relativeAccuracy, indexOffset);\n  };\n  /** Retrieve the key specifying the bucket for a `value` */\n\n\n  KeyMapping.prototype.key = function (value) {\n    return Math.ceil(this._logGamma(value)) + this._offset;\n  };\n  /** Retrieve the value represented by the bucket at `key` */\n\n\n  KeyMapping.prototype.value = function (key) {\n    return this._powGamma(key - this._offset) * (2 / (1 + this.gamma));\n  };\n\n  KeyMapping.prototype.toProto = function () {\n    return compiled_1.IndexMapping.create({\n      gamma: this.gamma,\n      indexOffset: this._offset,\n      interpolation: this._protoInterpolation()\n    });\n  };\n\n  KeyMapping.fromProto = function (protoMapping) {\n    if (!protoMapping ||\n    /* Double equals (==) is intentional here to check for\n     * `null` | `undefined` without including `0` */\n    protoMapping.gamma == null || protoMapping.indexOffset == null) {\n      throw Error('Failed to decode mapping from protobuf');\n    }\n\n    var interpolation = protoMapping.interpolation,\n        gamma = protoMapping.gamma,\n        indexOffset = protoMapping.indexOffset;\n\n    switch (interpolation) {\n      case compiled_1.IndexMapping.Interpolation.NONE:\n        return index_1.LogarithmicMapping.fromGammaOffset(gamma, indexOffset);\n\n      case compiled_1.IndexMapping.Interpolation.LINEAR:\n        return index_1.LinearlyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);\n\n      case compiled_1.IndexMapping.Interpolation.CUBIC:\n        return index_1.CubicallyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);\n\n      default:\n        throw Error('Unrecognized mapping when decoding from protobuf');\n    }\n  };\n  /** Return (an approximation of) the logarithm of the value base gamma */\n\n\n  KeyMapping.prototype._logGamma = function (value) {\n    return Math.log2(value) * this._multiplier;\n  };\n  /** Return (an approximation of) gamma to the power value */\n\n\n  KeyMapping.prototype._powGamma = function (value) {\n    return Math.pow(2, value / this._multiplier);\n  };\n\n  KeyMapping.prototype._protoInterpolation = function () {\n    return compiled_1.IndexMapping.Interpolation.NONE;\n  };\n\n  return KeyMapping;\n}();\n\nexports.KeyMapping = KeyMapping;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js"],"names":["Object","defineProperty","exports","value","KeyMapping","index_1","require","compiled_1","MIN_SAFE_FLOAT","Math","pow","MAX_SAFE_FLOAT","Number","MAX_VALUE","relativeAccuracy","offset","Error","_offset","gammaMantissa","gamma","_multiplier","log1p","minPossible","maxPossible","fromGammaOffset","indexOffset","prototype","key","ceil","_logGamma","_powGamma","toProto","IndexMapping","create","interpolation","_protoInterpolation","fromProto","protoMapping","Interpolation","NONE","LogarithmicMapping","LINEAR","LinearlyInterpolatedMapping","CUBIC","CubicallyInterpolatedMapping","log2"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * Unless explicitly stated otherwise all files in this repository are licensed\n * under the Apache 2.0 license (see LICENSE).\n * This product includes software developed at Datadog (https://www.datadoghq.com/).\n * Copyright 2020 Datadog, Inc.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KeyMapping = void 0;\nvar index_1 = require(\"./index\");\nvar compiled_1 = require(\"../proto/compiled\");\n// 1.1125369292536007e-308\nvar MIN_SAFE_FLOAT = Math.pow(2, -1023);\nvar MAX_SAFE_FLOAT = Number.MAX_VALUE;\n/**\n * A mapping between values and integer indices that imposes relative accuracy\n * guarantees. Specifically, for any value `minPossible() < value <\n * maxPossible` implementations of `KeyMapping` must be such that\n * `value(key(v))` is close to `v` with a relative error that is less than\n * `relativeAccuracy`.\n *\n * In implementations of KeyMapping, there is generally a trade-off between the\n * cost of computing the key and the number of keys that are required to cover a\n * given range of values (memory optimality). The most memory-optimal mapping is\n * the LogarithmicMapping, but it requires the costly evaluation of the logarithm\n * when computing the index. Other mappings can approximate the logarithmic\n * mapping, while being less computationally costly.\n */\nvar KeyMapping = /** @class */ (function () {\n    function KeyMapping(relativeAccuracy, offset) {\n        if (offset === void 0) { offset = 0; }\n        if (relativeAccuracy <= 0 || relativeAccuracy >= 1) {\n            throw Error('Relative accuracy must be between 0 and 1 when initializing a KeyMapping');\n        }\n        this.relativeAccuracy = relativeAccuracy;\n        this._offset = offset;\n        var gammaMantissa = (2 * relativeAccuracy) / (1 - relativeAccuracy);\n        this.gamma = 1 + gammaMantissa;\n        this._multiplier = 1 / Math.log1p(gammaMantissa);\n        this.minPossible = MIN_SAFE_FLOAT * this.gamma;\n        this.maxPossible = MAX_SAFE_FLOAT / this.gamma;\n    }\n    KeyMapping.fromGammaOffset = function (gamma, indexOffset) {\n        var relativeAccuracy = (gamma - 1) / (gamma + 1);\n        return new this(relativeAccuracy, indexOffset);\n    };\n    /** Retrieve the key specifying the bucket for a `value` */\n    KeyMapping.prototype.key = function (value) {\n        return Math.ceil(this._logGamma(value)) + this._offset;\n    };\n    /** Retrieve the value represented by the bucket at `key` */\n    KeyMapping.prototype.value = function (key) {\n        return this._powGamma(key - this._offset) * (2 / (1 + this.gamma));\n    };\n    KeyMapping.prototype.toProto = function () {\n        return compiled_1.IndexMapping.create({\n            gamma: this.gamma,\n            indexOffset: this._offset,\n            interpolation: this._protoInterpolation()\n        });\n    };\n    KeyMapping.fromProto = function (protoMapping) {\n        if (!protoMapping ||\n            /* Double equals (==) is intentional here to check for\n             * `null` | `undefined` without including `0` */\n            protoMapping.gamma == null ||\n            protoMapping.indexOffset == null) {\n            throw Error('Failed to decode mapping from protobuf');\n        }\n        var interpolation = protoMapping.interpolation, gamma = protoMapping.gamma, indexOffset = protoMapping.indexOffset;\n        switch (interpolation) {\n            case compiled_1.IndexMapping.Interpolation.NONE:\n                return index_1.LogarithmicMapping.fromGammaOffset(gamma, indexOffset);\n            case compiled_1.IndexMapping.Interpolation.LINEAR:\n                return index_1.LinearlyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);\n            case compiled_1.IndexMapping.Interpolation.CUBIC:\n                return index_1.CubicallyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);\n            default:\n                throw Error('Unrecognized mapping when decoding from protobuf');\n        }\n    };\n    /** Return (an approximation of) the logarithm of the value base gamma */\n    KeyMapping.prototype._logGamma = function (value) {\n        return Math.log2(value) * this._multiplier;\n    };\n    /** Return (an approximation of) gamma to the power value */\n    KeyMapping.prototype._powGamma = function (value) {\n        return Math.pow(2, value / this._multiplier);\n    };\n    KeyMapping.prototype._protoInterpolation = function () {\n        return compiled_1.IndexMapping.Interpolation.NONE;\n    };\n    return KeyMapping;\n}());\nexports.KeyMapping = KeyMapping;\n"]},"metadata":{},"sourceType":"script"}