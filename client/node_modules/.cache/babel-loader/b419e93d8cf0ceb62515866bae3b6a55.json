{"ast":null,"code":"'use strict';\n\nconst tx = require('../../dd-trace/src/plugins/util/tx');\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler');\n\nfunction createWrapConnect(tracer, config) {\n  return function wrapConnect(connect) {\n    return function connectWithTrace() {\n      const scope = tracer.scope();\n      const options = getOptions(arguments);\n      const lastIndex = arguments.length - 1;\n      const callback = arguments[lastIndex];\n      if (!options) return connect.apply(this, arguments);\n\n      if (typeof callback === 'function') {\n        arguments[lastIndex] = scope.bind(callback);\n      }\n\n      const span = options.path ? wrapIpc(tracer, config, this, options) : wrapTcp(tracer, config, this, options);\n      analyticsSampler.sample(span, config.measured);\n      return scope.bind(connect, span).apply(this, arguments);\n    };\n  };\n}\n\nfunction wrapTcp(tracer, config, socket, options) {\n  const host = options.host || 'localhost';\n  const port = options.port || 0;\n  const family = options.family || 4;\n  const span = startSpan(tracer, config, 'tcp', {\n    'resource.name': [host, port].filter(val => val).join(':'),\n    'tcp.remote.host': host,\n    'tcp.remote.port': port,\n    'tcp.family': `IPv${family}`,\n    'out.host': host,\n    'out.port': port\n  });\n  setupListeners(socket, span, 'tcp');\n  return span;\n}\n\nfunction wrapIpc(tracer, config, socket, options) {\n  const span = startSpan(tracer, config, 'ipc', {\n    'resource.name': options.path,\n    'ipc.path': options.path\n  });\n  setupListeners(socket, span, 'ipc');\n  return span;\n}\n\nfunction startSpan(tracer, config, protocol, tags) {\n  const childOf = tracer.scope().active();\n  const span = tracer.startSpan(`${protocol}.connect`, {\n    childOf,\n    tags: Object.assign({\n      'span.kind': 'client',\n      'service.name': config.service || tracer._service\n    }, tags)\n  });\n  return span;\n}\n\nfunction getOptions(args) {\n  if (!args[0]) return;\n\n  switch (typeof args[0]) {\n    case 'object':\n      if (Array.isArray(args[0])) return getOptions(args[0]);\n      return args[0];\n\n    case 'string':\n      if (isNaN(parseFloat(args[0]))) {\n        return {\n          path: args[0]\n        };\n      }\n\n    case 'number':\n      // eslint-disable-line no-fallthrough\n      return {\n        port: args[0],\n        host: typeof args[1] === 'string' ? args[1] : 'localhost'\n      };\n  }\n}\n\nfunction setupListeners(socket, span, protocol) {\n  const events = ['connect', 'error', 'close', 'timeout'];\n  const wrapListener = tx.wrap(span);\n\n  const localListener = () => {\n    span.addTags({\n      'tcp.local.address': socket.localAddress,\n      'tcp.local.port': socket.localPort\n    });\n  };\n\n  const cleanupListener = () => {\n    socket.removeListener('connect', localListener);\n    events.forEach(event => {\n      socket.removeListener(event, wrapListener);\n      socket.removeListener(event, cleanupListener);\n    });\n  };\n\n  if (protocol === 'tcp') {\n    socket.once('connect', localListener);\n  }\n\n  events.forEach(event => {\n    socket.once(event, wrapListener);\n    socket.once(event, cleanupListener);\n  });\n}\n\nmodule.exports = {\n  name: 'net',\n\n  patch(net, tracer, config) {\n    require('dns'); // net will otherwise get an unpatched version for DNS lookups\n\n\n    tracer.scope().bind(net.Socket.prototype);\n    this.wrap(net.Socket.prototype, 'connect', createWrapConnect(tracer, config));\n  },\n\n  unpatch(net, tracer) {\n    tracer.scope().unbind(net.Socket.prototype);\n    this.unwrap(net.Socket.prototype, 'connect');\n  }\n\n};","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-net/src/index.js"],"names":["tx","require","analyticsSampler","createWrapConnect","tracer","config","wrapConnect","connect","connectWithTrace","scope","options","getOptions","arguments","lastIndex","length","callback","apply","bind","span","path","wrapIpc","wrapTcp","sample","measured","socket","host","port","family","startSpan","filter","val","join","setupListeners","protocol","tags","childOf","active","Object","assign","service","_service","args","Array","isArray","isNaN","parseFloat","events","wrapListener","wrap","localListener","addTags","localAddress","localPort","cleanupListener","removeListener","forEach","event","once","module","exports","name","patch","net","Socket","prototype","unpatch","unbind","unwrap"],"mappings":"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","sourcesContent":["'use strict'\n\nconst tx = require('../../dd-trace/src/plugins/util/tx')\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction createWrapConnect (tracer, config) {\n  return function wrapConnect (connect) {\n    return function connectWithTrace () {\n      const scope = tracer.scope()\n      const options = getOptions(arguments)\n      const lastIndex = arguments.length - 1\n      const callback = arguments[lastIndex]\n\n      if (!options) return connect.apply(this, arguments)\n\n      if (typeof callback === 'function') {\n        arguments[lastIndex] = scope.bind(callback)\n      }\n\n      const span = options.path\n        ? wrapIpc(tracer, config, this, options)\n        : wrapTcp(tracer, config, this, options)\n\n      analyticsSampler.sample(span, config.measured)\n\n      return scope.bind(connect, span).apply(this, arguments)\n    }\n  }\n}\n\nfunction wrapTcp (tracer, config, socket, options) {\n  const host = options.host || 'localhost'\n  const port = options.port || 0\n  const family = options.family || 4\n\n  const span = startSpan(tracer, config, 'tcp', {\n    'resource.name': [host, port].filter(val => val).join(':'),\n    'tcp.remote.host': host,\n    'tcp.remote.port': port,\n    'tcp.family': `IPv${family}`,\n    'out.host': host,\n    'out.port': port\n  })\n\n  setupListeners(socket, span, 'tcp')\n\n  return span\n}\n\nfunction wrapIpc (tracer, config, socket, options) {\n  const span = startSpan(tracer, config, 'ipc', {\n    'resource.name': options.path,\n    'ipc.path': options.path\n  })\n\n  setupListeners(socket, span, 'ipc')\n\n  return span\n}\n\nfunction startSpan (tracer, config, protocol, tags) {\n  const childOf = tracer.scope().active()\n  const span = tracer.startSpan(`${protocol}.connect`, {\n    childOf,\n    tags: Object.assign({\n      'span.kind': 'client',\n      'service.name': config.service || tracer._service\n    }, tags)\n  })\n\n  return span\n}\n\nfunction getOptions (args) {\n  if (!args[0]) return\n\n  switch (typeof args[0]) {\n    case 'object':\n      if (Array.isArray(args[0])) return getOptions(args[0])\n      return args[0]\n    case 'string':\n      if (isNaN(parseFloat(args[0]))) {\n        return {\n          path: args[0]\n        }\n      }\n    case 'number': // eslint-disable-line no-fallthrough\n      return {\n        port: args[0],\n        host: typeof args[1] === 'string' ? args[1] : 'localhost'\n      }\n  }\n}\n\nfunction setupListeners (socket, span, protocol) {\n  const events = ['connect', 'error', 'close', 'timeout']\n\n  const wrapListener = tx.wrap(span)\n\n  const localListener = () => {\n    span.addTags({\n      'tcp.local.address': socket.localAddress,\n      'tcp.local.port': socket.localPort\n    })\n  }\n\n  const cleanupListener = () => {\n    socket.removeListener('connect', localListener)\n\n    events.forEach(event => {\n      socket.removeListener(event, wrapListener)\n      socket.removeListener(event, cleanupListener)\n    })\n  }\n\n  if (protocol === 'tcp') {\n    socket.once('connect', localListener)\n  }\n\n  events.forEach(event => {\n    socket.once(event, wrapListener)\n    socket.once(event, cleanupListener)\n  })\n}\n\nmodule.exports = {\n  name: 'net',\n  patch (net, tracer, config) {\n    require('dns') // net will otherwise get an unpatched version for DNS lookups\n\n    tracer.scope().bind(net.Socket.prototype)\n\n    this.wrap(net.Socket.prototype, 'connect', createWrapConnect(tracer, config))\n  },\n  unpatch (net, tracer) {\n    tracer.scope().unbind(net.Socket.prototype)\n\n    this.unwrap(net.Socket.prototype, 'connect')\n  }\n}\n"]},"metadata":{},"sourceType":"script"}