{"ast":null,"code":"const process = require('process'),\n      util = require('util'),\n      helpers = require('./helpers'),\n      applyStatsFns = require('./statsFunctions');\n\nconst constants = require('./constants');\n\nconst createTransport = require('./transport');\n\nconst PROTOCOL = constants.PROTOCOL;\nconst TCP_ERROR_CODES = constants.tcpErrors();\nconst UDS_ERROR_CODES = constants.udsErrors();\nconst TCP_DEFAULT_GRACEFUL_RESTART_LIMIT = 1000;\nconst UDS_DEFAULT_GRACEFUL_RESTART_LIMIT = 1000;\nconst CACHE_DNS_TTL_DEFAULT = 60000;\n/**\n * The Client for StatsD.  The main entry-point for hot-shots.  Note adding new parameters\n * to the constructor is deprecated- please use the constructor as one options object.\n * @constructor\n */\n\nconst Client = function (host, port, prefix, suffix, globalize, cacheDns, mock, globalTags, maxBufferSize, bufferFlushInterval, telegraf, sampleRate, protocol) {\n  let options = host || {}; // Adding options below is DEPRECATED.  Use the options object instead.\n\n  if (arguments.length > 1 || typeof host === 'string') {\n    options = {\n      host: host,\n      port: port,\n      prefix: prefix,\n      suffix: suffix,\n      globalize: globalize,\n      cacheDns: cacheDns,\n      mock: mock === true,\n      globalTags: globalTags,\n      maxBufferSize: maxBufferSize,\n      bufferFlushInterval: bufferFlushInterval,\n      telegraf: telegraf,\n      sampleRate: sampleRate,\n      protocol: protocol\n    };\n  } // hidden global_tags option for backwards compatibility\n\n\n  options.globalTags = options.globalTags || options.global_tags;\n  this.protocol = options.protocol && options.protocol.toLowerCase();\n\n  if (!this.protocol) {\n    this.protocol = PROTOCOL.UDP;\n  }\n\n  this.cacheDns = options.cacheDns === true;\n  this.cacheDnsTtl = options.cacheDnsTtl || CACHE_DNS_TTL_DEFAULT;\n  this.host = options.host || process.env.DD_AGENT_HOST;\n  this.port = options.port || parseInt(process.env.DD_DOGSTATSD_PORT, 10) || 8125;\n  this.path = options.path;\n  this.stream = options.stream;\n  this.prefix = options.prefix || '';\n  this.suffix = options.suffix || '';\n  this.tagPrefix = options.tagPrefix || '#';\n  this.tagSeparator = options.tagSeparator || ',';\n  this.mock = options.mock;\n  this.globalTags = typeof options.globalTags === 'object' ? helpers.formatTags(options.globalTags, options.telegraf) : [];\n\n  if (process.env.DD_ENTITY_ID) {\n    this.globalTags = this.globalTags.filter(item => {\n      return item.indexOf('dd.internal.entity_id:') !== 0;\n    });\n    this.globalTags.push('dd.internal.entity_id:'.concat(helpers.sanitizeTags(process.env.DD_ENTITY_ID)));\n  }\n\n  this.telegraf = options.telegraf || false;\n  this.maxBufferSize = options.maxBufferSize || 0;\n  this.sampleRate = options.sampleRate || 1;\n  this.bufferFlushInterval = options.bufferFlushInterval || 1000;\n  this.bufferHolder = options.isChild ? options.bufferHolder : {\n    buffer: ''\n  };\n  this.errorHandler = options.errorHandler;\n  this.tcpGracefulErrorHandling = 'tcpGracefulErrorHandling' in options ? options.tcpGracefulErrorHandling : true;\n  this.tcpGracefulRestartRateLimit = options.tcpGracefulRestartRateLimit || TCP_DEFAULT_GRACEFUL_RESTART_LIMIT; // only recreate once per second\n\n  this.udsGracefulErrorHandling = 'udsGracefulErrorHandling' in options ? options.udsGracefulErrorHandling : true;\n  this.udsGracefulRestartRateLimit = options.udsGracefulRestartRateLimit || UDS_DEFAULT_GRACEFUL_RESTART_LIMIT; // only recreate once per second\n\n  this.isChild = options.isChild;\n  this.closingFlushInterval = options.closingFlushInterval || 50; // If we're mocking the client, create a buffer to record the outgoing calls.\n\n  if (this.mock) {\n    this.mockBuffer = [];\n  } // We only want a single flush event per parent and all its child clients\n\n\n  if (!options.isChild && this.maxBufferSize > 0) {\n    this.intervalHandle = setInterval(this.onBufferFlushInterval.bind(this), this.bufferFlushInterval); // do not block node from shutting down\n\n    this.intervalHandle.unref();\n  }\n\n  if (options.isChild) {\n    if (options.dnsError) {\n      this.dnsError = options.dnsError;\n    }\n\n    this.socket = options.socket;\n  } else if (options.useDefaultRoute) {\n    const defaultRoute = helpers.getDefaultRoute();\n\n    if (defaultRoute) {\n      console.log(`Got ${defaultRoute} for the system's default route`);\n      this.host = defaultRoute;\n    }\n  }\n\n  if (!this.socket) {\n    trySetNewSocket(this);\n  }\n\n  if (this.socket && !options.isChild && options.errorHandler) {\n    this.socket.on('error', options.errorHandler);\n  }\n\n  if (options.globalize) {\n    global.statsd = this;\n  } // only for TCP/UDS (options.protocol tcp/uds)\n  // enabled with the extra flag options.tcpGracefulErrorHandling/options.udsGracefulErrorHandling\n  // will gracefully (attempt) to re-open the socket with a small delay\n  // options.tcpGracefulRestartRateLimit/options.udsGracefulRestartRateLimit is the minimum time (ms) between creating sockets\n  // does not support options.isChild (how to re-create a socket you didn't create?)\n\n\n  if (this.socket) {\n    maybeAddProtocolErrorHandler(this, options.protocol);\n  }\n\n  this.messagesInFlight = 0;\n  this.CHECKS = {\n    OK: 0,\n    WARNING: 1,\n    CRITICAL: 2,\n    UNKNOWN: 3\n  };\n};\n\napplyStatsFns(Client);\n/**\n * Checks if stats is an array and sends all stats calling back once all have sent\n * @param stat {String|Array} The stat(s) to send\n * @param value The value to send\n * @param type The type of the metric\n * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n * @param tags {Array=} The Array of tags to add to metrics. Optional.\n * @param callback {Function=} Callback when message is done being delivered. Optional.\n */\n\nClient.prototype.sendAll = function (stat, value, type, sampleRate, tags, callback) {\n  let completed = 0;\n  let calledback = false;\n  let sentBytes = 0;\n  const self = this;\n\n  if (sampleRate && typeof sampleRate !== 'number') {\n    callback = tags;\n    tags = sampleRate;\n    sampleRate = undefined;\n  }\n\n  if (tags && typeof tags !== 'object') {\n    callback = tags;\n    tags = undefined;\n  }\n  /**\n   * Gets called once for each callback, when all callbacks return we will\n   * call back from the function\n   * @private\n   */\n\n\n  function onSend(error, bytes) {\n    completed += 1;\n\n    if (calledback) {\n      return;\n    }\n\n    if (error) {\n      if (typeof callback === 'function') {\n        calledback = true;\n        callback(error);\n      } else if (self.errorHandler) {\n        calledback = true;\n        self.errorHandler(error);\n      }\n\n      return;\n    }\n\n    if (bytes) {\n      sentBytes += bytes;\n    }\n\n    if (completed === stat.length && typeof callback === 'function') {\n      callback(null, sentBytes);\n    }\n  }\n\n  if (Array.isArray(stat)) {\n    stat.forEach(item => {\n      self.sendStat(item, value, type, sampleRate, tags, onSend);\n    });\n  } else {\n    this.sendStat(stat, value, type, sampleRate, tags, callback);\n  }\n};\n/**\n * Sends a stat across the wire\n * @param stat {String|Array} The stat(s) to send\n * @param value The value to send\n * @param type {String} The type of message to send to statsd\n * @param sampleRate {Number} The Number of times to sample (0 to 1)\n * @param tags {Array} The Array of tags to add to metrics\n * @param callback {Function=} Callback when message is done being delivered. Optional.\n */\n\n\nClient.prototype.sendStat = function (stat, value, type, sampleRate, tags, callback) {\n  let message = `${this.prefix + stat + this.suffix}:${value}|${type}`;\n  sampleRate = sampleRate || this.sampleRate;\n\n  if (sampleRate && sampleRate < 1) {\n    if (Math.random() < sampleRate) {\n      message += `|@${sampleRate}`;\n    } else {\n      // don't want to send if we don't meet the sample ratio\n      return callback ? callback() : undefined;\n    }\n  }\n\n  this.send(message, tags, callback);\n};\n/**\n * Send a stat or event across the wire\n * @param message {String} The constructed message without tags\n * @param tags {Array} The tags to include (along with global tags). Optional.\n * @param callback {Function=} Callback when message is done being delivered (only if maxBufferSize == 0). Optional.\n */\n\n\nClient.prototype.send = function (message, tags, callback) {\n  let mergedTags = this.globalTags;\n\n  if (tags && typeof tags === 'object') {\n    mergedTags = helpers.overrideTags(mergedTags, tags, this.telegraf);\n  }\n\n  if (mergedTags.length > 0) {\n    if (this.telegraf) {\n      message = message.split(':');\n      message = `${message[0]},${mergedTags.join(',').replace(/:/g, '=')}:${message.slice(1).join(':')}`;\n    } else {\n      message += `|${this.tagPrefix}${mergedTags.join(this.tagSeparator)}`;\n    }\n  }\n\n  this._send(message, callback);\n};\n/**\n * Send a stat or event across the wire\n * @param message {String} The constructed message without tags\n * @param callback {Function=} Callback when message is done being delivered (only if maxBufferSize == 0). Optional.\n */\n\n\nClient.prototype._send = function (message, callback) {\n  // we may have a cached error rather than a cached lookup, so\n  // throw it on\n  if (this.dnsError) {\n    if (callback) {\n      return callback(this.dnsError);\n    } else if (this.errorHandler) {\n      return this.errorHandler(this.dnsError);\n    }\n\n    throw this.dnsError;\n  } // Only send this stat if we're not a mock Client.\n\n\n  if (!this.mock) {\n    if (this.maxBufferSize === 0) {\n      this.sendMessage(message, callback);\n    } else {\n      this.enqueue(message, callback);\n    }\n  } else {\n    this.mockBuffer.push(message);\n\n    if (typeof callback === 'function') {\n      callback(null, 0);\n    }\n  }\n};\n/**\n * Add the message to the buffer and flush the buffer if needed\n *\n * @param message {String} The constructed message without tags\n */\n\n\nClient.prototype.enqueue = function (message, callback) {\n  message += '\\n';\n\n  if (this.bufferHolder.buffer.length + message.length > this.maxBufferSize) {\n    this.flushQueue(callback);\n    this.bufferHolder.buffer += message;\n  } else {\n    this.bufferHolder.buffer += message;\n\n    if (callback) {\n      callback(null);\n    }\n  }\n};\n/**\n * Flush the buffer, sending on the messages\n */\n\n\nClient.prototype.flushQueue = function (callback) {\n  this.sendMessage(this.bufferHolder.buffer, callback);\n  this.bufferHolder.buffer = '';\n};\n/**\n * Send on the message through the socket\n *\n * @param message {String} The constructed message without tags\n * @param callback {Function=} Callback when message is done being delivered. Optional.\n */\n\n\nClient.prototype.sendMessage = function (message, callback) {\n  // don't waste the time if we aren't sending anything\n  if (message === '') {\n    if (callback) {\n      callback(null);\n    }\n\n    return;\n  }\n\n  const socketWasMissing = !this.socket;\n\n  if (socketWasMissing && (this.protocol === PROTOCOL.TCP || this.protocol === PROTOCOL.UDS)) {\n    trySetNewSocket(this);\n\n    if (this.socket) {\n      // On success, add custom TCP/UDS error handling.\n      maybeAddProtocolErrorHandler(this, this.protocol, Date.now());\n    }\n  }\n\n  if (socketWasMissing) {\n    const error = new Error('Socket not created properly. Check previous errors for details.');\n\n    if (callback) {\n      return callback(error);\n    } else if (this.errorHandler) {\n      return this.errorHandler(error);\n    } else {\n      return console.error(String(error));\n    }\n  }\n\n  const handleCallback = (err, bytes) => {\n    this.messagesInFlight--;\n    const errFormatted = err ? new Error(`Error sending hot-shots message: ${err}`) : null;\n\n    if (errFormatted) {\n      errFormatted.code = err.code; // handle TCP/UDS error that requires socket replacement when we are not\n      // emitting the `error` event on `this.socket`\n\n      if ((this.protocol === PROTOCOL.TCP || this.protocol === PROTOCOL.UDS) && (callback || this.errorHandler)) {\n        protocolErrorHandler(this, this.protocol, err);\n      }\n    }\n\n    if (callback) {\n      callback(errFormatted, bytes);\n    } else if (errFormatted) {\n      if (this.errorHandler) {\n        this.errorHandler(errFormatted);\n      } else {\n        console.error(String(errFormatted)); // emit error ourselves on the socket for backwards compatibility\n\n        this.socket.emit('error', errFormatted);\n      }\n    }\n  };\n\n  try {\n    this.messagesInFlight++;\n    this.socket.send(Buffer.from(message), handleCallback);\n  } catch (err) {\n    handleCallback(err);\n  }\n};\n/**\n * Called every bufferFlushInterval to flush any buffer that is around\n */\n\n\nClient.prototype.onBufferFlushInterval = function () {\n  this.flushQueue();\n};\n/**\n * Close the underlying socket and stop listening for data on it.\n */\n\n\nClient.prototype.close = function (callback) {\n  // stop trying to flush the queue on an interval\n  if (this.intervalHandle) {\n    clearInterval(this.intervalHandle);\n  } // flush the queue one last time, if needed\n\n\n  this.flushQueue(err => {\n    if (err) {\n      if (callback) {\n        return callback(err);\n      } else {\n        return console.error(err);\n      }\n    } // FIXME: we have entered callback hell, and this whole file is in need of an async rework\n    // wait until there are no more messages in flight before really closing the socket\n\n\n    let intervalAttempts = 0;\n    const waitForMessages = setInterval(() => {\n      intervalAttempts++;\n\n      if (intervalAttempts > 10) {\n        console.log('hot-shots could not clear out messages in flight but closing anyways');\n        this.messagesInFlight = 0;\n      }\n\n      if (this.messagesInFlight <= 0) {\n        clearInterval(waitForMessages);\n\n        this._close(callback);\n      }\n    }, this.closingFlushInterval);\n  });\n};\n/**\n * Really close the socket and handle any errors related to it\n */\n\n\nClient.prototype._close = function (callback) {\n  // error function to use in callback and catch below\n  let handledError = false;\n\n  const handleErr = err => {\n    const errMessage = `Error closing hot-shots socket: ${err}`;\n\n    if (handledError) {\n      console.error(errMessage);\n    } else {\n      // The combination of catch and error can lead to some errors\n      // showing up twice.  So we just show one of the errors that occur\n      // on close.\n      handledError = true;\n\n      if (callback) {\n        callback(new Error(errMessage));\n      } else if (this.errorHandler) {\n        this.errorHandler(new Error(errMessage));\n      } else {\n        console.error(errMessage);\n      }\n    }\n  };\n\n  if (this.errorHandler) {\n    this.socket.removeListener('error', this.errorHandler);\n  } // handle error and close events\n\n\n  this.socket.on('error', handleErr);\n\n  if (callback) {\n    this.socket.on('close', err => {\n      if (!handledError && callback) {\n        callback(err);\n      }\n    });\n  }\n\n  try {\n    this.socket.close();\n  } catch (err) {\n    handleErr(err);\n  }\n};\n\nconst ChildClient = function (parent, options) {\n  options = options || {};\n  Client.call(this, {\n    isChild: true,\n    socket: parent.socket,\n    // Child inherits socket from parent. Parent itself can be a child.\n    // All children and parent share the same buffer via sharing an object (cannot mutate strings)\n    bufferHolder: parent.bufferHolder,\n    dnsError: parent.dnsError,\n    // Child inherits an error from parent (if it is there)\n    errorHandler: options.errorHandler || parent.errorHandler,\n    // Handler for callback errors\n    host: parent.host,\n    port: parent.port,\n    tagPrefix: parent.tagPrefix,\n    tagSeparator: parent.tagSeparator,\n    prefix: (options.prefix || '') + parent.prefix,\n    // Child has its prefix prepended to parent's prefix\n    suffix: parent.suffix + (options.suffix || ''),\n    // Child has its suffix appended to parent's suffix\n    globalize: false,\n    // Only 'root' client can be global\n    mock: parent.mock,\n    // Append child's tags to parent's tags\n    globalTags: typeof options.globalTags === 'object' ? helpers.overrideTags(parent.globalTags, options.globalTags, parent.telegraf) : parent.globalTags,\n    maxBufferSize: parent.maxBufferSize,\n    bufferFlushInterval: parent.bufferFlushInterval,\n    telegraf: parent.telegraf,\n    protocol: parent.protocol,\n    closingFlushInterval: parent.closingFlushInterval\n  });\n};\n\nutil.inherits(ChildClient, Client);\n/**\n * Creates a child client that adds prefix, suffix and/or tags to this client. Child client can itself have children.\n * @param options\n *   @option prefix      {String}  An optional prefix to assign to each stat name sent\n *   @option suffix      {String}  An optional suffix to assign to each stat name sent\n *   @option globalTags {Array=} Optional tags that will be added to every metric\n */\n\nClient.prototype.childClient = function (options) {\n  return new ChildClient(this, options);\n};\n\nexports = module.exports = Client;\nexports.StatsD = Client;\n/**\n * Detect and handle an error connecting to a TCP/UDS socket. This will\n * attempt to create a new socket and replace and close the client's current\n * socket, registering a **new** `protocolErrorHandler()` on the newly created socket.\n * If a new socket can't be created (e.g. if no TCP/UDS currently exists at\n * `client.path`) then this will leave the existing socket intact.\n *\n * Note that this will no-op with an early exit if the last socket create time\n * was too recent (within the TCP/UDS graceful restart rate limit).\n * @param client Client The statsd Client that may be getting a TCP/UDS error handler.\n * @param protocol Client configured protocol\n * @param err The error that we will handle if a TCP/UDS connection error is detected.\n */\n\nfunction protocolErrorHandler(client, protocol, err) {\n  if (!err || !client.socket.createdAt) {\n    return;\n  } // recreate the socket, but only once within `tcpGracefulRestartRateLimit`/`udsGracefulRestartRateLimit`.\n\n\n  if (protocol === PROTOCOL.TCP && (!TCP_ERROR_CODES.includes(-err.code) || Date.now() - client.socket.createdAt < client.tcpGracefulRestartRateLimit)) {\n    return;\n  } else if (protocol === PROTOCOL.UDS && (!UDS_ERROR_CODES.includes(-err.code) || Date.now() - client.socket.createdAt < client.udsGracefulRestartRateLimit)) {\n    return;\n  }\n\n  if (client.errorHandler) {\n    client.socket.removeListener('error', client.errorHandler);\n  }\n\n  const newSocket = createTransport(client, {\n    host: client.host,\n    path: client.path,\n    port: client.port,\n    protocol: client.protocol\n  });\n\n  if (newSocket) {\n    client.socket.close();\n    client.socket = newSocket;\n    maybeAddProtocolErrorHandler(client, protocol);\n  } else {\n    const errorMessage = `Could not replace ${protocol} connection with new socket`;\n\n    if (client.errorHandler) {\n      client.errorHandler(new Error(errorMessage));\n    } else {\n      console.error(errorMessage);\n    }\n\n    return;\n  }\n\n  if (client.errorHandler) {\n    client.socket.on('error', client.errorHandler);\n  } else {\n    client.socket.on('error', error => console.error(`hot-shots ${protocol} error: ${error}`));\n  }\n}\n/**\n * Add a TCP/UDS socket error handler to the client's socket, if the\n * client is not a \"child\" client and has graceful error handling enabled for\n * TCP/UDS.\n * @param client Client The statsd Client that may be getting a TCP/UDS error handler.\n * @param protocol Client configured protocol\n */\n\n\nfunction maybeAddProtocolErrorHandler(client, protocol) {\n  if (client.isChild) {\n    return;\n  }\n\n  if (protocol === PROTOCOL.TCP && !client.tcpGracefulErrorHandling || protocol === PROTOCOL.UDS && !client.udsGracefulErrorHandling) {\n    return;\n  }\n\n  if (protocol === PROTOCOL.TCP || protocol === PROTOCOL.UDS) {\n    client.socket.on('error', err => {\n      protocolErrorHandler(client, protocol, err);\n    });\n  }\n}\n/**\n * Try to replace a client's socket with a new transport. If `createTransport()`\n * returns `null` this will still set the client's socket to `null`. This also\n * updates the socket creation time for UDS error handling.\n * @param client Client The statsd Client that will be getting a new socket\n */\n\n\nfunction trySetNewSocket(client) {\n  client.socket = createTransport(client, {\n    host: client.host,\n    cacheDns: client.cacheDns,\n    cacheDnsTtl: client.cacheDnsTtl,\n    path: client.path,\n    port: client.port,\n    protocol: client.protocol,\n    stream: client.stream\n  });\n}","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/hot-shots/lib/statsd.js"],"names":["process","require","util","helpers","applyStatsFns","constants","createTransport","PROTOCOL","TCP_ERROR_CODES","tcpErrors","UDS_ERROR_CODES","udsErrors","TCP_DEFAULT_GRACEFUL_RESTART_LIMIT","UDS_DEFAULT_GRACEFUL_RESTART_LIMIT","CACHE_DNS_TTL_DEFAULT","Client","host","port","prefix","suffix","globalize","cacheDns","mock","globalTags","maxBufferSize","bufferFlushInterval","telegraf","sampleRate","protocol","options","arguments","length","global_tags","toLowerCase","UDP","cacheDnsTtl","env","DD_AGENT_HOST","parseInt","DD_DOGSTATSD_PORT","path","stream","tagPrefix","tagSeparator","formatTags","DD_ENTITY_ID","filter","item","indexOf","push","concat","sanitizeTags","bufferHolder","isChild","buffer","errorHandler","tcpGracefulErrorHandling","tcpGracefulRestartRateLimit","udsGracefulErrorHandling","udsGracefulRestartRateLimit","closingFlushInterval","mockBuffer","intervalHandle","setInterval","onBufferFlushInterval","bind","unref","dnsError","socket","useDefaultRoute","defaultRoute","getDefaultRoute","console","log","trySetNewSocket","on","global","statsd","maybeAddProtocolErrorHandler","messagesInFlight","CHECKS","OK","WARNING","CRITICAL","UNKNOWN","prototype","sendAll","stat","value","type","tags","callback","completed","calledback","sentBytes","self","undefined","onSend","error","bytes","Array","isArray","forEach","sendStat","message","Math","random","send","mergedTags","overrideTags","split","join","replace","slice","_send","sendMessage","enqueue","flushQueue","socketWasMissing","TCP","UDS","Date","now","Error","String","handleCallback","err","errFormatted","code","protocolErrorHandler","emit","Buffer","from","close","clearInterval","intervalAttempts","waitForMessages","_close","handledError","handleErr","errMessage","removeListener","ChildClient","parent","call","inherits","childClient","exports","module","StatsD","client","createdAt","includes","newSocket","errorMessage"],"mappings":"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","sourcesContent":["const process = require('process'),\n  util = require('util'),\n  helpers = require('./helpers'),\n  applyStatsFns = require('./statsFunctions');\n\nconst constants = require('./constants');\nconst createTransport = require('./transport');\n\nconst PROTOCOL = constants.PROTOCOL;\nconst TCP_ERROR_CODES = constants.tcpErrors();\nconst UDS_ERROR_CODES = constants.udsErrors();\nconst TCP_DEFAULT_GRACEFUL_RESTART_LIMIT = 1000;\nconst UDS_DEFAULT_GRACEFUL_RESTART_LIMIT = 1000;\nconst CACHE_DNS_TTL_DEFAULT = 60000;\n\n/**\n * The Client for StatsD.  The main entry-point for hot-shots.  Note adding new parameters\n * to the constructor is deprecated- please use the constructor as one options object.\n * @constructor\n */\nconst Client = function (host, port, prefix, suffix, globalize, cacheDns, mock,\n    globalTags, maxBufferSize, bufferFlushInterval, telegraf, sampleRate, protocol) {\n  let options = host || {};\n\n  // Adding options below is DEPRECATED.  Use the options object instead.\n  if (arguments.length > 1 || typeof(host) === 'string') {\n    options = {\n      host        : host,\n      port        : port,\n      prefix      : prefix,\n      suffix      : suffix,\n      globalize   : globalize,\n      cacheDns    : cacheDns,\n      mock        : mock === true,\n      globalTags  : globalTags,\n      maxBufferSize : maxBufferSize,\n      bufferFlushInterval: bufferFlushInterval,\n      telegraf    : telegraf,\n      sampleRate  : sampleRate,\n      protocol    : protocol\n    };\n  }\n\n\n  // hidden global_tags option for backwards compatibility\n  options.globalTags = options.globalTags || options.global_tags;\n\n  this.protocol = (options.protocol && options.protocol.toLowerCase());\n  if (! this.protocol) {\n    this.protocol = PROTOCOL.UDP;\n  }\n  this.cacheDns = options.cacheDns === true;\n  this.cacheDnsTtl = options.cacheDnsTtl || CACHE_DNS_TTL_DEFAULT;\n  this.host = options.host || process.env.DD_AGENT_HOST;\n  this.port = options.port || parseInt(process.env.DD_DOGSTATSD_PORT, 10) || 8125;\n  this.path = options.path;\n  this.stream = options.stream;\n  this.prefix = options.prefix || '';\n  this.suffix = options.suffix || '';\n  this.tagPrefix = options.tagPrefix || '#';\n  this.tagSeparator = options.tagSeparator || ',';\n  this.mock        = options.mock;\n  this.globalTags  = typeof options.globalTags === 'object' ?\n      helpers.formatTags(options.globalTags, options.telegraf) : [];\n  if (process.env.DD_ENTITY_ID) {\n    this.globalTags = this.globalTags.filter((item) => {\n      return item.indexOf('dd.internal.entity_id:') !== 0;\n    });\n    this.globalTags.push('dd.internal.entity_id:'.concat(helpers.sanitizeTags(process.env.DD_ENTITY_ID)));\n  }\n  this.telegraf = options.telegraf || false;\n  this.maxBufferSize = options.maxBufferSize || 0;\n  this.sampleRate = options.sampleRate || 1;\n  this.bufferFlushInterval = options.bufferFlushInterval || 1000;\n  this.bufferHolder = options.isChild ? options.bufferHolder : { buffer: '' };\n  this.errorHandler = options.errorHandler;\n  this.tcpGracefulErrorHandling = 'tcpGracefulErrorHandling' in options ? options.tcpGracefulErrorHandling : true;\n  this.tcpGracefulRestartRateLimit = options.tcpGracefulRestartRateLimit || TCP_DEFAULT_GRACEFUL_RESTART_LIMIT; // only recreate once per second\n  this.udsGracefulErrorHandling = 'udsGracefulErrorHandling' in options ? options.udsGracefulErrorHandling : true;\n  this.udsGracefulRestartRateLimit = options.udsGracefulRestartRateLimit || UDS_DEFAULT_GRACEFUL_RESTART_LIMIT; // only recreate once per second\n  this.isChild = options.isChild;\n  this.closingFlushInterval = options.closingFlushInterval || 50;\n\n  // If we're mocking the client, create a buffer to record the outgoing calls.\n  if (this.mock) {\n    this.mockBuffer = [];\n  }\n\n  // We only want a single flush event per parent and all its child clients\n  if (!options.isChild && this.maxBufferSize > 0) {\n    this.intervalHandle = setInterval(this.onBufferFlushInterval.bind(this), this.bufferFlushInterval);\n    // do not block node from shutting down\n    this.intervalHandle.unref();\n  }\n\n  if (options.isChild) {\n    if (options.dnsError) {\n      this.dnsError = options.dnsError;\n    }\n    this.socket = options.socket;\n  } else if (options.useDefaultRoute) {\n    const defaultRoute = helpers.getDefaultRoute();\n    if (defaultRoute) {\n      console.log(`Got ${defaultRoute} for the system's default route`);\n      this.host = defaultRoute;\n    }\n  }\n\n  if (!this.socket) {\n    trySetNewSocket(this);\n  }\n\n  if (this.socket && !options.isChild && options.errorHandler) {\n    this.socket.on('error', options.errorHandler);\n  }\n\n  if (options.globalize) {\n    global.statsd = this;\n  }\n\n  // only for TCP/UDS (options.protocol tcp/uds)\n  // enabled with the extra flag options.tcpGracefulErrorHandling/options.udsGracefulErrorHandling\n  // will gracefully (attempt) to re-open the socket with a small delay\n  // options.tcpGracefulRestartRateLimit/options.udsGracefulRestartRateLimit is the minimum time (ms) between creating sockets\n  // does not support options.isChild (how to re-create a socket you didn't create?)\n  if (this.socket) {\n    maybeAddProtocolErrorHandler(this, options.protocol);\n  }\n\n  this.messagesInFlight = 0;\n  this.CHECKS = {\n    OK: 0,\n    WARNING: 1,\n    CRITICAL: 2,\n    UNKNOWN: 3,\n  };\n};\n\napplyStatsFns(Client);\n\n/**\n * Checks if stats is an array and sends all stats calling back once all have sent\n * @param stat {String|Array} The stat(s) to send\n * @param value The value to send\n * @param type The type of the metric\n * @param sampleRate {Number=} The Number of times to sample (0 to 1). Optional.\n * @param tags {Array=} The Array of tags to add to metrics. Optional.\n * @param callback {Function=} Callback when message is done being delivered. Optional.\n */\nClient.prototype.sendAll = function (stat, value, type, sampleRate, tags, callback) {\n  let completed = 0;\n  let calledback = false;\n  let sentBytes = 0;\n  const self = this;\n\n  if (sampleRate && typeof sampleRate !== 'number') {\n    callback = tags;\n    tags = sampleRate;\n    sampleRate = undefined;\n  }\n\n  if (tags && typeof tags !== 'object') {\n    callback = tags;\n    tags = undefined;\n  }\n\n  /**\n   * Gets called once for each callback, when all callbacks return we will\n   * call back from the function\n   * @private\n   */\n  function onSend(error, bytes) {\n    completed += 1;\n    if (calledback) {\n      return;\n    }\n\n    if (error) {\n      if (typeof callback === 'function') {\n        calledback = true;\n        callback(error);\n      } else if (self.errorHandler) {\n        calledback = true;\n        self.errorHandler(error);\n      }\n      return;\n    }\n\n    if (bytes) {\n      sentBytes += bytes;\n    }\n\n    if (completed === stat.length && typeof callback === 'function') {\n      callback(null, sentBytes);\n    }\n  }\n\n  if (Array.isArray(stat)) {\n    stat.forEach(item => {\n      self.sendStat(item, value, type, sampleRate, tags, onSend);\n    });\n  } else {\n    this.sendStat(stat, value, type, sampleRate, tags, callback);\n  }\n};\n\n/**\n * Sends a stat across the wire\n * @param stat {String|Array} The stat(s) to send\n * @param value The value to send\n * @param type {String} The type of message to send to statsd\n * @param sampleRate {Number} The Number of times to sample (0 to 1)\n * @param tags {Array} The Array of tags to add to metrics\n * @param callback {Function=} Callback when message is done being delivered. Optional.\n */\nClient.prototype.sendStat = function (stat, value, type, sampleRate, tags, callback) {\n  let message = `${this.prefix + stat + this.suffix}:${value}|${type}`;\n  sampleRate = sampleRate || this.sampleRate;\n  if (sampleRate && sampleRate < 1) {\n    if (Math.random() < sampleRate) {\n      message += `|@${sampleRate}`;\n    } else {\n      // don't want to send if we don't meet the sample ratio\n      return callback ? callback() : undefined;\n    }\n  }\n  this.send(message, tags, callback);\n};\n\n/**\n * Send a stat or event across the wire\n * @param message {String} The constructed message without tags\n * @param tags {Array} The tags to include (along with global tags). Optional.\n * @param callback {Function=} Callback when message is done being delivered (only if maxBufferSize == 0). Optional.\n */\nClient.prototype.send = function (message, tags, callback) {\n  let mergedTags = this.globalTags;\n  if (tags && typeof tags === 'object') {\n    mergedTags = helpers.overrideTags(mergedTags, tags, this.telegraf);\n  }\n  if (mergedTags.length > 0) {\n    if (this.telegraf) {\n      message = message.split(':');\n      message = `${message[0]},${mergedTags.join(',').replace(/:/g, '=')}:${message.slice(1).join(':')}`;\n    } else {\n      message += `|${this.tagPrefix}${mergedTags.join(this.tagSeparator)}`;\n    }\n  }\n\n  this._send(message, callback);\n};\n\n/**\n * Send a stat or event across the wire\n * @param message {String} The constructed message without tags\n * @param callback {Function=} Callback when message is done being delivered (only if maxBufferSize == 0). Optional.\n */\nClient.prototype._send = function (message, callback) {\n  // we may have a cached error rather than a cached lookup, so\n  // throw it on\n  if (this.dnsError) {\n    if (callback) {\n      return callback(this.dnsError);\n    } else if (this.errorHandler) {\n      return this.errorHandler(this.dnsError);\n    }\n    throw this.dnsError;\n  }\n\n  // Only send this stat if we're not a mock Client.\n  if (!this.mock) {\n    if (this.maxBufferSize === 0) {\n      this.sendMessage(message, callback);\n    } else {\n      this.enqueue(message, callback);\n    }\n  } else {\n    this.mockBuffer.push(message);\n    if (typeof callback === 'function') {\n      callback(null, 0);\n    }\n  }\n};\n\n/**\n * Add the message to the buffer and flush the buffer if needed\n *\n * @param message {String} The constructed message without tags\n */\nClient.prototype.enqueue = function (message, callback) {\n  message += '\\n';\n\n  if (this.bufferHolder.buffer.length + message.length > this.maxBufferSize) {\n    this.flushQueue(callback);\n    this.bufferHolder.buffer += message;\n  }\n  else {\n    this.bufferHolder.buffer += message;\n    if (callback) {\n      callback(null);\n    }\n  }\n};\n\n/**\n * Flush the buffer, sending on the messages\n */\nClient.prototype.flushQueue = function (callback) {\n  this.sendMessage(this.bufferHolder.buffer, callback);\n  this.bufferHolder.buffer = '';\n};\n\n/**\n * Send on the message through the socket\n *\n * @param message {String} The constructed message without tags\n * @param callback {Function=} Callback when message is done being delivered. Optional.\n */\nClient.prototype.sendMessage = function (message, callback) {\n  // don't waste the time if we aren't sending anything\n  if (message === '') {\n    if (callback) {\n      callback(null);\n    }\n    return;\n  }\n\n  const socketWasMissing = !this.socket;\n  if (socketWasMissing && (this.protocol === PROTOCOL.TCP || this.protocol === PROTOCOL.UDS)) {\n    trySetNewSocket(this);\n    if (this.socket) {\n      // On success, add custom TCP/UDS error handling.\n      maybeAddProtocolErrorHandler(this, this.protocol, Date.now());\n    }\n  }\n\n  if (socketWasMissing) {\n    const error = new Error('Socket not created properly. Check previous errors for details.');\n    if (callback) {\n      return callback(error);\n    } else if (this.errorHandler) {\n      return this.errorHandler(error);\n    } else {\n      return console.error(String(error));\n    }\n  }\n\n  const handleCallback = (err, bytes) => {\n    this.messagesInFlight--;\n    const errFormatted = err ? new Error(`Error sending hot-shots message: ${err}`) : null;\n    if (errFormatted) {\n      errFormatted.code = err.code;\n      // handle TCP/UDS error that requires socket replacement when we are not\n      // emitting the `error` event on `this.socket`\n      if ((this.protocol === PROTOCOL.TCP || this.protocol === PROTOCOL.UDS) && (callback || this.errorHandler)) {\n        protocolErrorHandler(this, this.protocol, err);\n      }\n    }\n    if (callback) {\n      callback(errFormatted, bytes);\n    } else if (errFormatted) {\n      if (this.errorHandler) {\n        this.errorHandler(errFormatted);\n      } else {\n        console.error(String(errFormatted));\n        // emit error ourselves on the socket for backwards compatibility\n        this.socket.emit('error', errFormatted);\n      }\n    }\n  };\n\n  try {\n    this.messagesInFlight++;\n    this.socket.send(Buffer.from(message), handleCallback);\n  } catch (err) {\n    handleCallback(err);\n  }\n};\n\n/**\n * Called every bufferFlushInterval to flush any buffer that is around\n */\nClient.prototype.onBufferFlushInterval = function () {\n  this.flushQueue();\n};\n\n/**\n * Close the underlying socket and stop listening for data on it.\n */\nClient.prototype.close = function (callback) {\n  // stop trying to flush the queue on an interval\n  if (this.intervalHandle) {\n    clearInterval(this.intervalHandle);\n  }\n\n  // flush the queue one last time, if needed\n  this.flushQueue((err) => {\n    if (err) {\n      if (callback) {\n        return callback(err);\n      }\n      else {\n        return console.error(err);\n      }\n    }\n\n    // FIXME: we have entered callback hell, and this whole file is in need of an async rework\n\n    // wait until there are no more messages in flight before really closing the socket\n    let intervalAttempts = 0;\n    const waitForMessages = setInterval(() => {\n      intervalAttempts++;\n      if (intervalAttempts > 10) {\n        console.log('hot-shots could not clear out messages in flight but closing anyways');\n        this.messagesInFlight = 0;\n      }\n      if (this.messagesInFlight <= 0) {\n        clearInterval(waitForMessages);\n        this._close(callback);\n      }\n    }, this.closingFlushInterval);\n  });\n};\n\n/**\n * Really close the socket and handle any errors related to it\n */\nClient.prototype._close = function (callback) {\n  // error function to use in callback and catch below\n  let handledError = false;\n  const handleErr = (err) => {\n    const errMessage = `Error closing hot-shots socket: ${err}`;\n    if (handledError) {\n      console.error(errMessage);\n    }\n    else {\n      // The combination of catch and error can lead to some errors\n      // showing up twice.  So we just show one of the errors that occur\n      // on close.\n      handledError = true;\n\n      if (callback) {\n        callback(new Error(errMessage));\n      } else if (this.errorHandler) {\n        this.errorHandler(new Error(errMessage));\n      } else {\n        console.error(errMessage);\n      }\n    }\n  };\n\n  if (this.errorHandler) {\n    this.socket.removeListener('error', this.errorHandler);\n  }\n\n  // handle error and close events\n  this.socket.on('error', handleErr);\n  if (callback) {\n    this.socket.on('close', err => {\n      if (! handledError && callback) {\n        callback(err);\n      }\n    });\n  }\n\n  try {\n    this.socket.close();\n  } catch (err) {\n    handleErr(err);\n  }\n};\n\nconst ChildClient = function (parent, options) {\n  options = options || {};\n  Client.call(this, {\n    isChild     : true,\n    socket      : parent.socket, // Child inherits socket from parent. Parent itself can be a child.\n    // All children and parent share the same buffer via sharing an object (cannot mutate strings)\n    bufferHolder: parent.bufferHolder,\n    dnsError    : parent.dnsError, // Child inherits an error from parent (if it is there)\n    errorHandler: options.errorHandler || parent.errorHandler, // Handler for callback errors\n    host        : parent.host,\n    port        : parent.port,\n    tagPrefix   : parent.tagPrefix,\n    tagSeparator : parent.tagSeparator,\n    prefix      : (options.prefix || '') + parent.prefix, // Child has its prefix prepended to parent's prefix\n    suffix      : parent.suffix + (options.suffix || ''), // Child has its suffix appended to parent's suffix\n    globalize   : false, // Only 'root' client can be global\n    mock        : parent.mock,\n    // Append child's tags to parent's tags\n    globalTags  : typeof options.globalTags === 'object' ?\n        helpers.overrideTags(parent.globalTags, options.globalTags, parent.telegraf) : parent.globalTags,\n    maxBufferSize : parent.maxBufferSize,\n    bufferFlushInterval: parent.bufferFlushInterval,\n    telegraf    : parent.telegraf,\n    protocol    : parent.protocol,\n    closingFlushInterval : parent.closingFlushInterval\n  });\n};\nutil.inherits(ChildClient, Client);\n\n/**\n * Creates a child client that adds prefix, suffix and/or tags to this client. Child client can itself have children.\n * @param options\n *   @option prefix      {String}  An optional prefix to assign to each stat name sent\n *   @option suffix      {String}  An optional suffix to assign to each stat name sent\n *   @option globalTags {Array=} Optional tags that will be added to every metric\n */\nClient.prototype.childClient = function (options) {\n  return new ChildClient(this, options);\n};\n\nexports = module.exports = Client;\nexports.StatsD = Client;\n\n/**\n * Detect and handle an error connecting to a TCP/UDS socket. This will\n * attempt to create a new socket and replace and close the client's current\n * socket, registering a **new** `protocolErrorHandler()` on the newly created socket.\n * If a new socket can't be created (e.g. if no TCP/UDS currently exists at\n * `client.path`) then this will leave the existing socket intact.\n *\n * Note that this will no-op with an early exit if the last socket create time\n * was too recent (within the TCP/UDS graceful restart rate limit).\n * @param client Client The statsd Client that may be getting a TCP/UDS error handler.\n * @param protocol Client configured protocol\n * @param err The error that we will handle if a TCP/UDS connection error is detected.\n */\nfunction protocolErrorHandler(client, protocol, err) {\n  if (!err || !client.socket.createdAt) {\n    return;\n  }\n\n  // recreate the socket, but only once within `tcpGracefulRestartRateLimit`/`udsGracefulRestartRateLimit`.\n\n  if (protocol === PROTOCOL.TCP && (!TCP_ERROR_CODES.includes(-err.code) || Date.now() - client.socket.createdAt < client.tcpGracefulRestartRateLimit)) {\n    return;\n  } else if (protocol === PROTOCOL.UDS && (!UDS_ERROR_CODES.includes(-err.code) || Date.now() - client.socket.createdAt < client.udsGracefulRestartRateLimit)) {\n    return;\n  }\n\n  if (client.errorHandler) {\n    client.socket.removeListener('error', client.errorHandler);\n  }\n\n  const newSocket = createTransport(client, {\n    host: client.host,\n    path: client.path,\n    port: client.port,\n    protocol: client.protocol,\n  });\n  if (newSocket) {\n    client.socket.close();\n    client.socket = newSocket;\n    maybeAddProtocolErrorHandler(client, protocol);\n  } else {\n    const errorMessage = `Could not replace ${protocol} connection with new socket`;\n    if (client.errorHandler) {\n      client.errorHandler(new Error(errorMessage));\n    } else {\n      console.error(errorMessage);\n    }\n    return;\n  }\n\n  if (client.errorHandler) {\n    client.socket.on('error', client.errorHandler);\n  } else {\n    client.socket.on('error', (error) => console.error(`hot-shots ${protocol} error: ${error}`));\n  }\n}\n\n/**\n * Add a TCP/UDS socket error handler to the client's socket, if the\n * client is not a \"child\" client and has graceful error handling enabled for\n * TCP/UDS.\n * @param client Client The statsd Client that may be getting a TCP/UDS error handler.\n * @param protocol Client configured protocol\n */\n function maybeAddProtocolErrorHandler(client, protocol) {\n  if (client.isChild) {\n    return;\n  }\n\n  if ((protocol === PROTOCOL.TCP && !client.tcpGracefulErrorHandling) || (protocol === PROTOCOL.UDS && !client.udsGracefulErrorHandling)) {\n    return;\n  }\n\n  if (protocol === PROTOCOL.TCP || protocol === PROTOCOL.UDS) {\n    client.socket.on('error', (err) => {\n      protocolErrorHandler(client, protocol, err);\n    });\n  }\n}\n\n/**\n * Try to replace a client's socket with a new transport. If `createTransport()`\n * returns `null` this will still set the client's socket to `null`. This also\n * updates the socket creation time for UDS error handling.\n * @param client Client The statsd Client that will be getting a new socket\n */\nfunction trySetNewSocket(client) {\n  client.socket = createTransport(client, {\n    host: client.host,\n    cacheDns: client.cacheDns,\n    cacheDnsTtl: client.cacheDnsTtl,\n    path: client.path,\n    port: client.port,\n    protocol: client.protocol,\n    stream: client.stream,\n  });\n}\n"]},"metadata":{},"sourceType":"script"}