{"ast":null,"code":"'use strict';\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst docker = require('./docker');\n\nconst log = require('../../log');\n\nconst httpAgent = new http.Agent({\n  keepAlive: true\n});\nconst httpsAgent = new https.Agent({\n  keepAlive: true\n});\nconst containerId = docker.id();\n\nfunction retriableRequest(options, callback, client, data) {\n  const req = client.request(options, res => {\n    let data = '';\n    res.setTimeout(options.timeout);\n    res.on('data', chunk => {\n      data += chunk;\n    });\n    res.on('end', () => {\n      if (res.statusCode >= 200 && res.statusCode <= 299) {\n        callback(null, data, res.statusCode);\n      } else {\n        const error = new Error(`Error from the agent: ${res.statusCode} ${http.STATUS_CODES[res.statusCode]}`);\n        error.status = res.statusCode;\n        callback(error, null, res.statusCode);\n      }\n    });\n  });\n  req.setTimeout(options.timeout, req.abort);\n  data.forEach(buffer => req.write(buffer));\n  return req;\n}\n\nfunction request(options, callback) {\n  options = Object.assign({\n    headers: {},\n    data: [],\n    timeout: 2000\n  }, options);\n  const data = [].concat(options.data);\n  const isSecure = options.protocol === 'https:';\n  const client = isSecure ? https : http;\n  const agent = isSecure ? httpsAgent : httpAgent;\n  options.agent = agent;\n  options.headers['Content-Length'] = byteLength(data);\n\n  if (containerId) {\n    options.headers['Datadog-Container-ID'] = containerId;\n  }\n\n  const firstRequest = retriableRequest(options, callback, client, data); // The first request will be retried if it fails due to a socket connection close\n\n  const firstRequestErrorHandler = error => {\n    if (firstRequest.reusedSocket && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n      log.debug('Retrying request due to socket connection error');\n      const retriedReq = retriableRequest(options, callback, client, data); // The retried request will fail normally\n\n      retriedReq.on('error', e => callback(new Error(`Network error trying to reach the agent: ${e.message}`)));\n      retriedReq.end();\n    } else {\n      callback(new Error(`Network error trying to reach the agent: ${error.message}`));\n    }\n  };\n\n  firstRequest.on('error', firstRequestErrorHandler);\n  firstRequest.end();\n  return firstRequest;\n}\n\nfunction byteLength(data) {\n  return data.length > 0 ? data.reduce((prev, next) => prev + next.length, 0) : 0;\n}\n\nmodule.exports = request;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/exporters/agent/request.js"],"names":["http","require","https","docker","log","httpAgent","Agent","keepAlive","httpsAgent","containerId","id","retriableRequest","options","callback","client","data","req","request","res","setTimeout","timeout","on","chunk","statusCode","error","Error","STATUS_CODES","status","abort","forEach","buffer","write","Object","assign","headers","concat","isSecure","protocol","agent","byteLength","firstRequest","firstRequestErrorHandler","reusedSocket","code","debug","retriedReq","e","message","end","length","reduce","prev","next","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst http = require('http')\nconst https = require('https')\nconst docker = require('./docker')\nconst log = require('../../log')\n\nconst httpAgent = new http.Agent({ keepAlive: true })\nconst httpsAgent = new https.Agent({ keepAlive: true })\nconst containerId = docker.id()\n\nfunction retriableRequest (options, callback, client, data) {\n  const req = client.request(options, res => {\n    let data = ''\n\n    res.setTimeout(options.timeout)\n\n    res.on('data', chunk => { data += chunk })\n    res.on('end', () => {\n      if (res.statusCode >= 200 && res.statusCode <= 299) {\n        callback(null, data, res.statusCode)\n      } else {\n        const error = new Error(`Error from the agent: ${res.statusCode} ${http.STATUS_CODES[res.statusCode]}`)\n        error.status = res.statusCode\n\n        callback(error, null, res.statusCode)\n      }\n    })\n  })\n  req.setTimeout(options.timeout, req.abort)\n  data.forEach(buffer => req.write(buffer))\n  return req\n}\n\nfunction request (options, callback) {\n  options = Object.assign({\n    headers: {},\n    data: [],\n    timeout: 2000\n  }, options)\n\n  const data = [].concat(options.data)\n  const isSecure = options.protocol === 'https:'\n  const client = isSecure ? https : http\n  const agent = isSecure ? httpsAgent : httpAgent\n\n  options.agent = agent\n  options.headers['Content-Length'] = byteLength(data)\n\n  if (containerId) {\n    options.headers['Datadog-Container-ID'] = containerId\n  }\n  const firstRequest = retriableRequest(options, callback, client, data)\n\n  // The first request will be retried if it fails due to a socket connection close\n  const firstRequestErrorHandler = error => {\n    if (firstRequest.reusedSocket && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n      log.debug('Retrying request due to socket connection error')\n      const retriedReq = retriableRequest(options, callback, client, data)\n      // The retried request will fail normally\n      retriedReq.on('error', e => callback(new Error(`Network error trying to reach the agent: ${e.message}`)))\n      retriedReq.end()\n    } else {\n      callback(new Error(`Network error trying to reach the agent: ${error.message}`))\n    }\n  }\n\n  firstRequest.on('error', firstRequestErrorHandler)\n  firstRequest.end()\n\n  return firstRequest\n}\n\nfunction byteLength (data) {\n  return data.length > 0 ? data.reduce((prev, next) => prev + next.length, 0) : 0\n}\n\nmodule.exports = request\n"]},"metadata":{},"sourceType":"script"}