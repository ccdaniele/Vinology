{"ast":null,"code":"const {\n  SAMPLING_RULE_DECISION\n} = require('../../dd-trace/src/constants');\n\nconst {\n  SAMPLING_PRIORITY,\n  SPAN_TYPE\n} = require('../../../ext/tags');\n\nconst {\n  AUTO_KEEP\n} = require('../../../ext/priority');\n\nconst {\n  TEST_TYPE,\n  TEST_STATUS,\n  getTestParentSpan\n} = require('../../dd-trace/src/plugins/util/test');\n/**\n * There are two ways to call `test.each` in `jest`:\n * 1. With an array of arrays: https://jestjs.io/docs/api#1-testeachtablename-fn-timeout\n * 2. With a tagged template literal: https://jestjs.io/docs/api#2-testeachtablename-fn-timeout\n * This function distinguishes between the two and returns the test parameters in different formats:\n * 1. An array of arrays with the different parameters to the test, e.g.\n * [[1, 2, 3], [2, 3, 5]]\n * 2. An array of objects, e.g.\n * [{ a: 1, b: 2, expected: 3 }, { a: 2, b: 3, expected: 5}]\n */\n\n\nfunction getFormattedJestTestParameters(testParameters) {\n  if (!testParameters || !testParameters.length) {\n    return;\n  }\n\n  const [parameterArray, ...parameterValues] = testParameters;\n\n  if (parameterValues.length === 0) {\n    // Way 1.\n    return parameterArray;\n  } // Way 2.\n\n\n  const parameterKeys = parameterArray[0].split('|').map(key => key.trim());\n  const formattedParameters = [];\n\n  for (let index = 0; index < parameterValues.length; index++) {\n    const parameterValue = parameterValues[index];\n    const parameterIndex = index % parameterKeys.length;\n\n    if (!parameterIndex) {\n      formattedParameters.push({});\n    }\n\n    const parameterKey = parameterKeys[parameterIndex];\n    const lastFormattedParameter = formattedParameters[formattedParameters.length - 1];\n    lastFormattedParameter[parameterKey] = parameterValue;\n  }\n\n  return formattedParameters;\n}\n\nfunction getTestSpanTags(tracer, testEnvironmentMetadata) {\n  const childOf = getTestParentSpan(tracer);\n  const commonSpanTags = {\n    [TEST_TYPE]: 'test',\n    [SAMPLING_RULE_DECISION]: 1,\n    [SAMPLING_PRIORITY]: AUTO_KEEP,\n    [SPAN_TYPE]: 'test',\n    ...testEnvironmentMetadata\n  };\n  return {\n    childOf,\n    commonSpanTags\n  };\n}\n\nfunction setSuppressedErrors(suppressedErrors, testSpan) {\n  if (suppressedErrors && suppressedErrors.length) {\n    testSpan.setTag('error', suppressedErrors[0]);\n    testSpan.setTag(TEST_STATUS, 'fail');\n  }\n}\n\nmodule.exports = {\n  getFormattedJestTestParameters,\n  getTestSpanTags,\n  setSuppressedErrors\n};","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-jest/src/util.js"],"names":["SAMPLING_RULE_DECISION","require","SAMPLING_PRIORITY","SPAN_TYPE","AUTO_KEEP","TEST_TYPE","TEST_STATUS","getTestParentSpan","getFormattedJestTestParameters","testParameters","length","parameterArray","parameterValues","parameterKeys","split","map","key","trim","formattedParameters","index","parameterValue","parameterIndex","push","parameterKey","lastFormattedParameter","getTestSpanTags","tracer","testEnvironmentMetadata","childOf","commonSpanTags","setSuppressedErrors","suppressedErrors","testSpan","setTag","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAA6BC,OAAO,CAAC,8BAAD,CAA1C;;AACA,MAAM;AAAEC,EAAAA,iBAAF;AAAqBC,EAAAA;AAArB,IAAmCF,OAAO,CAAC,mBAAD,CAAhD;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAgBH,OAAO,CAAC,uBAAD,CAA7B;;AACA,MAAM;AAAEI,EAAAA,SAAF;AAAaC,EAAAA,WAAb;AAA0BC,EAAAA;AAA1B,IAAgDN,OAAO,CAAC,sCAAD,CAA7D;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,8BAAT,CAAyCC,cAAzC,EAAyD;AACvD,MAAI,CAACA,cAAD,IAAmB,CAACA,cAAc,CAACC,MAAvC,EAA+C;AAC7C;AACD;;AACD,QAAM,CAACC,cAAD,EAAiB,GAAGC,eAApB,IAAuCH,cAA7C;;AACA,MAAIG,eAAe,CAACF,MAAhB,KAA2B,CAA/B,EAAkC;AAAE;AAClC,WAAOC,cAAP;AACD,GAPsD,CAQvD;;;AACA,QAAME,aAAa,GAAGF,cAAc,CAAC,CAAD,CAAd,CAAkBG,KAAlB,CAAwB,GAAxB,EAA6BC,GAA7B,CAAiCC,GAAG,IAAIA,GAAG,CAACC,IAAJ,EAAxC,CAAtB;AACA,QAAMC,mBAAmB,GAAG,EAA5B;;AACA,OAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGP,eAAe,CAACF,MAA5C,EAAoDS,KAAK,EAAzD,EAA6D;AAC3D,UAAMC,cAAc,GAAGR,eAAe,CAACO,KAAD,CAAtC;AACA,UAAME,cAAc,GAAGF,KAAK,GAAGN,aAAa,CAACH,MAA7C;;AACA,QAAI,CAACW,cAAL,EAAqB;AACnBH,MAAAA,mBAAmB,CAACI,IAApB,CAAyB,EAAzB;AACD;;AACD,UAAMC,YAAY,GAAGV,aAAa,CAACQ,cAAD,CAAlC;AACA,UAAMG,sBAAsB,GAAGN,mBAAmB,CAACA,mBAAmB,CAACR,MAApB,GAA6B,CAA9B,CAAlD;AACAc,IAAAA,sBAAsB,CAACD,YAAD,CAAtB,GAAuCH,cAAvC;AACD;;AAED,SAAOF,mBAAP;AACD;;AAED,SAASO,eAAT,CAA0BC,MAA1B,EAAkCC,uBAAlC,EAA2D;AACzD,QAAMC,OAAO,GAAGrB,iBAAiB,CAACmB,MAAD,CAAjC;AAEA,QAAMG,cAAc,GAAG;AACrB,KAACxB,SAAD,GAAa,MADQ;AAErB,KAACL,sBAAD,GAA0B,CAFL;AAGrB,KAACE,iBAAD,GAAqBE,SAHA;AAIrB,KAACD,SAAD,GAAa,MAJQ;AAKrB,OAAGwB;AALkB,GAAvB;AAOA,SAAO;AACLC,IAAAA,OADK;AAELC,IAAAA;AAFK,GAAP;AAID;;AAED,SAASC,mBAAT,CAA8BC,gBAA9B,EAAgDC,QAAhD,EAA0D;AACxD,MAAID,gBAAgB,IAAIA,gBAAgB,CAACrB,MAAzC,EAAiD;AAC/CsB,IAAAA,QAAQ,CAACC,MAAT,CAAgB,OAAhB,EAAyBF,gBAAgB,CAAC,CAAD,CAAzC;AACAC,IAAAA,QAAQ,CAACC,MAAT,CAAgB3B,WAAhB,EAA6B,MAA7B;AACD;AACF;;AAED4B,MAAM,CAACC,OAAP,GAAiB;AAAE3B,EAAAA,8BAAF;AAAkCiB,EAAAA,eAAlC;AAAmDK,EAAAA;AAAnD,CAAjB","sourcesContent":["const { SAMPLING_RULE_DECISION } = require('../../dd-trace/src/constants')\nconst { SAMPLING_PRIORITY, SPAN_TYPE } = require('../../../ext/tags')\nconst { AUTO_KEEP } = require('../../../ext/priority')\nconst { TEST_TYPE, TEST_STATUS, getTestParentSpan } = require('../../dd-trace/src/plugins/util/test')\n\n/**\n * There are two ways to call `test.each` in `jest`:\n * 1. With an array of arrays: https://jestjs.io/docs/api#1-testeachtablename-fn-timeout\n * 2. With a tagged template literal: https://jestjs.io/docs/api#2-testeachtablename-fn-timeout\n * This function distinguishes between the two and returns the test parameters in different formats:\n * 1. An array of arrays with the different parameters to the test, e.g.\n * [[1, 2, 3], [2, 3, 5]]\n * 2. An array of objects, e.g.\n * [{ a: 1, b: 2, expected: 3 }, { a: 2, b: 3, expected: 5}]\n */\nfunction getFormattedJestTestParameters (testParameters) {\n  if (!testParameters || !testParameters.length) {\n    return\n  }\n  const [parameterArray, ...parameterValues] = testParameters\n  if (parameterValues.length === 0) { // Way 1.\n    return parameterArray\n  }\n  // Way 2.\n  const parameterKeys = parameterArray[0].split('|').map(key => key.trim())\n  const formattedParameters = []\n  for (let index = 0; index < parameterValues.length; index++) {\n    const parameterValue = parameterValues[index]\n    const parameterIndex = index % parameterKeys.length\n    if (!parameterIndex) {\n      formattedParameters.push({})\n    }\n    const parameterKey = parameterKeys[parameterIndex]\n    const lastFormattedParameter = formattedParameters[formattedParameters.length - 1]\n    lastFormattedParameter[parameterKey] = parameterValue\n  }\n\n  return formattedParameters\n}\n\nfunction getTestSpanTags (tracer, testEnvironmentMetadata) {\n  const childOf = getTestParentSpan(tracer)\n\n  const commonSpanTags = {\n    [TEST_TYPE]: 'test',\n    [SAMPLING_RULE_DECISION]: 1,\n    [SAMPLING_PRIORITY]: AUTO_KEEP,\n    [SPAN_TYPE]: 'test',\n    ...testEnvironmentMetadata\n  }\n  return {\n    childOf,\n    commonSpanTags\n  }\n}\n\nfunction setSuppressedErrors (suppressedErrors, testSpan) {\n  if (suppressedErrors && suppressedErrors.length) {\n    testSpan.setTag('error', suppressedErrors[0])\n    testSpan.setTag(TEST_STATUS, 'fail')\n  }\n}\n\nmodule.exports = { getFormattedJestTestParameters, getTestSpanTags, setSuppressedErrors }\n"]},"metadata":{},"sourceType":"script"}