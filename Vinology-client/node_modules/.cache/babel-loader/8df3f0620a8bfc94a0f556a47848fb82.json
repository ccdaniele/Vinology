{"ast":null,"code":"'use strict';\n\nconst semver = require('semver');\n\nconst hook = require('./ritm');\n\nconst esmHook = require('./iitm');\n\nconst parse = require('module-details-from-path');\n\nconst path = require('path');\n\nconst uniq = require('lodash.uniq');\n\nconst log = require('./log');\n\nconst requirePackageJson = require('./require-package-json');\n\nconst pathSepExpr = new RegExp(`\\\\${path.sep}`, 'g');\n\nclass Loader {\n  constructor(instrumenter) {\n    this._instrumenter = instrumenter;\n  }\n\n  reload(plugins) {\n    this._plugins = plugins;\n    const instrumentations = Array.from(this._plugins.keys()).reduce((prev, current) => prev.concat(current), []);\n    const instrumentedModules = uniq(instrumentations.map(instrumentation => instrumentation.name));\n    this._names = new Set(instrumentations.map(instrumentation => filename(instrumentation)));\n    hook(instrumentedModules, this._hookModule.bind(this));\n    esmHook(instrumentedModules, this._hookModule.bind(this));\n  }\n\n  load(instrumentation, config) {\n    this._getModules(instrumentation).forEach(nodule => {\n      this._instrumenter.patch(instrumentation, nodule, config);\n    });\n  }\n\n  _getModules(instrumentation) {\n    const modules = [];\n    const ids = Object.keys(require.cache);\n    let pkg;\n\n    for (let i = 0, l = ids.length; i < l; i++) {\n      const id = ids[i].replace(pathSepExpr, '/');\n      if (!id.includes(`/node_modules/${instrumentation.name}/`)) continue;\n\n      if (instrumentation.file) {\n        if (!id.endsWith(`/node_modules/${filename(instrumentation)}`)) continue;\n        const basedir = getBasedir(ids[i]);\n        pkg = requirePackageJson(basedir, module);\n      } else {\n        const basedir = getBasedir(ids[i]);\n        pkg = requirePackageJson(basedir, module);\n        const mainFile = path.posix.normalize(pkg.main || 'index.js');\n        if (!id.endsWith(`/node_modules/${instrumentation.name}/${mainFile}`)) continue;\n      }\n\n      if (!matchVersion(pkg.version, instrumentation.versions)) continue;\n      modules.push(require.cache[ids[i]].exports);\n    }\n\n    return modules;\n  }\n\n  _hookModule(moduleExports, moduleName, moduleBaseDir) {\n    moduleName = moduleName.replace(pathSepExpr, '/');\n\n    if (!this._names.has(moduleName)) {\n      return moduleExports;\n    }\n\n    if (moduleBaseDir) {\n      moduleBaseDir = moduleBaseDir.replace(pathSepExpr, '/');\n    }\n\n    const moduleVersion = getVersion(moduleBaseDir);\n\n    for (const [plugin, meta] of this._plugins) {\n      if (meta.config.enabled === false) {\n        continue;\n      }\n\n      try {\n        for (const instrumentation of [].concat(plugin)) {\n          if (moduleName !== filename(instrumentation) || !matchVersion(moduleVersion, instrumentation.versions)) {\n            continue;\n          }\n\n          moduleExports = this._instrumenter.patch(instrumentation, moduleExports, meta.config) || moduleExports;\n        }\n      } catch (e) {\n        log.error(e);\n\n        this._instrumenter.unload(plugin);\n\n        log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`);\n      }\n    }\n\n    return moduleExports;\n  }\n\n}\n\nfunction getBasedir(id) {\n  return parse(id).basedir.replace(pathSepExpr, '/');\n}\n\nfunction matchVersion(version, ranges) {\n  return !version || ranges && ranges.some(range => semver.satisfies(semver.coerce(version), range));\n}\n\nfunction getVersion(moduleBaseDir) {\n  if (moduleBaseDir) {\n    return requirePackageJson(moduleBaseDir, module).version;\n  }\n}\n\nfunction filename(plugin) {\n  return [plugin.name, plugin.file].filter(val => val).join('/');\n}\n\nmodule.exports = Loader;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/loader.js"],"names":["semver","require","hook","esmHook","parse","path","uniq","log","requirePackageJson","pathSepExpr","RegExp","sep","Loader","constructor","instrumenter","_instrumenter","reload","plugins","_plugins","instrumentations","Array","from","keys","reduce","prev","current","concat","instrumentedModules","map","instrumentation","name","_names","Set","filename","_hookModule","bind","load","config","_getModules","forEach","nodule","patch","modules","ids","Object","cache","pkg","i","l","length","id","replace","includes","file","endsWith","basedir","getBasedir","module","mainFile","posix","normalize","main","matchVersion","version","versions","push","exports","moduleExports","moduleName","moduleBaseDir","has","moduleVersion","getVersion","plugin","meta","enabled","e","error","unload","debug","ranges","some","range","satisfies","coerce","filter","val","join"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,QAAD,CAApB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,QAAD,CAAvB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,0BAAD,CAArB;;AACA,MAAMI,IAAI,GAAGJ,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMK,IAAI,GAAGL,OAAO,CAAC,aAAD,CAApB;;AACA,MAAMM,GAAG,GAAGN,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAMO,kBAAkB,GAAGP,OAAO,CAAC,wBAAD,CAAlC;;AAEA,MAAMQ,WAAW,GAAG,IAAIC,MAAJ,CAAY,KAAIL,IAAI,CAACM,GAAI,EAAzB,EAA4B,GAA5B,CAApB;;AAEA,MAAMC,MAAN,CAAa;AACXC,EAAAA,WAAW,CAAEC,YAAF,EAAgB;AACzB,SAAKC,aAAL,GAAqBD,YAArB;AACD;;AAEDE,EAAAA,MAAM,CAAEC,OAAF,EAAW;AACf,SAAKC,QAAL,GAAgBD,OAAhB;AAEA,UAAME,gBAAgB,GAAGC,KAAK,CAACC,IAAN,CAAW,KAAKH,QAAL,CAAcI,IAAd,EAAX,EACtBC,MADsB,CACf,CAACC,IAAD,EAAOC,OAAP,KAAmBD,IAAI,CAACE,MAAL,CAAYD,OAAZ,CADJ,EAC0B,EAD1B,CAAzB;AAGA,UAAME,mBAAmB,GAAGrB,IAAI,CAACa,gBAAgB,CAC9CS,GAD8B,CAC1BC,eAAe,IAAIA,eAAe,CAACC,IADT,CAAD,CAAhC;AAGA,SAAKC,MAAL,GAAc,IAAIC,GAAJ,CAAQb,gBAAgB,CACnCS,GADmB,CACfC,eAAe,IAAII,QAAQ,CAACJ,eAAD,CADZ,CAAR,CAAd;AAGA3B,IAAAA,IAAI,CAACyB,mBAAD,EAAsB,KAAKO,WAAL,CAAiBC,IAAjB,CAAsB,IAAtB,CAAtB,CAAJ;AACAhC,IAAAA,OAAO,CAACwB,mBAAD,EAAsB,KAAKO,WAAL,CAAiBC,IAAjB,CAAsB,IAAtB,CAAtB,CAAP;AACD;;AAEDC,EAAAA,IAAI,CAAEP,eAAF,EAAmBQ,MAAnB,EAA2B;AAC7B,SAAKC,WAAL,CAAiBT,eAAjB,EAAkCU,OAAlC,CAA0CC,MAAM,IAAI;AAClD,WAAKzB,aAAL,CAAmB0B,KAAnB,CAAyBZ,eAAzB,EAA0CW,MAA1C,EAAkDH,MAAlD;AACD,KAFD;AAGD;;AAEDC,EAAAA,WAAW,CAAET,eAAF,EAAmB;AAC5B,UAAMa,OAAO,GAAG,EAAhB;AACA,UAAMC,GAAG,GAAGC,MAAM,CAACtB,IAAP,CAAYrB,OAAO,CAAC4C,KAApB,CAAZ;AAEA,QAAIC,GAAJ;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGL,GAAG,CAACM,MAAxB,EAAgCF,CAAC,GAAGC,CAApC,EAAuCD,CAAC,EAAxC,EAA4C;AAC1C,YAAMG,EAAE,GAAGP,GAAG,CAACI,CAAD,CAAH,CAAOI,OAAP,CAAe1C,WAAf,EAA4B,GAA5B,CAAX;AAEA,UAAI,CAACyC,EAAE,CAACE,QAAH,CAAa,iBAAgBvB,eAAe,CAACC,IAAK,GAAlD,CAAL,EAA4D;;AAE5D,UAAID,eAAe,CAACwB,IAApB,EAA0B;AACxB,YAAI,CAACH,EAAE,CAACI,QAAH,CAAa,iBAAgBrB,QAAQ,CAACJ,eAAD,CAAkB,EAAvD,CAAL,EAAgE;AAEhE,cAAM0B,OAAO,GAAGC,UAAU,CAACb,GAAG,CAACI,CAAD,CAAJ,CAA1B;AAEAD,QAAAA,GAAG,GAAGtC,kBAAkB,CAAC+C,OAAD,EAAUE,MAAV,CAAxB;AACD,OAND,MAMO;AACL,cAAMF,OAAO,GAAGC,UAAU,CAACb,GAAG,CAACI,CAAD,CAAJ,CAA1B;AAEAD,QAAAA,GAAG,GAAGtC,kBAAkB,CAAC+C,OAAD,EAAUE,MAAV,CAAxB;AAEA,cAAMC,QAAQ,GAAGrD,IAAI,CAACsD,KAAL,CAAWC,SAAX,CAAqBd,GAAG,CAACe,IAAJ,IAAY,UAAjC,CAAjB;AACA,YAAI,CAACX,EAAE,CAACI,QAAH,CAAa,iBAAgBzB,eAAe,CAACC,IAAK,IAAG4B,QAAS,EAA9D,CAAL,EAAuE;AACxE;;AAED,UAAI,CAACI,YAAY,CAAChB,GAAG,CAACiB,OAAL,EAAclC,eAAe,CAACmC,QAA9B,CAAjB,EAA0D;AAE1DtB,MAAAA,OAAO,CAACuB,IAAR,CAAahE,OAAO,CAAC4C,KAAR,CAAcF,GAAG,CAACI,CAAD,CAAjB,EAAsBmB,OAAnC;AACD;;AAED,WAAOxB,OAAP;AACD;;AAEDR,EAAAA,WAAW,CAAEiC,aAAF,EAAiBC,UAAjB,EAA6BC,aAA7B,EAA4C;AACrDD,IAAAA,UAAU,GAAGA,UAAU,CAACjB,OAAX,CAAmB1C,WAAnB,EAAgC,GAAhC,CAAb;;AAEA,QAAI,CAAC,KAAKsB,MAAL,CAAYuC,GAAZ,CAAgBF,UAAhB,CAAL,EAAkC;AAChC,aAAOD,aAAP;AACD;;AAED,QAAIE,aAAJ,EAAmB;AACjBA,MAAAA,aAAa,GAAGA,aAAa,CAAClB,OAAd,CAAsB1C,WAAtB,EAAmC,GAAnC,CAAhB;AACD;;AAED,UAAM8D,aAAa,GAAGC,UAAU,CAACH,aAAD,CAAhC;;AAEA,SAAK,MAAM,CAACI,MAAD,EAASC,IAAT,CAAX,IAA6B,KAAKxD,QAAlC,EAA4C;AAC1C,UAAIwD,IAAI,CAACrC,MAAL,CAAYsC,OAAZ,KAAwB,KAA5B,EAAmC;AACjC;AACD;;AACD,UAAI;AACF,aAAK,MAAM9C,eAAX,IAA8B,GAAGH,MAAH,CAAU+C,MAAV,CAA9B,EAAiD;AAC/C,cAAIL,UAAU,KAAKnC,QAAQ,CAACJ,eAAD,CAAvB,IAA4C,CAACiC,YAAY,CAACS,aAAD,EAAgB1C,eAAe,CAACmC,QAAhC,CAA7D,EAAwG;AACtG;AACD;;AAEDG,UAAAA,aAAa,GAAG,KAAKpD,aAAL,CAAmB0B,KAAnB,CAAyBZ,eAAzB,EAA0CsC,aAA1C,EAAyDO,IAAI,CAACrC,MAA9D,KAAyE8B,aAAzF;AACD;AACF,OARD,CAQE,OAAOS,CAAP,EAAU;AACVrE,QAAAA,GAAG,CAACsE,KAAJ,CAAUD,CAAV;;AACA,aAAK7D,aAAL,CAAmB+D,MAAnB,CAA0BL,MAA1B;;AACAlE,QAAAA,GAAG,CAACwE,KAAJ,CAAW,+BAA8BL,IAAI,CAAC5C,IAAK,iCAAnD;AACD;AACF;;AAED,WAAOqC,aAAP;AACD;;AA9FU;;AAiGb,SAASX,UAAT,CAAqBN,EAArB,EAAyB;AACvB,SAAO9C,KAAK,CAAC8C,EAAD,CAAL,CAAUK,OAAV,CAAkBJ,OAAlB,CAA0B1C,WAA1B,EAAuC,GAAvC,CAAP;AACD;;AAED,SAASqD,YAAT,CAAuBC,OAAvB,EAAgCiB,MAAhC,EAAwC;AACtC,SAAO,CAACjB,OAAD,IAAaiB,MAAM,IAAIA,MAAM,CAACC,IAAP,CAAYC,KAAK,IAAIlF,MAAM,CAACmF,SAAP,CAAiBnF,MAAM,CAACoF,MAAP,CAAcrB,OAAd,CAAjB,EAAyCmB,KAAzC,CAArB,CAA9B;AACD;;AAED,SAASV,UAAT,CAAqBH,aAArB,EAAoC;AAClC,MAAIA,aAAJ,EAAmB;AACjB,WAAO7D,kBAAkB,CAAC6D,aAAD,EAAgBZ,MAAhB,CAAlB,CAA0CM,OAAjD;AACD;AACF;;AAED,SAAS9B,QAAT,CAAmBwC,MAAnB,EAA2B;AACzB,SAAO,CAACA,MAAM,CAAC3C,IAAR,EAAc2C,MAAM,CAACpB,IAArB,EAA2BgC,MAA3B,CAAkCC,GAAG,IAAIA,GAAzC,EAA8CC,IAA9C,CAAmD,GAAnD,CAAP;AACD;;AAED9B,MAAM,CAACS,OAAP,GAAiBtD,MAAjB","sourcesContent":["'use strict'\n\nconst semver = require('semver')\nconst hook = require('./ritm')\nconst esmHook = require('./iitm')\nconst parse = require('module-details-from-path')\nconst path = require('path')\nconst uniq = require('lodash.uniq')\nconst log = require('./log')\nconst requirePackageJson = require('./require-package-json')\n\nconst pathSepExpr = new RegExp(`\\\\${path.sep}`, 'g')\n\nclass Loader {\n  constructor (instrumenter) {\n    this._instrumenter = instrumenter\n  }\n\n  reload (plugins) {\n    this._plugins = plugins\n\n    const instrumentations = Array.from(this._plugins.keys())\n      .reduce((prev, current) => prev.concat(current), [])\n\n    const instrumentedModules = uniq(instrumentations\n      .map(instrumentation => instrumentation.name))\n\n    this._names = new Set(instrumentations\n      .map(instrumentation => filename(instrumentation)))\n\n    hook(instrumentedModules, this._hookModule.bind(this))\n    esmHook(instrumentedModules, this._hookModule.bind(this))\n  }\n\n  load (instrumentation, config) {\n    this._getModules(instrumentation).forEach(nodule => {\n      this._instrumenter.patch(instrumentation, nodule, config)\n    })\n  }\n\n  _getModules (instrumentation) {\n    const modules = []\n    const ids = Object.keys(require.cache)\n\n    let pkg\n\n    for (let i = 0, l = ids.length; i < l; i++) {\n      const id = ids[i].replace(pathSepExpr, '/')\n\n      if (!id.includes(`/node_modules/${instrumentation.name}/`)) continue\n\n      if (instrumentation.file) {\n        if (!id.endsWith(`/node_modules/${filename(instrumentation)}`)) continue\n\n        const basedir = getBasedir(ids[i])\n\n        pkg = requirePackageJson(basedir, module)\n      } else {\n        const basedir = getBasedir(ids[i])\n\n        pkg = requirePackageJson(basedir, module)\n\n        const mainFile = path.posix.normalize(pkg.main || 'index.js')\n        if (!id.endsWith(`/node_modules/${instrumentation.name}/${mainFile}`)) continue\n      }\n\n      if (!matchVersion(pkg.version, instrumentation.versions)) continue\n\n      modules.push(require.cache[ids[i]].exports)\n    }\n\n    return modules\n  }\n\n  _hookModule (moduleExports, moduleName, moduleBaseDir) {\n    moduleName = moduleName.replace(pathSepExpr, '/')\n\n    if (!this._names.has(moduleName)) {\n      return moduleExports\n    }\n\n    if (moduleBaseDir) {\n      moduleBaseDir = moduleBaseDir.replace(pathSepExpr, '/')\n    }\n\n    const moduleVersion = getVersion(moduleBaseDir)\n\n    for (const [plugin, meta] of this._plugins) {\n      if (meta.config.enabled === false) {\n        continue\n      }\n      try {\n        for (const instrumentation of [].concat(plugin)) {\n          if (moduleName !== filename(instrumentation) || !matchVersion(moduleVersion, instrumentation.versions)) {\n            continue\n          }\n\n          moduleExports = this._instrumenter.patch(instrumentation, moduleExports, meta.config) || moduleExports\n        }\n      } catch (e) {\n        log.error(e)\n        this._instrumenter.unload(plugin)\n        log.debug(`Error while trying to patch ${meta.name}. The plugin has been disabled.`)\n      }\n    }\n\n    return moduleExports\n  }\n}\n\nfunction getBasedir (id) {\n  return parse(id).basedir.replace(pathSepExpr, '/')\n}\n\nfunction matchVersion (version, ranges) {\n  return !version || (ranges && ranges.some(range => semver.satisfies(semver.coerce(version), range)))\n}\n\nfunction getVersion (moduleBaseDir) {\n  if (moduleBaseDir) {\n    return requirePackageJson(moduleBaseDir, module).version\n  }\n}\n\nfunction filename (plugin) {\n  return [plugin.name, plugin.file].filter(val => val).join('/')\n}\n\nmodule.exports = Loader\n"]},"metadata":{},"sourceType":"script"}