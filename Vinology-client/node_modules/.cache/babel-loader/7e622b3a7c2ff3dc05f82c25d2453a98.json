{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.stop = exports.start = exports.profile = exports.v8Profile = void 0;\n\nconst heap_profiler_bindings_1 = require(\"./heap-profiler-bindings\");\n\nconst profile_serializer_1 = require(\"./profile-serializer\");\n\nlet enabled = false;\nlet heapIntervalBytes = 0;\nlet heapStackDepth = 0;\n/*\n * Collects a heap profile when heapProfiler is enabled. Otherwise throws\n * an error.\n *\n * Data is returned in V8 allocation profile format.\n */\n\nfunction v8Profile() {\n  if (!enabled) {\n    throw new Error('Heap profiler is not enabled.');\n  }\n\n  return heap_profiler_bindings_1.getAllocationProfile();\n}\n\nexports.v8Profile = v8Profile;\n/**\n * Collects a profile and returns it serialized in pprof format.\n * Throws if heap profiler is not enabled.\n *\n * @param ignoreSamplePath\n * @param sourceMapper\n */\n\nfunction profile(ignoreSamplePath, sourceMapper) {\n  const startTimeNanos = Date.now() * 1000 * 1000;\n  const result = v8Profile(); // Add node for external memory usage.\n  // Current type definitions do not have external.\n  // TODO: remove any once type definition is updated to include external.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  const {\n    external\n  } = process.memoryUsage();\n\n  if (external > 0) {\n    const externalNode = {\n      name: '(external)',\n      scriptName: '',\n      children: [],\n      allocations: [{\n        sizeBytes: external,\n        count: 1\n      }]\n    };\n    result.children.push(externalNode);\n  }\n\n  return profile_serializer_1.serializeHeapProfile(result, startTimeNanos, heapIntervalBytes, ignoreSamplePath, sourceMapper);\n}\n\nexports.profile = profile;\n/**\n * Starts heap profiling. If heap profiling has already been started with\n * the same parameters, this is a noop. If heap profiler has already been\n * started with different parameters, this throws an error.\n *\n * @param intervalBytes - average number of bytes between samples.\n * @param stackDepth - maximum stack depth for samples collected.\n */\n\nfunction start(intervalBytes, stackDepth) {\n  if (enabled) {\n    throw new Error(`Heap profiler is already started  with intervalBytes ${heapIntervalBytes} and stackDepth ${stackDepth}`);\n  }\n\n  heapIntervalBytes = intervalBytes;\n  heapStackDepth = stackDepth;\n  heap_profiler_bindings_1.startSamplingHeapProfiler(heapIntervalBytes, heapStackDepth);\n  enabled = true;\n}\n\nexports.start = start; // Stops heap profiling. If heap profiling has not been started, does nothing.\n\nfunction stop() {\n  if (enabled) {\n    enabled = false;\n    heap_profiler_bindings_1.stopSamplingHeapProfiler();\n  }\n}\n\nexports.stop = stop;","map":{"version":3,"sources":["../../ts/src/heap-profiler.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;;;AAIH,MAAA,wBAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AAKA,MAAA,oBAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AAIA,IAAI,OAAO,GAAG,KAAd;AACA,IAAI,iBAAiB,GAAG,CAAxB;AACA,IAAI,cAAc,GAAG,CAArB;AAEA;;;;;AAKG;;AACH,SAAgB,SAAhB,GAAyB;AACvB,MAAI,CAAC,OAAL,EAAc;AACZ,UAAM,IAAI,KAAJ,CAAU,+BAAV,CAAN;AACD;;AACD,SAAO,wBAAA,CAAA,oBAAA,EAAP;AACD;;AALD,OAAA,CAAA,SAAA,GAAA,SAAA;AAOA;;;;;;AAMG;;AACH,SAAgB,OAAhB,CACE,gBADF,EAEE,YAFF,EAE6B;AAE3B,QAAM,cAAc,GAAG,IAAI,CAAC,GAAL,KAAa,IAAb,GAAoB,IAA3C;AACA,QAAM,MAAM,GAAG,SAAS,EAAxB,CAH2B,CAI3B;AACA;AACA;AACA;;AACA,QAAM;AAAC,IAAA;AAAD,MAAiC,OAAO,CAAC,WAAR,EAAvC;;AACA,MAAI,QAAQ,GAAG,CAAf,EAAkB;AAChB,UAAM,YAAY,GAA0B;AAC1C,MAAA,IAAI,EAAE,YADoC;AAE1C,MAAA,UAAU,EAAE,EAF8B;AAG1C,MAAA,QAAQ,EAAE,EAHgC;AAI1C,MAAA,WAAW,EAAE,CAAC;AAAC,QAAA,SAAS,EAAE,QAAZ;AAAsB,QAAA,KAAK,EAAE;AAA7B,OAAD;AAJ6B,KAA5C;AAMA,IAAA,MAAM,CAAC,QAAP,CAAgB,IAAhB,CAAqB,YAArB;AACD;;AACD,SAAO,oBAAA,CAAA,oBAAA,CACL,MADK,EAEL,cAFK,EAGL,iBAHK,EAIL,gBAJK,EAKL,YALK,CAAP;AAOD;;AA3BD,OAAA,CAAA,OAAA,GAAA,OAAA;AA6BA;;;;;;;AAOG;;AACH,SAAgB,KAAhB,CAAsB,aAAtB,EAA6C,UAA7C,EAA+D;AAC7D,MAAI,OAAJ,EAAa;AACX,UAAM,IAAI,KAAJ,CACJ,wDAAwD,iBAAiB,mBAAmB,UAAU,EADlG,CAAN;AAGD;;AACD,EAAA,iBAAiB,GAAG,aAApB;AACA,EAAA,cAAc,GAAG,UAAjB;AACA,EAAA,wBAAA,CAAA,yBAAA,CAA0B,iBAA1B,EAA6C,cAA7C;AACA,EAAA,OAAO,GAAG,IAAV;AACD;;AAVD,OAAA,CAAA,KAAA,GAAA,KAAA,C,CAYA;;AACA,SAAgB,IAAhB,GAAoB;AAClB,MAAI,OAAJ,EAAa;AACX,IAAA,OAAO,GAAG,KAAV;AACA,IAAA,wBAAA,CAAA,wBAAA;AACD;AACF;;AALD,OAAA,CAAA,IAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stop = exports.start = exports.profile = exports.v8Profile = void 0;\nconst heap_profiler_bindings_1 = require(\"./heap-profiler-bindings\");\nconst profile_serializer_1 = require(\"./profile-serializer\");\nlet enabled = false;\nlet heapIntervalBytes = 0;\nlet heapStackDepth = 0;\n/*\n * Collects a heap profile when heapProfiler is enabled. Otherwise throws\n * an error.\n *\n * Data is returned in V8 allocation profile format.\n */\nfunction v8Profile() {\n    if (!enabled) {\n        throw new Error('Heap profiler is not enabled.');\n    }\n    return heap_profiler_bindings_1.getAllocationProfile();\n}\nexports.v8Profile = v8Profile;\n/**\n * Collects a profile and returns it serialized in pprof format.\n * Throws if heap profiler is not enabled.\n *\n * @param ignoreSamplePath\n * @param sourceMapper\n */\nfunction profile(ignoreSamplePath, sourceMapper) {\n    const startTimeNanos = Date.now() * 1000 * 1000;\n    const result = v8Profile();\n    // Add node for external memory usage.\n    // Current type definitions do not have external.\n    // TODO: remove any once type definition is updated to include external.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const { external } = process.memoryUsage();\n    if (external > 0) {\n        const externalNode = {\n            name: '(external)',\n            scriptName: '',\n            children: [],\n            allocations: [{ sizeBytes: external, count: 1 }],\n        };\n        result.children.push(externalNode);\n    }\n    return profile_serializer_1.serializeHeapProfile(result, startTimeNanos, heapIntervalBytes, ignoreSamplePath, sourceMapper);\n}\nexports.profile = profile;\n/**\n * Starts heap profiling. If heap profiling has already been started with\n * the same parameters, this is a noop. If heap profiler has already been\n * started with different parameters, this throws an error.\n *\n * @param intervalBytes - average number of bytes between samples.\n * @param stackDepth - maximum stack depth for samples collected.\n */\nfunction start(intervalBytes, stackDepth) {\n    if (enabled) {\n        throw new Error(`Heap profiler is already started  with intervalBytes ${heapIntervalBytes} and stackDepth ${stackDepth}`);\n    }\n    heapIntervalBytes = intervalBytes;\n    heapStackDepth = stackDepth;\n    heap_profiler_bindings_1.startSamplingHeapProfiler(heapIntervalBytes, heapStackDepth);\n    enabled = true;\n}\nexports.start = start;\n// Stops heap profiling. If heap profiling has not been started, does nothing.\nfunction stop() {\n    if (enabled) {\n        enabled = false;\n        heap_profiler_bindings_1.stopSamplingHeapProfiler();\n    }\n}\nexports.stop = stop;\n//# sourceMappingURL=heap-profiler.js.map"]},"metadata":{},"sourceType":"script"}