{"ast":null,"code":"'use strict';\n\nconst Tags = require('opentracing').Tags;\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler');\n\nfunction createWrapRequest(tracer, config) {\n  config = normalizeConfig(config);\n  return function wrapRequest(request) {\n    return function requestWithTrace(params, options, cb) {\n      if (!params) return request.apply(this, arguments);\n      const lastIndex = arguments.length - 1;\n      const body = getBody(params.body || params.bulkBody);\n      const childOf = tracer.scope().active();\n      const span = tracer.startSpan('elasticsearch.query', {\n        childOf,\n        tags: {\n          [Tags.SPAN_KIND]: Tags.SPAN_KIND_RPC_CLIENT,\n          [Tags.DB_TYPE]: 'elasticsearch',\n          'service.name': config.service || `${tracer._service}-elasticsearch`,\n          'resource.name': `${params.method} ${quantizePath(params.path)}`,\n          'span.type': 'elasticsearch',\n          'elasticsearch.url': params.path,\n          'elasticsearch.method': params.method,\n          'elasticsearch.body': body,\n          'elasticsearch.params': JSON.stringify(params.querystring || params.query)\n        }\n      });\n      analyticsSampler.sample(span, config.measured);\n      cb = arguments[lastIndex];\n\n      if (typeof cb === 'function') {\n        arguments[lastIndex] = wrapCallback(tracer, span, params, config, cb);\n        return tracer.scope().activate(span, () => request.apply(this, arguments));\n      } else {\n        const promise = request.apply(this, arguments);\n\n        if (promise && typeof promise.then === 'function') {\n          promise.then(() => finish(span, params, config), e => finish(span, params, config, e));\n        } else {\n          finish(span, params, config);\n        }\n\n        return promise;\n      }\n    };\n  };\n}\n\nfunction wrapCallback(tracer, span, params, config, done) {\n  return tracer.scope().bind(function (err) {\n    finish(span, params, config, err);\n    done.apply(null, arguments);\n  });\n}\n\nfunction finish(span, params, config, err) {\n  if (err) {\n    span.addTags({\n      'error.type': err.name,\n      'error.msg': err.message,\n      'error.stack': err.stack\n    });\n  }\n\n  config.hooks.query(span, params);\n  span.finish();\n}\n\nfunction quantizePath(path) {\n  return path && path.replace(/[0-9]+/g, '?');\n}\n\nfunction getBody(body) {\n  return body && JSON.stringify(body);\n}\n\nfunction normalizeConfig(config) {\n  const hooks = getHooks(config);\n  return Object.assign({}, config, {\n    hooks\n  });\n}\n\nfunction getHooks(config) {\n  const noop = () => {};\n\n  const query = config.hooks && config.hooks.query || noop;\n  return {\n    query\n  };\n}\n\nmodule.exports = [{\n  name: 'elasticsearch',\n  file: 'src/lib/transport.js',\n  versions: ['>=10'],\n\n  patch(Transport, tracer, config) {\n    this.wrap(Transport.prototype, 'request', createWrapRequest(tracer, config));\n  },\n\n  unpatch(Transport) {\n    this.unwrap(Transport.prototype, 'request');\n  }\n\n}, {\n  name: '@elastic/elasticsearch',\n  file: 'lib/Transport.js',\n  versions: ['>=5.6.16'],\n\n  // initial version of this module\n  patch(Transport, tracer, config) {\n    this.wrap(Transport.prototype, 'request', createWrapRequest(tracer, config));\n  },\n\n  unpatch(Transport) {\n    this.unwrap(Transport.prototype, 'request');\n  }\n\n}];","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-elasticsearch/src/index.js"],"names":["Tags","require","analyticsSampler","createWrapRequest","tracer","config","normalizeConfig","wrapRequest","request","requestWithTrace","params","options","cb","apply","arguments","lastIndex","length","body","getBody","bulkBody","childOf","scope","active","span","startSpan","tags","SPAN_KIND","SPAN_KIND_RPC_CLIENT","DB_TYPE","service","_service","method","quantizePath","path","JSON","stringify","querystring","query","sample","measured","wrapCallback","activate","promise","then","finish","e","done","bind","err","addTags","name","message","stack","hooks","replace","getHooks","Object","assign","noop","module","exports","file","versions","patch","Transport","wrap","prototype","unpatch","unwrap"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Tags = require('opentracing').Tags\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction createWrapRequest (tracer, config) {\n  config = normalizeConfig(config)\n  return function wrapRequest (request) {\n    return function requestWithTrace (params, options, cb) {\n      if (!params) return request.apply(this, arguments)\n\n      const lastIndex = arguments.length - 1\n      const body = getBody(params.body || params.bulkBody)\n      const childOf = tracer.scope().active()\n      const span = tracer.startSpan('elasticsearch.query', {\n        childOf,\n        tags: {\n          [Tags.SPAN_KIND]: Tags.SPAN_KIND_RPC_CLIENT,\n          [Tags.DB_TYPE]: 'elasticsearch',\n          'service.name': config.service || `${tracer._service}-elasticsearch`,\n          'resource.name': `${params.method} ${quantizePath(params.path)}`,\n          'span.type': 'elasticsearch',\n          'elasticsearch.url': params.path,\n          'elasticsearch.method': params.method,\n          'elasticsearch.body': body,\n          'elasticsearch.params': JSON.stringify(params.querystring || params.query)\n        }\n      })\n\n      analyticsSampler.sample(span, config.measured)\n\n      cb = arguments[lastIndex]\n\n      if (typeof cb === 'function') {\n        arguments[lastIndex] = wrapCallback(tracer, span, params, config, cb)\n\n        return tracer.scope().activate(span, () => request.apply(this, arguments))\n      } else {\n        const promise = request.apply(this, arguments)\n\n        if (promise && typeof promise.then === 'function') {\n          promise.then(() => finish(span, params, config), e => finish(span, params, config, e))\n        } else {\n          finish(span, params, config)\n        }\n\n        return promise\n      }\n    }\n  }\n}\n\nfunction wrapCallback (tracer, span, params, config, done) {\n  return tracer.scope().bind(function (err) {\n    finish(span, params, config, err)\n    done.apply(null, arguments)\n  })\n}\n\nfunction finish (span, params, config, err) {\n  if (err) {\n    span.addTags({\n      'error.type': err.name,\n      'error.msg': err.message,\n      'error.stack': err.stack\n    })\n  }\n\n  config.hooks.query(span, params)\n\n  span.finish()\n}\n\nfunction quantizePath (path) {\n  return path && path.replace(/[0-9]+/g, '?')\n}\n\nfunction getBody (body) {\n  return body && JSON.stringify(body)\n}\n\nfunction normalizeConfig (config) {\n  const hooks = getHooks(config)\n\n  return Object.assign({}, config, {\n    hooks\n  })\n}\n\nfunction getHooks (config) {\n  const noop = () => {}\n  const query = (config.hooks && config.hooks.query) || noop\n\n  return { query }\n}\n\nmodule.exports = [\n  {\n    name: 'elasticsearch',\n    file: 'src/lib/transport.js',\n    versions: ['>=10'],\n    patch (Transport, tracer, config) {\n      this.wrap(Transport.prototype, 'request', createWrapRequest(tracer, config))\n    },\n    unpatch (Transport) {\n      this.unwrap(Transport.prototype, 'request')\n    }\n  },\n  {\n    name: '@elastic/elasticsearch',\n    file: 'lib/Transport.js',\n    versions: ['>=5.6.16'], // initial version of this module\n    patch (Transport, tracer, config) {\n      this.wrap(Transport.prototype, 'request', createWrapRequest(tracer, config))\n    },\n    unpatch (Transport) {\n      this.unwrap(Transport.prototype, 'request')\n    }\n  }\n]\n"]},"metadata":{},"sourceType":"script"}