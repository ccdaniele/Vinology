{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // TODO: Move mock-tracer to its own NPM package once it is complete and tested.\n\nvar opentracing = require(\"../index\");\n\nvar mock_report_1 = require(\"./mock_report\");\n\nvar mock_span_1 = require(\"./mock_span\");\n/**\n * OpenTracing Tracer implementation designed for use in unit tests.\n */\n\n\nvar MockTracer =\n/** @class */\nfunction (_super) {\n  __extends(MockTracer, _super); //------------------------------------------------------------------------//\n  // MockTracer-specific\n  //------------------------------------------------------------------------//\n\n\n  function MockTracer() {\n    var _this = _super.call(this) || this;\n\n    _this._spans = [];\n    return _this;\n  } //------------------------------------------------------------------------//\n  // OpenTracing implementation\n  //------------------------------------------------------------------------//\n\n\n  MockTracer.prototype._startSpan = function (name, fields) {\n    // _allocSpan is given it's own method so that derived classes can\n    // allocate any type of object they want, but not have to duplicate\n    // the other common logic in startSpan().\n    var span = this._allocSpan();\n\n    span.setOperationName(name);\n\n    this._spans.push(span);\n\n    if (fields.references) {\n      for (var _i = 0, _a = fields.references; _i < _a.length; _i++) {\n        var ref = _a[_i];\n        span.addReference(ref);\n      }\n    } // Capture the stack at the time the span started\n\n\n    span._startStack = new Error().stack;\n    return span;\n  };\n\n  MockTracer.prototype._inject = function (span, format, carrier) {\n    throw new Error('NOT YET IMPLEMENTED');\n  };\n\n  MockTracer.prototype._extract = function (format, carrier) {\n    throw new Error('NOT YET IMPLEMENTED');\n  };\n\n  MockTracer.prototype._allocSpan = function () {\n    return new mock_span_1.default(this);\n  };\n  /**\n   * Discard any buffered data.\n   */\n\n\n  MockTracer.prototype.clear = function () {\n    this._spans = [];\n  };\n  /**\n   * Return the buffered data in a format convenient for making unit test\n   * assertions.\n   */\n\n\n  MockTracer.prototype.report = function () {\n    return new mock_report_1.default(this._spans);\n  };\n\n  return MockTracer;\n}(opentracing.Tracer);\n\nexports.MockTracer = MockTracer;\nexports.default = MockTracer;","map":{"version":3,"sources":["../../src/mock_tracer/mock_tracer.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;IACA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,aAAA,CAAA;AAEA;;AAEG;;;AACH,IAAA,UAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAgC,EAAA,SAAA,CAAA,UAAA,EAAA,MAAA,CAAA,CAAhC,CAmCI;AACA;AACA;;;AAEA,WAAA,UAAA,GAAA;AAAA,QAAA,KAAA,GACI,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IADX;;AAEI,IAAA,KAAI,CAAC,MAAL,GAAc,EAAd;;AACH,GA1CL,CAII;AACA;AACA;;;AAEU,EAAA,UAAA,CAAA,SAAA,CAAA,UAAA,GAAV,UAAqB,IAArB,EAAmC,MAAnC,EAAkE;AAC9D;AACA;AACA;AACA,QAAM,IAAI,GAAG,KAAK,UAAL,EAAb;;AACA,IAAA,IAAI,CAAC,gBAAL,CAAsB,IAAtB;;AACA,SAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB;;AAEA,QAAI,MAAM,CAAC,UAAX,EAAuB;AACnB,WAAkB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,MAAM,CAAC,UAAzB,EAAkB,EAAA,GAAA,EAAA,CAAA,MAAlB,EAAkB,EAAA,EAAlB,EAAqC;AAAhC,YAAM,GAAG,GAAA,EAAA,CAAA,EAAA,CAAT;AACD,QAAA,IAAI,CAAC,YAAL,CAAkB,GAAlB;AACH;AACJ,KAZ6D,CAc9D;;;AACA,IAAA,IAAI,CAAC,WAAL,GAAmB,IAAI,KAAJ,GAAY,KAA/B;AACA,WAAO,IAAP;AACH,GAjBS;;AAmBA,EAAA,UAAA,CAAA,SAAA,CAAA,OAAA,GAAV,UAAkB,IAAlB,EAAqC,MAArC,EAAkD,OAAlD,EAA8D;AAC1D,UAAM,IAAI,KAAJ,CAAU,qBAAV,CAAN;AACH,GAFS;;AAIA,EAAA,UAAA,CAAA,SAAA,CAAA,QAAA,GAAV,UAAmB,MAAnB,EAAgC,OAAhC,EAA4C;AACxC,UAAM,IAAI,KAAJ,CAAU,qBAAV,CAAN;AACH,GAFS;;AAaF,EAAA,UAAA,CAAA,SAAA,CAAA,UAAA,GAAR,YAAA;AACI,WAAO,IAAI,WAAA,CAAA,OAAJ,CAAa,IAAb,CAAP;AACH,GAFO;AAIR;;AAEG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,KAAA,GAAA,YAAA;AACI,SAAK,MAAL,GAAc,EAAd;AACH,GAFD;AAIA;;;AAGG;;;AACH,EAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAA,YAAA;AACI,WAAO,IAAI,aAAA,CAAA,OAAJ,CAAe,KAAK,MAApB,CAAP;AACH,GAFD;;AAGJ,SAAA,UAAA;AAAC,CA9DD,CAAgC,WAAW,CAAC,MAA5C,CAAA;;AAAa,OAAA,CAAA,UAAA,GAAA,UAAA;AAgEb,OAAA,CAAA,OAAA,GAAe,UAAf","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// TODO: Move mock-tracer to its own NPM package once it is complete and tested.\nvar opentracing = require(\"../index\");\nvar mock_report_1 = require(\"./mock_report\");\nvar mock_span_1 = require(\"./mock_span\");\n/**\n * OpenTracing Tracer implementation designed for use in unit tests.\n */\nvar MockTracer = /** @class */ (function (_super) {\n    __extends(MockTracer, _super);\n    //------------------------------------------------------------------------//\n    // MockTracer-specific\n    //------------------------------------------------------------------------//\n    function MockTracer() {\n        var _this = _super.call(this) || this;\n        _this._spans = [];\n        return _this;\n    }\n    //------------------------------------------------------------------------//\n    // OpenTracing implementation\n    //------------------------------------------------------------------------//\n    MockTracer.prototype._startSpan = function (name, fields) {\n        // _allocSpan is given it's own method so that derived classes can\n        // allocate any type of object they want, but not have to duplicate\n        // the other common logic in startSpan().\n        var span = this._allocSpan();\n        span.setOperationName(name);\n        this._spans.push(span);\n        if (fields.references) {\n            for (var _i = 0, _a = fields.references; _i < _a.length; _i++) {\n                var ref = _a[_i];\n                span.addReference(ref);\n            }\n        }\n        // Capture the stack at the time the span started\n        span._startStack = new Error().stack;\n        return span;\n    };\n    MockTracer.prototype._inject = function (span, format, carrier) {\n        throw new Error('NOT YET IMPLEMENTED');\n    };\n    MockTracer.prototype._extract = function (format, carrier) {\n        throw new Error('NOT YET IMPLEMENTED');\n    };\n    MockTracer.prototype._allocSpan = function () {\n        return new mock_span_1.default(this);\n    };\n    /**\n     * Discard any buffered data.\n     */\n    MockTracer.prototype.clear = function () {\n        this._spans = [];\n    };\n    /**\n     * Return the buffered data in a format convenient for making unit test\n     * assertions.\n     */\n    MockTracer.prototype.report = function () {\n        return new mock_report_1.default(this._spans);\n    };\n    return MockTracer;\n}(opentracing.Tracer));\nexports.MockTracer = MockTracer;\nexports.default = MockTracer;\n//# sourceMappingURL=mock_tracer.js.map"]},"metadata":{},"sourceType":"script"}