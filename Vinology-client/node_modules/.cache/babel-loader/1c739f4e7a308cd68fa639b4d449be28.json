{"ast":null,"code":"'use strict';\n\nconst Chunk = require('./chunk');\n\nconst log = require('../log');\n\nconst SOFT_LIMIT = 8 * 1024 * 1024; // 8MB\n\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\nfloat64Array[0] = -1;\nconst bigEndian = uInt8Float64Array[7] === 0;\n\nclass AgentEncoder {\n  constructor(writer) {\n    this._traceBytes = new Chunk();\n    this._stringBytes = new Chunk();\n    this._writer = writer;\n\n    this._reset();\n  }\n\n  count() {\n    return this._traceCount;\n  }\n\n  encode(trace) {\n    const bytes = this._traceBytes;\n    const start = bytes.length;\n    this._traceCount++;\n\n    this._encode(bytes, trace);\n\n    const end = bytes.length;\n    log.debug(() => {\n      const hex = bytes.buffer.subarray(start, end).toString('hex').match(/../g).join(' ');\n      return `Adding encoded trace to buffer: ${hex}`;\n    }); // we can go over the soft limit since the agent has a 50MB hard limit\n\n    if (this._traceBytes.length > SOFT_LIMIT || this._stringBytes.length > SOFT_LIMIT) {\n      this._writer.flush();\n    }\n  }\n\n  makePayload() {\n    const traceSize = this._traceBytes.length + 5;\n    const buffer = Buffer.allocUnsafe(traceSize);\n\n    this._writeTraces(buffer);\n\n    this._reset();\n\n    return buffer;\n  }\n\n  _encode(bytes, trace) {\n    this._encodeArrayPrefix(bytes, trace);\n\n    for (const span of trace) {\n      bytes.reserve(1);\n\n      if (span.type) {\n        bytes.buffer[bytes.length++] = 0x8c;\n\n        this._encodeString(bytes, 'type');\n\n        this._encodeString(bytes, span.type);\n      } else {\n        bytes.buffer[bytes.length++] = 0x8b;\n      }\n\n      this._encodeString(bytes, 'trace_id');\n\n      this._encodeId(bytes, span.trace_id);\n\n      this._encodeString(bytes, 'span_id');\n\n      this._encodeId(bytes, span.span_id);\n\n      this._encodeString(bytes, 'parent_id');\n\n      this._encodeId(bytes, span.parent_id);\n\n      this._encodeString(bytes, 'name');\n\n      this._encodeString(bytes, span.name);\n\n      this._encodeString(bytes, 'resource');\n\n      this._encodeString(bytes, span.resource);\n\n      this._encodeString(bytes, 'service');\n\n      this._encodeString(bytes, span.service);\n\n      this._encodeString(bytes, 'error');\n\n      this._encodeInteger(bytes, span.error);\n\n      this._encodeString(bytes, 'start');\n\n      this._encodeLong(bytes, span.start);\n\n      this._encodeString(bytes, 'duration');\n\n      this._encodeLong(bytes, span.duration);\n\n      this._encodeString(bytes, 'meta');\n\n      this._encodeMap(bytes, span.meta);\n\n      this._encodeString(bytes, 'metrics');\n\n      this._encodeMap(bytes, span.metrics);\n    }\n  }\n\n  _reset() {\n    this._traceCount = 0;\n    this._traceBytes.length = 0;\n    this._stringCount = 0;\n    this._stringBytes.length = 0;\n    this._stringMap = {};\n\n    this._cacheString('');\n  }\n\n  _encodeArrayPrefix(bytes, value) {\n    const length = value.length;\n    const buffer = bytes.buffer;\n    const offset = bytes.length;\n    bytes.reserve(5);\n    bytes.length += 5;\n    buffer[offset] = 0xdd;\n    buffer[offset + 1] = length >> 24;\n    buffer[offset + 2] = length >> 16;\n    buffer[offset + 3] = length >> 8;\n    buffer[offset + 4] = length;\n  }\n\n  _encodeByte(bytes, value) {\n    const buffer = bytes.buffer;\n    bytes.reserve(1);\n    buffer[bytes.length++] = value;\n  }\n\n  _encodeId(bytes, id) {\n    const buffer = bytes.buffer;\n    const offset = bytes.length;\n    bytes.reserve(9);\n    bytes.length += 9;\n    id = id.toArray();\n    buffer[offset] = 0xcf;\n    buffer[offset + 1] = id[0];\n    buffer[offset + 2] = id[1];\n    buffer[offset + 3] = id[2];\n    buffer[offset + 4] = id[3];\n    buffer[offset + 5] = id[4];\n    buffer[offset + 6] = id[5];\n    buffer[offset + 7] = id[6];\n    buffer[offset + 8] = id[7];\n  }\n\n  _encodeInteger(bytes, value) {\n    const buffer = bytes.buffer;\n    const offset = bytes.length;\n    bytes.reserve(5);\n    bytes.length += 5;\n    buffer[offset] = 0xce;\n    buffer[offset + 1] = value >> 24;\n    buffer[offset + 2] = value >> 16;\n    buffer[offset + 3] = value >> 8;\n    buffer[offset + 4] = value;\n  }\n\n  _encodeLong(bytes, value) {\n    const buffer = bytes.buffer;\n    const offset = bytes.length;\n    const hi = value / Math.pow(2, 32) >> 0;\n    const lo = value >>> 0;\n    bytes.reserve(9);\n    bytes.length += 9;\n    buffer[offset] = 0xcf;\n    buffer[offset + 1] = hi >> 24;\n    buffer[offset + 2] = hi >> 16;\n    buffer[offset + 3] = hi >> 8;\n    buffer[offset + 4] = hi;\n    buffer[offset + 5] = lo >> 24;\n    buffer[offset + 6] = lo >> 16;\n    buffer[offset + 7] = lo >> 8;\n    buffer[offset + 8] = lo;\n  }\n\n  _encodeMap(bytes, value) {\n    const keys = Object.keys(value);\n    const buffer = bytes.buffer;\n    const offset = bytes.length;\n    bytes.reserve(5);\n    bytes.length += 5;\n    let length = 0;\n\n    for (const key of keys) {\n      if (typeof value[key] !== 'string' && typeof value[key] !== 'number') return;\n      length++;\n\n      this._encodeString(bytes, key);\n\n      this._encodeValue(bytes, value[key]);\n    }\n\n    buffer[offset] = 0xdf;\n    buffer[offset + 1] = length >> 24;\n    buffer[offset + 2] = length >> 16;\n    buffer[offset + 3] = length >> 8;\n    buffer[offset + 4] = length;\n  }\n\n  _encodeValue(bytes, value) {\n    switch (typeof value) {\n      case 'string':\n        this._encodeString(bytes, value);\n\n        break;\n\n      case 'number':\n        this._encodeFloat(bytes, value);\n\n        break;\n\n      default: // should not happen\n\n    }\n  }\n\n  _encodeString(bytes, value = '') {\n    this._cacheString(value);\n\n    const {\n      start,\n      end\n    } = this._stringMap[value];\n\n    this._stringBytes.copy(bytes, start, end);\n  }\n\n  _encodeFloat(bytes, value) {\n    float64Array[0] = value;\n    const buffer = bytes.buffer;\n    const offset = bytes.length;\n    bytes.reserve(9);\n    bytes.length += 9;\n    buffer[offset] = 0xcb;\n\n    if (bigEndian) {\n      for (let i = 0; i <= 7; i++) {\n        buffer[offset + i + 1] = uInt8Float64Array[i];\n      }\n    } else {\n      for (let i = 7; i >= 0; i--) {\n        buffer[bytes.length - i - 1] = uInt8Float64Array[i];\n      }\n    }\n  }\n\n  _cacheString(value) {\n    if (!(value in this._stringMap)) {\n      this._stringCount++;\n      this._stringMap[value] = {\n        start: this._stringBytes.length,\n        end: this._stringBytes.length + this._stringBytes.write(value)\n      };\n    }\n  }\n\n  _writeArrayPrefix(buffer, offset, count) {\n    buffer[offset++] = 0xdd;\n    buffer.writeUInt32BE(count, offset);\n    return offset + 4;\n  }\n\n  _writeTraces(buffer, offset = 0) {\n    offset = this._writeArrayPrefix(buffer, offset, this._traceCount);\n    offset += this._traceBytes.buffer.copy(buffer, offset, 0, this._traceBytes.length);\n    return offset;\n  }\n\n}\n\nmodule.exports = {\n  AgentEncoder\n};","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/encode/0.4.js"],"names":["Chunk","require","log","SOFT_LIMIT","float64Array","Float64Array","uInt8Float64Array","Uint8Array","buffer","bigEndian","AgentEncoder","constructor","writer","_traceBytes","_stringBytes","_writer","_reset","count","_traceCount","encode","trace","bytes","start","length","_encode","end","debug","hex","subarray","toString","match","join","flush","makePayload","traceSize","Buffer","allocUnsafe","_writeTraces","_encodeArrayPrefix","span","reserve","type","_encodeString","_encodeId","trace_id","span_id","parent_id","name","resource","service","_encodeInteger","error","_encodeLong","duration","_encodeMap","meta","metrics","_stringCount","_stringMap","_cacheString","value","offset","_encodeByte","id","toArray","hi","Math","pow","lo","keys","Object","key","_encodeValue","_encodeFloat","copy","i","write","_writeArrayPrefix","writeUInt32BE","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Chunk = require('./chunk')\nconst log = require('../log')\n\nconst SOFT_LIMIT = 8 * 1024 * 1024 // 8MB\n\nconst float64Array = new Float64Array(1)\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer)\n\nfloat64Array[0] = -1\n\nconst bigEndian = uInt8Float64Array[7] === 0\n\nclass AgentEncoder {\n  constructor (writer) {\n    this._traceBytes = new Chunk()\n    this._stringBytes = new Chunk()\n    this._writer = writer\n    this._reset()\n  }\n\n  count () {\n    return this._traceCount\n  }\n\n  encode (trace) {\n    const bytes = this._traceBytes\n    const start = bytes.length\n\n    this._traceCount++\n\n    this._encode(bytes, trace)\n\n    const end = bytes.length\n\n    log.debug(() => {\n      const hex = bytes.buffer.subarray(start, end).toString('hex').match(/../g).join(' ')\n\n      return `Adding encoded trace to buffer: ${hex}`\n    })\n\n    // we can go over the soft limit since the agent has a 50MB hard limit\n    if (this._traceBytes.length > SOFT_LIMIT || this._stringBytes.length > SOFT_LIMIT) {\n      this._writer.flush()\n    }\n  }\n\n  makePayload () {\n    const traceSize = this._traceBytes.length + 5\n    const buffer = Buffer.allocUnsafe(traceSize)\n\n    this._writeTraces(buffer)\n\n    this._reset()\n\n    return buffer\n  }\n\n  _encode (bytes, trace) {\n    this._encodeArrayPrefix(bytes, trace)\n\n    for (const span of trace) {\n      bytes.reserve(1)\n\n      if (span.type) {\n        bytes.buffer[bytes.length++] = 0x8c\n\n        this._encodeString(bytes, 'type')\n        this._encodeString(bytes, span.type)\n      } else {\n        bytes.buffer[bytes.length++] = 0x8b\n      }\n\n      this._encodeString(bytes, 'trace_id')\n      this._encodeId(bytes, span.trace_id)\n      this._encodeString(bytes, 'span_id')\n      this._encodeId(bytes, span.span_id)\n      this._encodeString(bytes, 'parent_id')\n      this._encodeId(bytes, span.parent_id)\n      this._encodeString(bytes, 'name')\n      this._encodeString(bytes, span.name)\n      this._encodeString(bytes, 'resource')\n      this._encodeString(bytes, span.resource)\n      this._encodeString(bytes, 'service')\n      this._encodeString(bytes, span.service)\n      this._encodeString(bytes, 'error')\n      this._encodeInteger(bytes, span.error)\n      this._encodeString(bytes, 'start')\n      this._encodeLong(bytes, span.start)\n      this._encodeString(bytes, 'duration')\n      this._encodeLong(bytes, span.duration)\n      this._encodeString(bytes, 'meta')\n      this._encodeMap(bytes, span.meta)\n      this._encodeString(bytes, 'metrics')\n      this._encodeMap(bytes, span.metrics)\n    }\n  }\n\n  _reset () {\n    this._traceCount = 0\n    this._traceBytes.length = 0\n    this._stringCount = 0\n    this._stringBytes.length = 0\n    this._stringMap = {}\n\n    this._cacheString('')\n  }\n\n  _encodeArrayPrefix (bytes, value) {\n    const length = value.length\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    bytes.reserve(5)\n    bytes.length += 5\n\n    buffer[offset] = 0xdd\n    buffer[offset + 1] = length >> 24\n    buffer[offset + 2] = length >> 16\n    buffer[offset + 3] = length >> 8\n    buffer[offset + 4] = length\n  }\n\n  _encodeByte (bytes, value) {\n    const buffer = bytes.buffer\n\n    bytes.reserve(1)\n\n    buffer[bytes.length++] = value\n  }\n\n  _encodeId (bytes, id) {\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    bytes.reserve(9)\n    bytes.length += 9\n\n    id = id.toArray()\n\n    buffer[offset] = 0xcf\n    buffer[offset + 1] = id[0]\n    buffer[offset + 2] = id[1]\n    buffer[offset + 3] = id[2]\n    buffer[offset + 4] = id[3]\n    buffer[offset + 5] = id[4]\n    buffer[offset + 6] = id[5]\n    buffer[offset + 7] = id[6]\n    buffer[offset + 8] = id[7]\n  }\n\n  _encodeInteger (bytes, value) {\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    bytes.reserve(5)\n    bytes.length += 5\n\n    buffer[offset] = 0xce\n    buffer[offset + 1] = value >> 24\n    buffer[offset + 2] = value >> 16\n    buffer[offset + 3] = value >> 8\n    buffer[offset + 4] = value\n  }\n\n  _encodeLong (bytes, value) {\n    const buffer = bytes.buffer\n    const offset = bytes.length\n    const hi = (value / Math.pow(2, 32)) >> 0\n    const lo = value >>> 0\n\n    bytes.reserve(9)\n    bytes.length += 9\n\n    buffer[offset] = 0xcf\n    buffer[offset + 1] = hi >> 24\n    buffer[offset + 2] = hi >> 16\n    buffer[offset + 3] = hi >> 8\n    buffer[offset + 4] = hi\n    buffer[offset + 5] = lo >> 24\n    buffer[offset + 6] = lo >> 16\n    buffer[offset + 7] = lo >> 8\n    buffer[offset + 8] = lo\n  }\n\n  _encodeMap (bytes, value) {\n    const keys = Object.keys(value)\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    bytes.reserve(5)\n    bytes.length += 5\n\n    let length = 0\n\n    for (const key of keys) {\n      if (typeof value[key] !== 'string' && typeof value[key] !== 'number') return\n\n      length++\n\n      this._encodeString(bytes, key)\n      this._encodeValue(bytes, value[key])\n    }\n\n    buffer[offset] = 0xdf\n    buffer[offset + 1] = length >> 24\n    buffer[offset + 2] = length >> 16\n    buffer[offset + 3] = length >> 8\n    buffer[offset + 4] = length\n  }\n\n  _encodeValue (bytes, value) {\n    switch (typeof value) {\n      case 'string':\n        this._encodeString(bytes, value)\n        break\n      case 'number':\n        this._encodeFloat(bytes, value)\n        break\n      default:\n        // should not happen\n    }\n  }\n\n  _encodeString (bytes, value = '') {\n    this._cacheString(value)\n\n    const { start, end } = this._stringMap[value]\n\n    this._stringBytes.copy(bytes, start, end)\n  }\n\n  _encodeFloat (bytes, value) {\n    float64Array[0] = value\n\n    const buffer = bytes.buffer\n    const offset = bytes.length\n\n    bytes.reserve(9)\n    bytes.length += 9\n\n    buffer[offset] = 0xcb\n\n    if (bigEndian) {\n      for (let i = 0; i <= 7; i++) {\n        buffer[offset + i + 1] = uInt8Float64Array[i]\n      }\n    } else {\n      for (let i = 7; i >= 0; i--) {\n        buffer[bytes.length - i - 1] = uInt8Float64Array[i]\n      }\n    }\n  }\n\n  _cacheString (value) {\n    if (!(value in this._stringMap)) {\n      this._stringCount++\n      this._stringMap[value] = {\n        start: this._stringBytes.length,\n        end: this._stringBytes.length + this._stringBytes.write(value)\n      }\n    }\n  }\n\n  _writeArrayPrefix (buffer, offset, count) {\n    buffer[offset++] = 0xdd\n    buffer.writeUInt32BE(count, offset)\n\n    return offset + 4\n  }\n\n  _writeTraces (buffer, offset = 0) {\n    offset = this._writeArrayPrefix(buffer, offset, this._traceCount)\n    offset += this._traceBytes.buffer.copy(buffer, offset, 0, this._traceBytes.length)\n\n    return offset\n  }\n}\n\nmodule.exports = { AgentEncoder }\n"]},"metadata":{},"sourceType":"script"}