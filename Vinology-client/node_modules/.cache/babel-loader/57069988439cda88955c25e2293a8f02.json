{"ast":null,"code":"'use strict';\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler');\n\nfunction createWrapProducer(tracer, config) {\n  return function wrapProducer(createProducer) {\n    return function producerWithTrace() {\n      const serviceName = config.service || `${tracer._service}-kafka`;\n      const producer = createProducer.apply(this, arguments);\n      const send = producer.send;\n      const tags = {\n        'service.name': serviceName,\n        'span.kind': 'producer',\n        'component': 'kafkajs'\n      };\n      producer.send = tracer.wrap('kafka.produce', {\n        tags\n      }, function (...args) {\n        const {\n          topic,\n          messages = []\n        } = args[0];\n        const currentSpan = tracer.scope().active();\n        analyticsSampler.sample(currentSpan, config.measured);\n        currentSpan.addTags({\n          'resource.name': topic,\n          'kafka.topic': topic,\n          'kafka.batch_size': messages.length\n        });\n\n        for (const message of messages) {\n          message.headers = message.headers || {};\n          tracer.inject(currentSpan, 'text_map', message.headers);\n        }\n\n        return send.apply(this, args);\n      });\n      return producer;\n    };\n  };\n}\n\nfunction createWrapConsumer(tracer, config) {\n  return function wrapConsumer(createConsumer) {\n    return function consumerWithTrace() {\n      const serviceName = config.service || `${tracer._service}-kafka`;\n      const consumer = createConsumer.apply(this, arguments);\n      const run = consumer.run;\n      const tags = {\n        'service.name': serviceName,\n        'span.kind': 'consumer',\n        'span.type': 'worker',\n        'component': 'kafkajs'\n      };\n\n      consumer.run = function ({\n        eachMessage,\n        ...runArgs\n      }) {\n        if (typeof eachMessage !== 'function') return run({\n          eachMessage,\n          ...runArgs\n        });\n        return run({\n          eachMessage: function (...eachMessageArgs) {\n            const {\n              topic,\n              partition,\n              message\n            } = eachMessageArgs[0];\n            const childOf = extract(tracer, message.headers);\n            return tracer.trace('kafka.consume', {\n              childOf,\n              tags\n            }, () => {\n              const currentSpan = tracer.scope().active();\n              analyticsSampler.sample(currentSpan, config.measured, true);\n              currentSpan.addTags({\n                'resource.name': topic,\n                'kafka.topic': topic,\n                'kafka.partition': partition,\n                'kafka.message.offset': message.offset\n              });\n              return eachMessage.apply(this, eachMessageArgs);\n            });\n          },\n          ...runArgs\n        });\n      };\n\n      return consumer;\n    };\n  };\n}\n\nfunction extract(tracer, bufferMap) {\n  if (!bufferMap) return null;\n  const textMap = {};\n\n  for (const key of Object.keys(bufferMap)) {\n    textMap[key] = bufferMap[key].toString();\n  }\n\n  return tracer.extract('text_map', textMap);\n}\n\nmodule.exports = [{\n  name: 'kafkajs',\n  versions: ['>=1.4'],\n\n  patch({\n    Kafka\n  }, tracer, config) {\n    this.wrap(Kafka.prototype, 'producer', createWrapProducer(tracer, config));\n    this.wrap(Kafka.prototype, 'consumer', createWrapConsumer(tracer, config));\n  },\n\n  unpatch({\n    Kafka\n  }) {\n    this.unwrap(Kafka.prototype, 'producer');\n    this.unwrap(Kafka.prototype, 'consumer');\n  }\n\n}];","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-kafkajs/src/index.js"],"names":["analyticsSampler","require","createWrapProducer","tracer","config","wrapProducer","createProducer","producerWithTrace","serviceName","service","_service","producer","apply","arguments","send","tags","wrap","args","topic","messages","currentSpan","scope","active","sample","measured","addTags","length","message","headers","inject","createWrapConsumer","wrapConsumer","createConsumer","consumerWithTrace","consumer","run","eachMessage","runArgs","eachMessageArgs","partition","childOf","extract","trace","offset","bufferMap","textMap","key","Object","keys","toString","module","exports","name","versions","patch","Kafka","prototype","unpatch","unwrap"],"mappings":"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","sourcesContent":["'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\n\nfunction createWrapProducer (tracer, config) {\n  return function wrapProducer (createProducer) {\n    return function producerWithTrace () {\n      const serviceName = config.service || `${tracer._service}-kafka`\n      const producer = createProducer.apply(this, arguments)\n\n      const send = producer.send\n\n      const tags = {\n        'service.name': serviceName,\n        'span.kind': 'producer',\n        'component': 'kafkajs'\n      }\n\n      producer.send = tracer.wrap('kafka.produce', { tags }, function (...args) {\n        const { topic, messages = [] } = args[0]\n        const currentSpan = tracer.scope().active()\n\n        analyticsSampler.sample(currentSpan, config.measured)\n\n        currentSpan.addTags({\n          'resource.name': topic,\n          'kafka.topic': topic,\n          'kafka.batch_size': messages.length\n        })\n\n        for (const message of messages) {\n          message.headers = message.headers || {}\n          tracer.inject(currentSpan, 'text_map', message.headers)\n        }\n\n        return send.apply(this, args)\n      })\n\n      return producer\n    }\n  }\n}\n\nfunction createWrapConsumer (tracer, config) {\n  return function wrapConsumer (createConsumer) {\n    return function consumerWithTrace () {\n      const serviceName = config.service || `${tracer._service}-kafka`\n      const consumer = createConsumer.apply(this, arguments)\n      const run = consumer.run\n\n      const tags = {\n        'service.name': serviceName,\n        'span.kind': 'consumer',\n        'span.type': 'worker',\n        'component': 'kafkajs'\n      }\n\n      consumer.run = function ({ eachMessage, ...runArgs }) {\n        if (typeof eachMessage !== 'function') return run({ eachMessage, ...runArgs })\n\n        return run({\n          eachMessage: function (...eachMessageArgs) {\n            const { topic, partition, message } = eachMessageArgs[0]\n            const childOf = extract(tracer, message.headers)\n\n            return tracer.trace('kafka.consume', { childOf, tags }, () => {\n              const currentSpan = tracer.scope().active()\n\n              analyticsSampler.sample(currentSpan, config.measured, true)\n\n              currentSpan.addTags({\n                'resource.name': topic,\n                'kafka.topic': topic,\n                'kafka.partition': partition,\n                'kafka.message.offset': message.offset\n              })\n\n              return eachMessage.apply(this, eachMessageArgs)\n            })\n          },\n          ...runArgs\n        })\n      }\n\n      return consumer\n    }\n  }\n}\n\nfunction extract (tracer, bufferMap) {\n  if (!bufferMap) return null\n\n  const textMap = {}\n\n  for (const key of Object.keys(bufferMap)) {\n    textMap[key] = bufferMap[key].toString()\n  }\n\n  return tracer.extract('text_map', textMap)\n}\n\nmodule.exports = [\n  {\n    name: 'kafkajs',\n    versions: ['>=1.4'],\n    patch ({ Kafka }, tracer, config) {\n      this.wrap(\n        Kafka.prototype,\n        'producer',\n        createWrapProducer(tracer, config)\n      )\n      this.wrap(\n        Kafka.prototype,\n        'consumer',\n        createWrapConsumer(tracer, config)\n      )\n    },\n    unpatch ({ Kafka }) {\n      this.unwrap(Kafka.prototype, 'producer')\n      this.unwrap(Kafka.prototype, 'consumer')\n    }\n  }\n]\n"]},"metadata":{},"sourceType":"script"}