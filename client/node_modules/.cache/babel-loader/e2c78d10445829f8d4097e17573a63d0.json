{"ast":null,"code":"'use strict';\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler');\n\nconst tx = require('../../dd-trace/src/plugins/util/tx');\n\nconst rrtypes = {\n  resolveAny: 'ANY',\n  resolve4: 'A',\n  resolve6: 'AAAA',\n  resolveCname: 'CNAME',\n  resolveMx: 'MX',\n  resolveNs: 'NS',\n  resolveTxt: 'TXT',\n  resolveSrv: 'SRV',\n  resolvePtr: 'PTR',\n  resolveNaptr: 'NAPTR',\n  resolveSoa: 'SOA'\n};\n\nfunction createWrapLookup(tracer, config) {\n  return function wrapLookup(lookup) {\n    return function lookupWithTrace(hostname, options, callback) {\n      if (!isArgsValid(arguments, 2)) return lookup.apply(this, arguments);\n      const span = startSpan(tracer, config, 'dns.lookup', {\n        'resource.name': hostname,\n        'dns.hostname': hostname\n      });\n      wrapArgs(span, arguments, (e, address) => {\n        span.setTag('dns.address', address);\n      });\n      return tracer.scope().activate(span, () => lookup.apply(this, arguments));\n    };\n  };\n}\n\nfunction createWrapLookupService(tracer, config) {\n  return function wrapLookupService(lookupService) {\n    return function lookupServiceWithTrace(address, port, callback) {\n      if (!isArgsValid(arguments, 3)) return lookupService.apply(this, arguments);\n      const span = startSpan(tracer, config, 'dns.lookup_service', {\n        'resource.name': `${address}:${port}`,\n        'dns.address': address,\n        'dns.port': port\n      });\n      wrapArgs(span, arguments);\n      return tracer.scope().activate(span, () => lookupService.apply(this, arguments));\n    };\n  };\n}\n\nfunction createWrapResolve(tracer, config) {\n  return function wrapResolve(resolve) {\n    return function resolveWithTrace(hostname, rrtype, callback) {\n      if (!isArgsValid(arguments, 2)) return resolve.apply(this, arguments);\n\n      if (typeof rrtype !== 'string') {\n        rrtype = 'A';\n      }\n\n      const span = wrapResolver(tracer, config, rrtype, arguments);\n      return tracer.scope().activate(span, () => resolve.apply(this, arguments));\n    };\n  };\n}\n\nfunction createWrapResolver(tracer, config, rrtype) {\n  return function wrapResolve(resolve) {\n    return function resolveWithTrace(hostname, callback) {\n      if (!isArgsValid(arguments, 2)) return resolve.apply(this, arguments);\n      const span = wrapResolver(tracer, config, rrtype, arguments);\n      return tracer.scope().activate(span, () => resolve.apply(this, arguments));\n    };\n  };\n}\n\nfunction createWrapReverse(tracer, config) {\n  return function wrapReverse(reverse) {\n    return function reverseWithTrace(ip, callback) {\n      if (!isArgsValid(arguments, 2)) return reverse.apply(this, arguments);\n      const span = startSpan(tracer, config, 'dns.reverse', {\n        'resource.name': ip,\n        'dns.ip': ip\n      });\n      wrapArgs(span, arguments);\n      return tracer.scope().activate(span, () => reverse.apply(this, arguments));\n    };\n  };\n}\n\nfunction startSpan(tracer, config, operation, tags) {\n  const childOf = tracer.scope().active();\n  const span = tracer.startSpan(operation, {\n    childOf,\n    tags: Object.assign({\n      'service.name': config.service || tracer._service,\n      'span.kind': 'client'\n    }, tags)\n  });\n  analyticsSampler.sample(span, config.measured);\n  return span;\n}\n\nfunction isArgsValid(args, minLength) {\n  if (args.length < minLength) return false;\n  if (typeof args[args.length - 1] !== 'function') return false;\n  return true;\n}\n\nfunction wrapArgs(span, args, callback) {\n  const original = args[args.length - 1];\n  const fn = tx.wrap(span, original);\n\n  args[args.length - 1] = function () {\n    callback && callback.apply(null, arguments);\n    return fn.apply(this, arguments);\n  };\n}\n\nfunction wrapResolver(tracer, config, rrtype, args) {\n  const hostname = args[0];\n  const span = startSpan(tracer, config, 'dns.resolve', {\n    'resource.name': `${rrtype} ${hostname}`,\n    'dns.hostname': hostname,\n    'dns.rrtype': rrtype\n  });\n  wrapArgs(span, args);\n  return span;\n}\n\nfunction patchResolveShorthands(tracer, config, shim, prototype) {\n  Object.keys(rrtypes).filter(method => !!prototype[method]).forEach(method => {\n    shim.wrap(prototype, method, createWrapResolver(tracer, config, rrtypes[method]));\n  });\n}\n\nfunction unpatchResolveShorthands(shim, prototype) {\n  Object.keys(rrtypes).filter(method => !!prototype[method]).forEach(method => {\n    shim.unwrap(prototype, method);\n  });\n}\n\nmodule.exports = [{\n  name: 'dns',\n\n  patch(dns, tracer, config) {\n    this.wrap(dns, 'lookup', createWrapLookup(tracer, config));\n    this.wrap(dns, 'lookupService', createWrapLookupService(tracer, config));\n    this.wrap(dns, 'resolve', createWrapResolve(tracer, config));\n    this.wrap(dns, 'reverse', createWrapReverse(tracer, config));\n    patchResolveShorthands(tracer, config, this, dns);\n\n    if (dns.Resolver) {\n      this.wrap(dns.Resolver.prototype, 'resolve', createWrapResolve(tracer, config));\n      this.wrap(dns.Resolver.prototype, 'reverse', createWrapReverse(tracer, config));\n      patchResolveShorthands(tracer, config, this, dns.Resolver.prototype);\n    }\n  },\n\n  unpatch(dns) {\n    this.unwrap(dns, ['lookup', 'lookupService', 'resolve', 'reverse']);\n    unpatchResolveShorthands(this, dns);\n\n    if (dns.Resolver) {\n      this.unwrap(dns.prototype.Resolver, ['resolve', 'reverse']);\n      unpatchResolveShorthands(this, dns.Resolver.prototype);\n    }\n  }\n\n}];","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-dns/src/index.js"],"names":["analyticsSampler","require","tx","rrtypes","resolveAny","resolve4","resolve6","resolveCname","resolveMx","resolveNs","resolveTxt","resolveSrv","resolvePtr","resolveNaptr","resolveSoa","createWrapLookup","tracer","config","wrapLookup","lookup","lookupWithTrace","hostname","options","callback","isArgsValid","arguments","apply","span","startSpan","wrapArgs","e","address","setTag","scope","activate","createWrapLookupService","wrapLookupService","lookupService","lookupServiceWithTrace","port","createWrapResolve","wrapResolve","resolve","resolveWithTrace","rrtype","wrapResolver","createWrapResolver","createWrapReverse","wrapReverse","reverse","reverseWithTrace","ip","operation","tags","childOf","active","Object","assign","service","_service","sample","measured","args","minLength","length","original","fn","wrap","patchResolveShorthands","shim","prototype","keys","filter","method","forEach","unpatchResolveShorthands","unwrap","module","exports","name","patch","dns","Resolver","unpatch"],"mappings":"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","sourcesContent":["'use strict'\n\nconst analyticsSampler = require('../../dd-trace/src/analytics_sampler')\nconst tx = require('../../dd-trace/src/plugins/util/tx')\n\nconst rrtypes = {\n  resolveAny: 'ANY',\n  resolve4: 'A',\n  resolve6: 'AAAA',\n  resolveCname: 'CNAME',\n  resolveMx: 'MX',\n  resolveNs: 'NS',\n  resolveTxt: 'TXT',\n  resolveSrv: 'SRV',\n  resolvePtr: 'PTR',\n  resolveNaptr: 'NAPTR',\n  resolveSoa: 'SOA'\n}\n\nfunction createWrapLookup (tracer, config) {\n  return function wrapLookup (lookup) {\n    return function lookupWithTrace (hostname, options, callback) {\n      if (!isArgsValid(arguments, 2)) return lookup.apply(this, arguments)\n\n      const span = startSpan(tracer, config, 'dns.lookup', {\n        'resource.name': hostname,\n        'dns.hostname': hostname\n      })\n\n      wrapArgs(span, arguments, (e, address) => {\n        span.setTag('dns.address', address)\n      })\n\n      return tracer.scope().activate(span, () => lookup.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapLookupService (tracer, config) {\n  return function wrapLookupService (lookupService) {\n    return function lookupServiceWithTrace (address, port, callback) {\n      if (!isArgsValid(arguments, 3)) return lookupService.apply(this, arguments)\n\n      const span = startSpan(tracer, config, 'dns.lookup_service', {\n        'resource.name': `${address}:${port}`,\n        'dns.address': address,\n        'dns.port': port\n      })\n\n      wrapArgs(span, arguments)\n\n      return tracer.scope().activate(span, () => lookupService.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapResolve (tracer, config) {\n  return function wrapResolve (resolve) {\n    return function resolveWithTrace (hostname, rrtype, callback) {\n      if (!isArgsValid(arguments, 2)) return resolve.apply(this, arguments)\n\n      if (typeof rrtype !== 'string') {\n        rrtype = 'A'\n      }\n\n      const span = wrapResolver(tracer, config, rrtype, arguments)\n\n      return tracer.scope().activate(span, () => resolve.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapResolver (tracer, config, rrtype) {\n  return function wrapResolve (resolve) {\n    return function resolveWithTrace (hostname, callback) {\n      if (!isArgsValid(arguments, 2)) return resolve.apply(this, arguments)\n\n      const span = wrapResolver(tracer, config, rrtype, arguments)\n\n      return tracer.scope().activate(span, () => resolve.apply(this, arguments))\n    }\n  }\n}\n\nfunction createWrapReverse (tracer, config) {\n  return function wrapReverse (reverse) {\n    return function reverseWithTrace (ip, callback) {\n      if (!isArgsValid(arguments, 2)) return reverse.apply(this, arguments)\n\n      const span = startSpan(tracer, config, 'dns.reverse', {\n        'resource.name': ip,\n        'dns.ip': ip\n      })\n\n      wrapArgs(span, arguments)\n\n      return tracer.scope().activate(span, () => reverse.apply(this, arguments))\n    }\n  }\n}\n\nfunction startSpan (tracer, config, operation, tags) {\n  const childOf = tracer.scope().active()\n  const span = tracer.startSpan(operation, {\n    childOf,\n    tags: Object.assign({\n      'service.name': config.service || tracer._service,\n      'span.kind': 'client'\n    }, tags)\n  })\n\n  analyticsSampler.sample(span, config.measured)\n\n  return span\n}\n\nfunction isArgsValid (args, minLength) {\n  if (args.length < minLength) return false\n  if (typeof args[args.length - 1] !== 'function') return false\n\n  return true\n}\n\nfunction wrapArgs (span, args, callback) {\n  const original = args[args.length - 1]\n  const fn = tx.wrap(span, original)\n\n  args[args.length - 1] = function () {\n    callback && callback.apply(null, arguments)\n    return fn.apply(this, arguments)\n  }\n}\n\nfunction wrapResolver (tracer, config, rrtype, args) {\n  const hostname = args[0]\n  const span = startSpan(tracer, config, 'dns.resolve', {\n    'resource.name': `${rrtype} ${hostname}`,\n    'dns.hostname': hostname,\n    'dns.rrtype': rrtype\n  })\n\n  wrapArgs(span, args)\n\n  return span\n}\n\nfunction patchResolveShorthands (tracer, config, shim, prototype) {\n  Object.keys(rrtypes)\n    .filter(method => !!prototype[method])\n    .forEach(method => {\n      shim.wrap(prototype, method, createWrapResolver(tracer, config, rrtypes[method]))\n    })\n}\n\nfunction unpatchResolveShorthands (shim, prototype) {\n  Object.keys(rrtypes)\n    .filter(method => !!prototype[method])\n    .forEach(method => {\n      shim.unwrap(prototype, method)\n    })\n}\n\nmodule.exports = [\n  {\n    name: 'dns',\n    patch (dns, tracer, config) {\n      this.wrap(dns, 'lookup', createWrapLookup(tracer, config))\n      this.wrap(dns, 'lookupService', createWrapLookupService(tracer, config))\n      this.wrap(dns, 'resolve', createWrapResolve(tracer, config))\n      this.wrap(dns, 'reverse', createWrapReverse(tracer, config))\n\n      patchResolveShorthands(tracer, config, this, dns)\n\n      if (dns.Resolver) {\n        this.wrap(dns.Resolver.prototype, 'resolve', createWrapResolve(tracer, config))\n        this.wrap(dns.Resolver.prototype, 'reverse', createWrapReverse(tracer, config))\n\n        patchResolveShorthands(tracer, config, this, dns.Resolver.prototype)\n      }\n    },\n    unpatch (dns) {\n      this.unwrap(dns, [\n        'lookup',\n        'lookupService',\n        'resolve',\n        'reverse'\n      ])\n\n      unpatchResolveShorthands(this, dns)\n\n      if (dns.Resolver) {\n        this.unwrap(dns.prototype.Resolver, [\n          'resolve',\n          'reverse'\n        ])\n\n        unpatchResolveShorthands(this, dns.Resolver.prototype)\n      }\n    }\n  }\n]\n"]},"metadata":{},"sourceType":"script"}