{"ast":null,"code":"/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\n\nvar $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nvar $Reader = $protobuf.Reader,\n    $Writer = $protobuf.Writer,\n    $util = $protobuf.util; // Exported root namespace\n\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n$root.DDSketch = function () {\n  /**\n   * Properties of a DDSketch.\n   * @exports IDDSketch\n   * @interface IDDSketch\n   * @property {IIndexMapping|null} [mapping] DDSketch mapping\n   * @property {IStore|null} [positiveValues] DDSketch positiveValues\n   * @property {IStore|null} [negativeValues] DDSketch negativeValues\n   * @property {number|null} [zeroCount] DDSketch zeroCount\n   */\n\n  /**\n   * Constructs a new DDSketch.\n   * @exports DDSketch\n   * @classdesc Represents a DDSketch.\n   * @implements IDDSketch\n   * @constructor\n   * @param {IDDSketch=} [properties] Properties to set\n   */\n  function DDSketch(properties) {\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * DDSketch mapping.\n   * @member {IIndexMapping|null|undefined} mapping\n   * @memberof DDSketch\n   * @instance\n   */\n\n\n  DDSketch.prototype.mapping = null;\n  /**\n   * DDSketch positiveValues.\n   * @member {IStore|null|undefined} positiveValues\n   * @memberof DDSketch\n   * @instance\n   */\n\n  DDSketch.prototype.positiveValues = null;\n  /**\n   * DDSketch negativeValues.\n   * @member {IStore|null|undefined} negativeValues\n   * @memberof DDSketch\n   * @instance\n   */\n\n  DDSketch.prototype.negativeValues = null;\n  /**\n   * DDSketch zeroCount.\n   * @member {number} zeroCount\n   * @memberof DDSketch\n   * @instance\n   */\n\n  DDSketch.prototype.zeroCount = 0;\n  /**\n   * Creates a new DDSketch instance using the specified properties.\n   * @function create\n   * @memberof DDSketch\n   * @static\n   * @param {IDDSketch=} [properties] Properties to set\n   * @returns {DDSketch} DDSketch instance\n   */\n\n  DDSketch.create = function create(properties) {\n    return new DDSketch(properties);\n  };\n  /**\n   * Encodes the specified DDSketch message. Does not implicitly {@link DDSketch.verify|verify} messages.\n   * @function encode\n   * @memberof DDSketch\n   * @static\n   * @param {IDDSketch} message DDSketch message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  DDSketch.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.mapping != null && Object.hasOwnProperty.call(message, \"mapping\")) $root.IndexMapping.encode(message.mapping, writer.uint32(\n    /* id 1, wireType 2 =*/\n    10).fork()).ldelim();\n    if (message.positiveValues != null && Object.hasOwnProperty.call(message, \"positiveValues\")) $root.Store.encode(message.positiveValues, writer.uint32(\n    /* id 2, wireType 2 =*/\n    18).fork()).ldelim();\n    if (message.negativeValues != null && Object.hasOwnProperty.call(message, \"negativeValues\")) $root.Store.encode(message.negativeValues, writer.uint32(\n    /* id 3, wireType 2 =*/\n    26).fork()).ldelim();\n    if (message.zeroCount != null && Object.hasOwnProperty.call(message, \"zeroCount\")) writer.uint32(\n    /* id 4, wireType 1 =*/\n    33).double(message.zeroCount);\n    return writer;\n  };\n  /**\n   * Encodes the specified DDSketch message, length delimited. Does not implicitly {@link DDSketch.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof DDSketch\n   * @static\n   * @param {IDDSketch} message DDSketch message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  DDSketch.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a DDSketch message from the specified reader or buffer.\n   * @function decode\n   * @memberof DDSketch\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {DDSketch} DDSketch\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  DDSketch.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.DDSketch();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.mapping = $root.IndexMapping.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.positiveValues = $root.Store.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.negativeValues = $root.Store.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.zeroCount = reader.double();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a DDSketch message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof DDSketch\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {DDSketch} DDSketch\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  DDSketch.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a DDSketch message.\n   * @function verify\n   * @memberof DDSketch\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  DDSketch.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.mapping != null && message.hasOwnProperty(\"mapping\")) {\n      var error = $root.IndexMapping.verify(message.mapping);\n      if (error) return \"mapping.\" + error;\n    }\n\n    if (message.positiveValues != null && message.hasOwnProperty(\"positiveValues\")) {\n      var error = $root.Store.verify(message.positiveValues);\n      if (error) return \"positiveValues.\" + error;\n    }\n\n    if (message.negativeValues != null && message.hasOwnProperty(\"negativeValues\")) {\n      var error = $root.Store.verify(message.negativeValues);\n      if (error) return \"negativeValues.\" + error;\n    }\n\n    if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\")) if (typeof message.zeroCount !== \"number\") return \"zeroCount: number expected\";\n    return null;\n  };\n  /**\n   * Creates a DDSketch message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof DDSketch\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {DDSketch} DDSketch\n   */\n\n\n  DDSketch.fromObject = function fromObject(object) {\n    if (object instanceof $root.DDSketch) return object;\n    var message = new $root.DDSketch();\n\n    if (object.mapping != null) {\n      if (typeof object.mapping !== \"object\") throw TypeError(\".DDSketch.mapping: object expected\");\n      message.mapping = $root.IndexMapping.fromObject(object.mapping);\n    }\n\n    if (object.positiveValues != null) {\n      if (typeof object.positiveValues !== \"object\") throw TypeError(\".DDSketch.positiveValues: object expected\");\n      message.positiveValues = $root.Store.fromObject(object.positiveValues);\n    }\n\n    if (object.negativeValues != null) {\n      if (typeof object.negativeValues !== \"object\") throw TypeError(\".DDSketch.negativeValues: object expected\");\n      message.negativeValues = $root.Store.fromObject(object.negativeValues);\n    }\n\n    if (object.zeroCount != null) message.zeroCount = Number(object.zeroCount);\n    return message;\n  };\n  /**\n   * Creates a plain object from a DDSketch message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof DDSketch\n   * @static\n   * @param {DDSketch} message DDSketch\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  DDSketch.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n\n    if (options.defaults) {\n      object.mapping = null;\n      object.positiveValues = null;\n      object.negativeValues = null;\n      object.zeroCount = 0;\n    }\n\n    if (message.mapping != null && message.hasOwnProperty(\"mapping\")) object.mapping = $root.IndexMapping.toObject(message.mapping, options);\n    if (message.positiveValues != null && message.hasOwnProperty(\"positiveValues\")) object.positiveValues = $root.Store.toObject(message.positiveValues, options);\n    if (message.negativeValues != null && message.hasOwnProperty(\"negativeValues\")) object.negativeValues = $root.Store.toObject(message.negativeValues, options);\n    if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\")) object.zeroCount = options.json && !isFinite(message.zeroCount) ? String(message.zeroCount) : message.zeroCount;\n    return object;\n  };\n  /**\n   * Converts this DDSketch to JSON.\n   * @function toJSON\n   * @memberof DDSketch\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  DDSketch.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return DDSketch;\n}();\n\n$root.IndexMapping = function () {\n  /**\n   * Properties of an IndexMapping.\n   * @exports IIndexMapping\n   * @interface IIndexMapping\n   * @property {number|null} [gamma] IndexMapping gamma\n   * @property {number|null} [indexOffset] IndexMapping indexOffset\n   * @property {IndexMapping.Interpolation|null} [interpolation] IndexMapping interpolation\n   */\n\n  /**\n   * Constructs a new IndexMapping.\n   * @exports IndexMapping\n   * @classdesc Represents an IndexMapping.\n   * @implements IIndexMapping\n   * @constructor\n   * @param {IIndexMapping=} [properties] Properties to set\n   */\n  function IndexMapping(properties) {\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * IndexMapping gamma.\n   * @member {number} gamma\n   * @memberof IndexMapping\n   * @instance\n   */\n\n\n  IndexMapping.prototype.gamma = 0;\n  /**\n   * IndexMapping indexOffset.\n   * @member {number} indexOffset\n   * @memberof IndexMapping\n   * @instance\n   */\n\n  IndexMapping.prototype.indexOffset = 0;\n  /**\n   * IndexMapping interpolation.\n   * @member {IndexMapping.Interpolation} interpolation\n   * @memberof IndexMapping\n   * @instance\n   */\n\n  IndexMapping.prototype.interpolation = 0;\n  /**\n   * Creates a new IndexMapping instance using the specified properties.\n   * @function create\n   * @memberof IndexMapping\n   * @static\n   * @param {IIndexMapping=} [properties] Properties to set\n   * @returns {IndexMapping} IndexMapping instance\n   */\n\n  IndexMapping.create = function create(properties) {\n    return new IndexMapping(properties);\n  };\n  /**\n   * Encodes the specified IndexMapping message. Does not implicitly {@link IndexMapping.verify|verify} messages.\n   * @function encode\n   * @memberof IndexMapping\n   * @static\n   * @param {IIndexMapping} message IndexMapping message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  IndexMapping.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.gamma != null && Object.hasOwnProperty.call(message, \"gamma\")) writer.uint32(\n    /* id 1, wireType 1 =*/\n    9).double(message.gamma);\n    if (message.indexOffset != null && Object.hasOwnProperty.call(message, \"indexOffset\")) writer.uint32(\n    /* id 2, wireType 1 =*/\n    17).double(message.indexOffset);\n    if (message.interpolation != null && Object.hasOwnProperty.call(message, \"interpolation\")) writer.uint32(\n    /* id 3, wireType 0 =*/\n    24).int32(message.interpolation);\n    return writer;\n  };\n  /**\n   * Encodes the specified IndexMapping message, length delimited. Does not implicitly {@link IndexMapping.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof IndexMapping\n   * @static\n   * @param {IIndexMapping} message IndexMapping message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  IndexMapping.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes an IndexMapping message from the specified reader or buffer.\n   * @function decode\n   * @memberof IndexMapping\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {IndexMapping} IndexMapping\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  IndexMapping.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.IndexMapping();\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.gamma = reader.double();\n          break;\n\n        case 2:\n          message.indexOffset = reader.double();\n          break;\n\n        case 3:\n          message.interpolation = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes an IndexMapping message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof IndexMapping\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {IndexMapping} IndexMapping\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  IndexMapping.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies an IndexMapping message.\n   * @function verify\n   * @memberof IndexMapping\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  IndexMapping.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n    if (message.gamma != null && message.hasOwnProperty(\"gamma\")) if (typeof message.gamma !== \"number\") return \"gamma: number expected\";\n    if (message.indexOffset != null && message.hasOwnProperty(\"indexOffset\")) if (typeof message.indexOffset !== \"number\") return \"indexOffset: number expected\";\n    if (message.interpolation != null && message.hasOwnProperty(\"interpolation\")) switch (message.interpolation) {\n      default:\n        return \"interpolation: enum value expected\";\n\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n        break;\n    }\n    return null;\n  };\n  /**\n   * Creates an IndexMapping message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof IndexMapping\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {IndexMapping} IndexMapping\n   */\n\n\n  IndexMapping.fromObject = function fromObject(object) {\n    if (object instanceof $root.IndexMapping) return object;\n    var message = new $root.IndexMapping();\n    if (object.gamma != null) message.gamma = Number(object.gamma);\n    if (object.indexOffset != null) message.indexOffset = Number(object.indexOffset);\n\n    switch (object.interpolation) {\n      case \"NONE\":\n      case 0:\n        message.interpolation = 0;\n        break;\n\n      case \"LINEAR\":\n      case 1:\n        message.interpolation = 1;\n        break;\n\n      case \"QUADRATIC\":\n      case 2:\n        message.interpolation = 2;\n        break;\n\n      case \"CUBIC\":\n      case 3:\n        message.interpolation = 3;\n        break;\n    }\n\n    return message;\n  };\n  /**\n   * Creates a plain object from an IndexMapping message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof IndexMapping\n   * @static\n   * @param {IndexMapping} message IndexMapping\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  IndexMapping.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n\n    if (options.defaults) {\n      object.gamma = 0;\n      object.indexOffset = 0;\n      object.interpolation = options.enums === String ? \"NONE\" : 0;\n    }\n\n    if (message.gamma != null && message.hasOwnProperty(\"gamma\")) object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;\n    if (message.indexOffset != null && message.hasOwnProperty(\"indexOffset\")) object.indexOffset = options.json && !isFinite(message.indexOffset) ? String(message.indexOffset) : message.indexOffset;\n    if (message.interpolation != null && message.hasOwnProperty(\"interpolation\")) object.interpolation = options.enums === String ? $root.IndexMapping.Interpolation[message.interpolation] : message.interpolation;\n    return object;\n  };\n  /**\n   * Converts this IndexMapping to JSON.\n   * @function toJSON\n   * @memberof IndexMapping\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  IndexMapping.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n  /**\n   * Interpolation enum.\n   * @name IndexMapping.Interpolation\n   * @enum {number}\n   * @property {number} NONE=0 NONE value\n   * @property {number} LINEAR=1 LINEAR value\n   * @property {number} QUADRATIC=2 QUADRATIC value\n   * @property {number} CUBIC=3 CUBIC value\n   */\n\n\n  IndexMapping.Interpolation = function () {\n    var valuesById = {},\n        values = Object.create(valuesById);\n    values[valuesById[0] = \"NONE\"] = 0;\n    values[valuesById[1] = \"LINEAR\"] = 1;\n    values[valuesById[2] = \"QUADRATIC\"] = 2;\n    values[valuesById[3] = \"CUBIC\"] = 3;\n    return values;\n  }();\n\n  return IndexMapping;\n}();\n\n$root.Store = function () {\n  /**\n   * Properties of a Store.\n   * @exports IStore\n   * @interface IStore\n   * @property {Object.<string,number>|null} [binCounts] Store binCounts\n   * @property {Array.<number>|null} [contiguousBinCounts] Store contiguousBinCounts\n   * @property {number|null} [contiguousBinIndexOffset] Store contiguousBinIndexOffset\n   */\n\n  /**\n   * Constructs a new Store.\n   * @exports Store\n   * @classdesc Represents a Store.\n   * @implements IStore\n   * @constructor\n   * @param {IStore=} [properties] Properties to set\n   */\n  function Store(properties) {\n    this.binCounts = {};\n    this.contiguousBinCounts = [];\n    if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Store binCounts.\n   * @member {Object.<string,number>} binCounts\n   * @memberof Store\n   * @instance\n   */\n\n\n  Store.prototype.binCounts = $util.emptyObject;\n  /**\n   * Store contiguousBinCounts.\n   * @member {Array.<number>} contiguousBinCounts\n   * @memberof Store\n   * @instance\n   */\n\n  Store.prototype.contiguousBinCounts = $util.emptyArray;\n  /**\n   * Store contiguousBinIndexOffset.\n   * @member {number} contiguousBinIndexOffset\n   * @memberof Store\n   * @instance\n   */\n\n  Store.prototype.contiguousBinIndexOffset = 0;\n  /**\n   * Creates a new Store instance using the specified properties.\n   * @function create\n   * @memberof Store\n   * @static\n   * @param {IStore=} [properties] Properties to set\n   * @returns {Store} Store instance\n   */\n\n  Store.create = function create(properties) {\n    return new Store(properties);\n  };\n  /**\n   * Encodes the specified Store message. Does not implicitly {@link Store.verify|verify} messages.\n   * @function encode\n   * @memberof Store\n   * @static\n   * @param {IStore} message Store message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Store.encode = function encode(message, writer) {\n    if (!writer) writer = $Writer.create();\n    if (message.binCounts != null && Object.hasOwnProperty.call(message, \"binCounts\")) for (var keys = Object.keys(message.binCounts), i = 0; i < keys.length; ++i) writer.uint32(\n    /* id 1, wireType 2 =*/\n    10).fork().uint32(\n    /* id 1, wireType 0 =*/\n    8).sint32(keys[i]).uint32(\n    /* id 2, wireType 1 =*/\n    17).double(message.binCounts[keys[i]]).ldelim();\n\n    if (message.contiguousBinCounts != null && message.contiguousBinCounts.length) {\n      writer.uint32(\n      /* id 2, wireType 2 =*/\n      18).fork();\n\n      for (var i = 0; i < message.contiguousBinCounts.length; ++i) writer.double(message.contiguousBinCounts[i]);\n\n      writer.ldelim();\n    }\n\n    if (message.contiguousBinIndexOffset != null && Object.hasOwnProperty.call(message, \"contiguousBinIndexOffset\")) writer.uint32(\n    /* id 3, wireType 0 =*/\n    24).sint32(message.contiguousBinIndexOffset);\n    return writer;\n  };\n  /**\n   * Encodes the specified Store message, length delimited. Does not implicitly {@link Store.verify|verify} messages.\n   * @function encodeDelimited\n   * @memberof Store\n   * @static\n   * @param {IStore} message Store message or plain object to encode\n   * @param {$protobuf.Writer} [writer] Writer to encode to\n   * @returns {$protobuf.Writer} Writer\n   */\n\n\n  Store.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer).ldelim();\n  };\n  /**\n   * Decodes a Store message from the specified reader or buffer.\n   * @function decode\n   * @memberof Store\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {Store} Store\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Store.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    var end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.Store(),\n        key,\n        value;\n\n    while (reader.pos < end) {\n      var tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (message.binCounts === $util.emptyObject) message.binCounts = {};\n          var end2 = reader.uint32() + reader.pos;\n          key = 0;\n          value = 0;\n\n          while (reader.pos < end2) {\n            var tag2 = reader.uint32();\n\n            switch (tag2 >>> 3) {\n              case 1:\n                key = reader.sint32();\n                break;\n\n              case 2:\n                value = reader.double();\n                break;\n\n              default:\n                reader.skipType(tag2 & 7);\n                break;\n            }\n          }\n\n          message.binCounts[key] = value;\n          break;\n\n        case 2:\n          if (!(message.contiguousBinCounts && message.contiguousBinCounts.length)) message.contiguousBinCounts = [];\n\n          if ((tag & 7) === 2) {\n            var end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.contiguousBinCounts.push(reader.double());\n          } else message.contiguousBinCounts.push(reader.double());\n\n          break;\n\n        case 3:\n          message.contiguousBinIndexOffset = reader.sint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * Decodes a Store message from the specified reader or buffer, length delimited.\n   * @function decodeDelimited\n   * @memberof Store\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @returns {Store} Store\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  Store.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n    return this.decode(reader, reader.uint32());\n  };\n  /**\n   * Verifies a Store message.\n   * @function verify\n   * @memberof Store\n   * @static\n   * @param {Object.<string,*>} message Plain object to verify\n   * @returns {string|null} `null` if valid, otherwise the reason why it is not\n   */\n\n\n  Store.verify = function verify(message) {\n    if (typeof message !== \"object\" || message === null) return \"object expected\";\n\n    if (message.binCounts != null && message.hasOwnProperty(\"binCounts\")) {\n      if (!$util.isObject(message.binCounts)) return \"binCounts: object expected\";\n      var key = Object.keys(message.binCounts);\n\n      for (var i = 0; i < key.length; ++i) {\n        if (!$util.key32Re.test(key[i])) return \"binCounts: integer key{k:sint32} expected\";\n        if (typeof message.binCounts[key[i]] !== \"number\") return \"binCounts: number{k:sint32} expected\";\n      }\n    }\n\n    if (message.contiguousBinCounts != null && message.hasOwnProperty(\"contiguousBinCounts\")) {\n      if (!Array.isArray(message.contiguousBinCounts)) return \"contiguousBinCounts: array expected\";\n\n      for (var i = 0; i < message.contiguousBinCounts.length; ++i) if (typeof message.contiguousBinCounts[i] !== \"number\") return \"contiguousBinCounts: number[] expected\";\n    }\n\n    if (message.contiguousBinIndexOffset != null && message.hasOwnProperty(\"contiguousBinIndexOffset\")) if (!$util.isInteger(message.contiguousBinIndexOffset)) return \"contiguousBinIndexOffset: integer expected\";\n    return null;\n  };\n  /**\n   * Creates a Store message from a plain object. Also converts values to their respective internal types.\n   * @function fromObject\n   * @memberof Store\n   * @static\n   * @param {Object.<string,*>} object Plain object\n   * @returns {Store} Store\n   */\n\n\n  Store.fromObject = function fromObject(object) {\n    if (object instanceof $root.Store) return object;\n    var message = new $root.Store();\n\n    if (object.binCounts) {\n      if (typeof object.binCounts !== \"object\") throw TypeError(\".Store.binCounts: object expected\");\n      message.binCounts = {};\n\n      for (var keys = Object.keys(object.binCounts), i = 0; i < keys.length; ++i) message.binCounts[keys[i]] = Number(object.binCounts[keys[i]]);\n    }\n\n    if (object.contiguousBinCounts) {\n      if (!Array.isArray(object.contiguousBinCounts)) throw TypeError(\".Store.contiguousBinCounts: array expected\");\n      message.contiguousBinCounts = [];\n\n      for (var i = 0; i < object.contiguousBinCounts.length; ++i) message.contiguousBinCounts[i] = Number(object.contiguousBinCounts[i]);\n    }\n\n    if (object.contiguousBinIndexOffset != null) message.contiguousBinIndexOffset = object.contiguousBinIndexOffset | 0;\n    return message;\n  };\n  /**\n   * Creates a plain object from a Store message. Also converts values to other types if specified.\n   * @function toObject\n   * @memberof Store\n   * @static\n   * @param {Store} message Store\n   * @param {$protobuf.IConversionOptions} [options] Conversion options\n   * @returns {Object.<string,*>} Plain object\n   */\n\n\n  Store.toObject = function toObject(message, options) {\n    if (!options) options = {};\n    var object = {};\n    if (options.arrays || options.defaults) object.contiguousBinCounts = [];\n    if (options.objects || options.defaults) object.binCounts = {};\n    if (options.defaults) object.contiguousBinIndexOffset = 0;\n    var keys2;\n\n    if (message.binCounts && (keys2 = Object.keys(message.binCounts)).length) {\n      object.binCounts = {};\n\n      for (var j = 0; j < keys2.length; ++j) object.binCounts[keys2[j]] = options.json && !isFinite(message.binCounts[keys2[j]]) ? String(message.binCounts[keys2[j]]) : message.binCounts[keys2[j]];\n    }\n\n    if (message.contiguousBinCounts && message.contiguousBinCounts.length) {\n      object.contiguousBinCounts = [];\n\n      for (var j = 0; j < message.contiguousBinCounts.length; ++j) object.contiguousBinCounts[j] = options.json && !isFinite(message.contiguousBinCounts[j]) ? String(message.contiguousBinCounts[j]) : message.contiguousBinCounts[j];\n    }\n\n    if (message.contiguousBinIndexOffset != null && message.hasOwnProperty(\"contiguousBinIndexOffset\")) object.contiguousBinIndexOffset = message.contiguousBinIndexOffset;\n    return object;\n  };\n  /**\n   * Converts this Store to JSON.\n   * @function toJSON\n   * @memberof Store\n   * @instance\n   * @returns {Object.<string,*>} JSON object\n   */\n\n\n  Store.prototype.toJSON = function toJSON() {\n    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n  };\n\n  return Store;\n}();\n\nmodule.exports = $root;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js"],"names":["$protobuf","require","$Reader","Reader","$Writer","Writer","$util","util","$root","roots","DDSketch","properties","keys","Object","i","length","prototype","mapping","positiveValues","negativeValues","zeroCount","create","encode","message","writer","hasOwnProperty","call","IndexMapping","uint32","fork","ldelim","Store","double","encodeDelimited","decode","reader","end","undefined","len","pos","tag","skipType","decodeDelimited","verify","error","fromObject","object","TypeError","Number","toObject","options","defaults","json","isFinite","String","toJSON","constructor","toJSONOptions","gamma","indexOffset","interpolation","int32","enums","Interpolation","valuesById","values","binCounts","contiguousBinCounts","emptyObject","emptyArray","contiguousBinIndexOffset","sint32","key","value","end2","tag2","push","isObject","key32Re","test","Array","isArray","isInteger","arrays","objects","keys2","j","module","exports"],"mappings":"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","sourcesContent":["/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n\"use strict\";\nvar $protobuf = require(\"protobufjs/minimal\");\n// Common aliases\nvar $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n// Exported root namespace\nvar $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n$root.DDSketch = (function () {\n    /**\n     * Properties of a DDSketch.\n     * @exports IDDSketch\n     * @interface IDDSketch\n     * @property {IIndexMapping|null} [mapping] DDSketch mapping\n     * @property {IStore|null} [positiveValues] DDSketch positiveValues\n     * @property {IStore|null} [negativeValues] DDSketch negativeValues\n     * @property {number|null} [zeroCount] DDSketch zeroCount\n     */\n    /**\n     * Constructs a new DDSketch.\n     * @exports DDSketch\n     * @classdesc Represents a DDSketch.\n     * @implements IDDSketch\n     * @constructor\n     * @param {IDDSketch=} [properties] Properties to set\n     */\n    function DDSketch(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * DDSketch mapping.\n     * @member {IIndexMapping|null|undefined} mapping\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.mapping = null;\n    /**\n     * DDSketch positiveValues.\n     * @member {IStore|null|undefined} positiveValues\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.positiveValues = null;\n    /**\n     * DDSketch negativeValues.\n     * @member {IStore|null|undefined} negativeValues\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.negativeValues = null;\n    /**\n     * DDSketch zeroCount.\n     * @member {number} zeroCount\n     * @memberof DDSketch\n     * @instance\n     */\n    DDSketch.prototype.zeroCount = 0;\n    /**\n     * Creates a new DDSketch instance using the specified properties.\n     * @function create\n     * @memberof DDSketch\n     * @static\n     * @param {IDDSketch=} [properties] Properties to set\n     * @returns {DDSketch} DDSketch instance\n     */\n    DDSketch.create = function create(properties) {\n        return new DDSketch(properties);\n    };\n    /**\n     * Encodes the specified DDSketch message. Does not implicitly {@link DDSketch.verify|verify} messages.\n     * @function encode\n     * @memberof DDSketch\n     * @static\n     * @param {IDDSketch} message DDSketch message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DDSketch.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.mapping != null && Object.hasOwnProperty.call(message, \"mapping\"))\n            $root.IndexMapping.encode(message.mapping, writer.uint32(/* id 1, wireType 2 =*/ 10).fork()).ldelim();\n        if (message.positiveValues != null && Object.hasOwnProperty.call(message, \"positiveValues\"))\n            $root.Store.encode(message.positiveValues, writer.uint32(/* id 2, wireType 2 =*/ 18).fork()).ldelim();\n        if (message.negativeValues != null && Object.hasOwnProperty.call(message, \"negativeValues\"))\n            $root.Store.encode(message.negativeValues, writer.uint32(/* id 3, wireType 2 =*/ 26).fork()).ldelim();\n        if (message.zeroCount != null && Object.hasOwnProperty.call(message, \"zeroCount\"))\n            writer.uint32(/* id 4, wireType 1 =*/ 33).double(message.zeroCount);\n        return writer;\n    };\n    /**\n     * Encodes the specified DDSketch message, length delimited. Does not implicitly {@link DDSketch.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof DDSketch\n     * @static\n     * @param {IDDSketch} message DDSketch message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    DDSketch.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a DDSketch message from the specified reader or buffer.\n     * @function decode\n     * @memberof DDSketch\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {DDSketch} DDSketch\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DDSketch.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.DDSketch();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.mapping = $root.IndexMapping.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.positiveValues = $root.Store.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.negativeValues = $root.Store.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.zeroCount = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    /**\n     * Decodes a DDSketch message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof DDSketch\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {DDSketch} DDSketch\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DDSketch.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a DDSketch message.\n     * @function verify\n     * @memberof DDSketch\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    DDSketch.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.mapping != null && message.hasOwnProperty(\"mapping\")) {\n            var error = $root.IndexMapping.verify(message.mapping);\n            if (error)\n                return \"mapping.\" + error;\n        }\n        if (message.positiveValues != null && message.hasOwnProperty(\"positiveValues\")) {\n            var error = $root.Store.verify(message.positiveValues);\n            if (error)\n                return \"positiveValues.\" + error;\n        }\n        if (message.negativeValues != null && message.hasOwnProperty(\"negativeValues\")) {\n            var error = $root.Store.verify(message.negativeValues);\n            if (error)\n                return \"negativeValues.\" + error;\n        }\n        if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\"))\n            if (typeof message.zeroCount !== \"number\")\n                return \"zeroCount: number expected\";\n        return null;\n    };\n    /**\n     * Creates a DDSketch message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof DDSketch\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {DDSketch} DDSketch\n     */\n    DDSketch.fromObject = function fromObject(object) {\n        if (object instanceof $root.DDSketch)\n            return object;\n        var message = new $root.DDSketch();\n        if (object.mapping != null) {\n            if (typeof object.mapping !== \"object\")\n                throw TypeError(\".DDSketch.mapping: object expected\");\n            message.mapping = $root.IndexMapping.fromObject(object.mapping);\n        }\n        if (object.positiveValues != null) {\n            if (typeof object.positiveValues !== \"object\")\n                throw TypeError(\".DDSketch.positiveValues: object expected\");\n            message.positiveValues = $root.Store.fromObject(object.positiveValues);\n        }\n        if (object.negativeValues != null) {\n            if (typeof object.negativeValues !== \"object\")\n                throw TypeError(\".DDSketch.negativeValues: object expected\");\n            message.negativeValues = $root.Store.fromObject(object.negativeValues);\n        }\n        if (object.zeroCount != null)\n            message.zeroCount = Number(object.zeroCount);\n        return message;\n    };\n    /**\n     * Creates a plain object from a DDSketch message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof DDSketch\n     * @static\n     * @param {DDSketch} message DDSketch\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    DDSketch.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.mapping = null;\n            object.positiveValues = null;\n            object.negativeValues = null;\n            object.zeroCount = 0;\n        }\n        if (message.mapping != null && message.hasOwnProperty(\"mapping\"))\n            object.mapping = $root.IndexMapping.toObject(message.mapping, options);\n        if (message.positiveValues != null && message.hasOwnProperty(\"positiveValues\"))\n            object.positiveValues = $root.Store.toObject(message.positiveValues, options);\n        if (message.negativeValues != null && message.hasOwnProperty(\"negativeValues\"))\n            object.negativeValues = $root.Store.toObject(message.negativeValues, options);\n        if (message.zeroCount != null && message.hasOwnProperty(\"zeroCount\"))\n            object.zeroCount = options.json && !isFinite(message.zeroCount) ? String(message.zeroCount) : message.zeroCount;\n        return object;\n    };\n    /**\n     * Converts this DDSketch to JSON.\n     * @function toJSON\n     * @memberof DDSketch\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    DDSketch.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return DDSketch;\n})();\n$root.IndexMapping = (function () {\n    /**\n     * Properties of an IndexMapping.\n     * @exports IIndexMapping\n     * @interface IIndexMapping\n     * @property {number|null} [gamma] IndexMapping gamma\n     * @property {number|null} [indexOffset] IndexMapping indexOffset\n     * @property {IndexMapping.Interpolation|null} [interpolation] IndexMapping interpolation\n     */\n    /**\n     * Constructs a new IndexMapping.\n     * @exports IndexMapping\n     * @classdesc Represents an IndexMapping.\n     * @implements IIndexMapping\n     * @constructor\n     * @param {IIndexMapping=} [properties] Properties to set\n     */\n    function IndexMapping(properties) {\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * IndexMapping gamma.\n     * @member {number} gamma\n     * @memberof IndexMapping\n     * @instance\n     */\n    IndexMapping.prototype.gamma = 0;\n    /**\n     * IndexMapping indexOffset.\n     * @member {number} indexOffset\n     * @memberof IndexMapping\n     * @instance\n     */\n    IndexMapping.prototype.indexOffset = 0;\n    /**\n     * IndexMapping interpolation.\n     * @member {IndexMapping.Interpolation} interpolation\n     * @memberof IndexMapping\n     * @instance\n     */\n    IndexMapping.prototype.interpolation = 0;\n    /**\n     * Creates a new IndexMapping instance using the specified properties.\n     * @function create\n     * @memberof IndexMapping\n     * @static\n     * @param {IIndexMapping=} [properties] Properties to set\n     * @returns {IndexMapping} IndexMapping instance\n     */\n    IndexMapping.create = function create(properties) {\n        return new IndexMapping(properties);\n    };\n    /**\n     * Encodes the specified IndexMapping message. Does not implicitly {@link IndexMapping.verify|verify} messages.\n     * @function encode\n     * @memberof IndexMapping\n     * @static\n     * @param {IIndexMapping} message IndexMapping message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    IndexMapping.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.gamma != null && Object.hasOwnProperty.call(message, \"gamma\"))\n            writer.uint32(/* id 1, wireType 1 =*/ 9).double(message.gamma);\n        if (message.indexOffset != null && Object.hasOwnProperty.call(message, \"indexOffset\"))\n            writer.uint32(/* id 2, wireType 1 =*/ 17).double(message.indexOffset);\n        if (message.interpolation != null && Object.hasOwnProperty.call(message, \"interpolation\"))\n            writer.uint32(/* id 3, wireType 0 =*/ 24).int32(message.interpolation);\n        return writer;\n    };\n    /**\n     * Encodes the specified IndexMapping message, length delimited. Does not implicitly {@link IndexMapping.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof IndexMapping\n     * @static\n     * @param {IIndexMapping} message IndexMapping message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    IndexMapping.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes an IndexMapping message from the specified reader or buffer.\n     * @function decode\n     * @memberof IndexMapping\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {IndexMapping} IndexMapping\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    IndexMapping.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.IndexMapping();\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.gamma = reader.double();\n                    break;\n                case 2:\n                    message.indexOffset = reader.double();\n                    break;\n                case 3:\n                    message.interpolation = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    /**\n     * Decodes an IndexMapping message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof IndexMapping\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {IndexMapping} IndexMapping\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    IndexMapping.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies an IndexMapping message.\n     * @function verify\n     * @memberof IndexMapping\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    IndexMapping.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.gamma != null && message.hasOwnProperty(\"gamma\"))\n            if (typeof message.gamma !== \"number\")\n                return \"gamma: number expected\";\n        if (message.indexOffset != null && message.hasOwnProperty(\"indexOffset\"))\n            if (typeof message.indexOffset !== \"number\")\n                return \"indexOffset: number expected\";\n        if (message.interpolation != null && message.hasOwnProperty(\"interpolation\"))\n            switch (message.interpolation) {\n                default:\n                    return \"interpolation: enum value expected\";\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                    break;\n            }\n        return null;\n    };\n    /**\n     * Creates an IndexMapping message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof IndexMapping\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {IndexMapping} IndexMapping\n     */\n    IndexMapping.fromObject = function fromObject(object) {\n        if (object instanceof $root.IndexMapping)\n            return object;\n        var message = new $root.IndexMapping();\n        if (object.gamma != null)\n            message.gamma = Number(object.gamma);\n        if (object.indexOffset != null)\n            message.indexOffset = Number(object.indexOffset);\n        switch (object.interpolation) {\n            case \"NONE\":\n            case 0:\n                message.interpolation = 0;\n                break;\n            case \"LINEAR\":\n            case 1:\n                message.interpolation = 1;\n                break;\n            case \"QUADRATIC\":\n            case 2:\n                message.interpolation = 2;\n                break;\n            case \"CUBIC\":\n            case 3:\n                message.interpolation = 3;\n                break;\n        }\n        return message;\n    };\n    /**\n     * Creates a plain object from an IndexMapping message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof IndexMapping\n     * @static\n     * @param {IndexMapping} message IndexMapping\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    IndexMapping.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.defaults) {\n            object.gamma = 0;\n            object.indexOffset = 0;\n            object.interpolation = options.enums === String ? \"NONE\" : 0;\n        }\n        if (message.gamma != null && message.hasOwnProperty(\"gamma\"))\n            object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;\n        if (message.indexOffset != null && message.hasOwnProperty(\"indexOffset\"))\n            object.indexOffset = options.json && !isFinite(message.indexOffset) ? String(message.indexOffset) : message.indexOffset;\n        if (message.interpolation != null && message.hasOwnProperty(\"interpolation\"))\n            object.interpolation = options.enums === String ? $root.IndexMapping.Interpolation[message.interpolation] : message.interpolation;\n        return object;\n    };\n    /**\n     * Converts this IndexMapping to JSON.\n     * @function toJSON\n     * @memberof IndexMapping\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    IndexMapping.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    /**\n     * Interpolation enum.\n     * @name IndexMapping.Interpolation\n     * @enum {number}\n     * @property {number} NONE=0 NONE value\n     * @property {number} LINEAR=1 LINEAR value\n     * @property {number} QUADRATIC=2 QUADRATIC value\n     * @property {number} CUBIC=3 CUBIC value\n     */\n    IndexMapping.Interpolation = (function () {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"NONE\"] = 0;\n        values[valuesById[1] = \"LINEAR\"] = 1;\n        values[valuesById[2] = \"QUADRATIC\"] = 2;\n        values[valuesById[3] = \"CUBIC\"] = 3;\n        return values;\n    })();\n    return IndexMapping;\n})();\n$root.Store = (function () {\n    /**\n     * Properties of a Store.\n     * @exports IStore\n     * @interface IStore\n     * @property {Object.<string,number>|null} [binCounts] Store binCounts\n     * @property {Array.<number>|null} [contiguousBinCounts] Store contiguousBinCounts\n     * @property {number|null} [contiguousBinIndexOffset] Store contiguousBinIndexOffset\n     */\n    /**\n     * Constructs a new Store.\n     * @exports Store\n     * @classdesc Represents a Store.\n     * @implements IStore\n     * @constructor\n     * @param {IStore=} [properties] Properties to set\n     */\n    function Store(properties) {\n        this.binCounts = {};\n        this.contiguousBinCounts = [];\n        if (properties)\n            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Store binCounts.\n     * @member {Object.<string,number>} binCounts\n     * @memberof Store\n     * @instance\n     */\n    Store.prototype.binCounts = $util.emptyObject;\n    /**\n     * Store contiguousBinCounts.\n     * @member {Array.<number>} contiguousBinCounts\n     * @memberof Store\n     * @instance\n     */\n    Store.prototype.contiguousBinCounts = $util.emptyArray;\n    /**\n     * Store contiguousBinIndexOffset.\n     * @member {number} contiguousBinIndexOffset\n     * @memberof Store\n     * @instance\n     */\n    Store.prototype.contiguousBinIndexOffset = 0;\n    /**\n     * Creates a new Store instance using the specified properties.\n     * @function create\n     * @memberof Store\n     * @static\n     * @param {IStore=} [properties] Properties to set\n     * @returns {Store} Store instance\n     */\n    Store.create = function create(properties) {\n        return new Store(properties);\n    };\n    /**\n     * Encodes the specified Store message. Does not implicitly {@link Store.verify|verify} messages.\n     * @function encode\n     * @memberof Store\n     * @static\n     * @param {IStore} message Store message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Store.encode = function encode(message, writer) {\n        if (!writer)\n            writer = $Writer.create();\n        if (message.binCounts != null && Object.hasOwnProperty.call(message, \"binCounts\"))\n            for (var keys = Object.keys(message.binCounts), i = 0; i < keys.length; ++i)\n                writer.uint32(/* id 1, wireType 2 =*/ 10).fork().uint32(/* id 1, wireType 0 =*/ 8).sint32(keys[i]).uint32(/* id 2, wireType 1 =*/ 17).double(message.binCounts[keys[i]]).ldelim();\n        if (message.contiguousBinCounts != null && message.contiguousBinCounts.length) {\n            writer.uint32(/* id 2, wireType 2 =*/ 18).fork();\n            for (var i = 0; i < message.contiguousBinCounts.length; ++i)\n                writer.double(message.contiguousBinCounts[i]);\n            writer.ldelim();\n        }\n        if (message.contiguousBinIndexOffset != null && Object.hasOwnProperty.call(message, \"contiguousBinIndexOffset\"))\n            writer.uint32(/* id 3, wireType 0 =*/ 24).sint32(message.contiguousBinIndexOffset);\n        return writer;\n    };\n    /**\n     * Encodes the specified Store message, length delimited. Does not implicitly {@link Store.verify|verify} messages.\n     * @function encodeDelimited\n     * @memberof Store\n     * @static\n     * @param {IStore} message Store message or plain object to encode\n     * @param {$protobuf.Writer} [writer] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Store.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n    };\n    /**\n     * Decodes a Store message from the specified reader or buffer.\n     * @function decode\n     * @memberof Store\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {Store} Store\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Store.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Store(), key, value;\n        while (reader.pos < end) {\n            var tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (message.binCounts === $util.emptyObject)\n                        message.binCounts = {};\n                    var end2 = reader.uint32() + reader.pos;\n                    key = 0;\n                    value = 0;\n                    while (reader.pos < end2) {\n                        var tag2 = reader.uint32();\n                        switch (tag2 >>> 3) {\n                            case 1:\n                                key = reader.sint32();\n                                break;\n                            case 2:\n                                value = reader.double();\n                                break;\n                            default:\n                                reader.skipType(tag2 & 7);\n                                break;\n                        }\n                    }\n                    message.binCounts[key] = value;\n                    break;\n                case 2:\n                    if (!(message.contiguousBinCounts && message.contiguousBinCounts.length))\n                        message.contiguousBinCounts = [];\n                    if ((tag & 7) === 2) {\n                        var end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.contiguousBinCounts.push(reader.double());\n                    }\n                    else\n                        message.contiguousBinCounts.push(reader.double());\n                    break;\n                case 3:\n                    message.contiguousBinIndexOffset = reader.sint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    /**\n     * Decodes a Store message from the specified reader or buffer, length delimited.\n     * @function decodeDelimited\n     * @memberof Store\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @returns {Store} Store\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Store.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader))\n            reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n    };\n    /**\n     * Verifies a Store message.\n     * @function verify\n     * @memberof Store\n     * @static\n     * @param {Object.<string,*>} message Plain object to verify\n     * @returns {string|null} `null` if valid, otherwise the reason why it is not\n     */\n    Store.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null)\n            return \"object expected\";\n        if (message.binCounts != null && message.hasOwnProperty(\"binCounts\")) {\n            if (!$util.isObject(message.binCounts))\n                return \"binCounts: object expected\";\n            var key = Object.keys(message.binCounts);\n            for (var i = 0; i < key.length; ++i) {\n                if (!$util.key32Re.test(key[i]))\n                    return \"binCounts: integer key{k:sint32} expected\";\n                if (typeof message.binCounts[key[i]] !== \"number\")\n                    return \"binCounts: number{k:sint32} expected\";\n            }\n        }\n        if (message.contiguousBinCounts != null && message.hasOwnProperty(\"contiguousBinCounts\")) {\n            if (!Array.isArray(message.contiguousBinCounts))\n                return \"contiguousBinCounts: array expected\";\n            for (var i = 0; i < message.contiguousBinCounts.length; ++i)\n                if (typeof message.contiguousBinCounts[i] !== \"number\")\n                    return \"contiguousBinCounts: number[] expected\";\n        }\n        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty(\"contiguousBinIndexOffset\"))\n            if (!$util.isInteger(message.contiguousBinIndexOffset))\n                return \"contiguousBinIndexOffset: integer expected\";\n        return null;\n    };\n    /**\n     * Creates a Store message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Store\n     * @static\n     * @param {Object.<string,*>} object Plain object\n     * @returns {Store} Store\n     */\n    Store.fromObject = function fromObject(object) {\n        if (object instanceof $root.Store)\n            return object;\n        var message = new $root.Store();\n        if (object.binCounts) {\n            if (typeof object.binCounts !== \"object\")\n                throw TypeError(\".Store.binCounts: object expected\");\n            message.binCounts = {};\n            for (var keys = Object.keys(object.binCounts), i = 0; i < keys.length; ++i)\n                message.binCounts[keys[i]] = Number(object.binCounts[keys[i]]);\n        }\n        if (object.contiguousBinCounts) {\n            if (!Array.isArray(object.contiguousBinCounts))\n                throw TypeError(\".Store.contiguousBinCounts: array expected\");\n            message.contiguousBinCounts = [];\n            for (var i = 0; i < object.contiguousBinCounts.length; ++i)\n                message.contiguousBinCounts[i] = Number(object.contiguousBinCounts[i]);\n        }\n        if (object.contiguousBinIndexOffset != null)\n            message.contiguousBinIndexOffset = object.contiguousBinIndexOffset | 0;\n        return message;\n    };\n    /**\n     * Creates a plain object from a Store message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Store\n     * @static\n     * @param {Store} message Store\n     * @param {$protobuf.IConversionOptions} [options] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Store.toObject = function toObject(message, options) {\n        if (!options)\n            options = {};\n        var object = {};\n        if (options.arrays || options.defaults)\n            object.contiguousBinCounts = [];\n        if (options.objects || options.defaults)\n            object.binCounts = {};\n        if (options.defaults)\n            object.contiguousBinIndexOffset = 0;\n        var keys2;\n        if (message.binCounts && (keys2 = Object.keys(message.binCounts)).length) {\n            object.binCounts = {};\n            for (var j = 0; j < keys2.length; ++j)\n                object.binCounts[keys2[j]] = options.json && !isFinite(message.binCounts[keys2[j]]) ? String(message.binCounts[keys2[j]]) : message.binCounts[keys2[j]];\n        }\n        if (message.contiguousBinCounts && message.contiguousBinCounts.length) {\n            object.contiguousBinCounts = [];\n            for (var j = 0; j < message.contiguousBinCounts.length; ++j)\n                object.contiguousBinCounts[j] = options.json && !isFinite(message.contiguousBinCounts[j]) ? String(message.contiguousBinCounts[j]) : message.contiguousBinCounts[j];\n        }\n        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty(\"contiguousBinIndexOffset\"))\n            object.contiguousBinIndexOffset = message.contiguousBinIndexOffset;\n        return object;\n    };\n    /**\n     * Converts this Store to JSON.\n     * @function toJSON\n     * @memberof Store\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Store.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n    return Store;\n})();\nmodule.exports = $root;\n"]},"metadata":{},"sourceType":"script"}