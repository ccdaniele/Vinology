{"ast":null,"code":"'use strict'; // Use a weak map to avoid polluting the wrapped function/method.\n\nconst unwrappers = new WeakMap();\n\nfunction copyProperties(original, wrapped) {\n  Object.setPrototypeOf(wrapped, original);\n  const props = Object.getOwnPropertyDescriptors(original);\n  const keys = Reflect.ownKeys(props);\n\n  for (const key of keys) {\n    Object.defineProperty(wrapped, key, props[key]);\n  }\n}\n\nfunction wrapFn(original, delegate) {\n  assertFunction(delegate);\n  assertNotClass(original); // TODO: support constructors of native classes\n\n  const shim = function shim() {\n    return delegate.apply(this, arguments);\n  };\n\n  unwrappers.set(shim, () => {\n    delegate = original;\n  });\n  copyProperties(original, shim);\n  return shim;\n}\n\nfunction wrapMethod(target, name, wrapper) {\n  assertMethod(target, name);\n  assertNotClass(target[name]); // TODO: support constructors of native classes\n\n  assertFunction(wrapper);\n  const original = target[name];\n  const wrapped = wrapper(original);\n  const descriptor = Object.getOwnPropertyDescriptor(target, name);\n\n  if (descriptor) {\n    unwrappers.set(wrapped, () => Object.defineProperty(target, name, descriptor));\n  } else {\n    // no descriptor means original was on the prototype\n    unwrappers.set(wrapped, () => delete target[name]);\n  }\n\n  Object.defineProperty(target, name, {\n    configurable: true,\n    writable: true,\n    enumerable: false,\n    ...descriptor,\n    value: wrapped\n  });\n  copyProperties(original, wrapped);\n  return target;\n}\n\nfunction wrap(target, name, wrapper) {\n  return typeof name === 'function' ? wrapFn(target, name) : wrapMethod(target, name, wrapper);\n}\n\nfunction unwrap(target, name) {\n  if (!target) return target; // no target to unwrap\n\n  const unwrapper = unwrappers.get(name ? target[name] : target);\n  if (!unwrapper) return target; // target is already unwrapped or isn't wrapped\n\n  unwrapper();\n  return target;\n}\n\nfunction massWrap(targets, names, wrapper) {\n  targets = toArray(targets);\n  names = toArray(names);\n\n  for (const target of targets) {\n    for (const name of names) {\n      wrap(target, name, wrapper);\n    }\n  }\n}\n\nfunction massUnwrap(targets, names) {\n  targets = toArray(targets);\n  names = toArray(names);\n\n  for (const target of targets) {\n    for (const name of names) {\n      unwrap(target, name);\n    }\n  }\n}\n\nfunction toArray(maybeArray) {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];\n}\n\nfunction assertMethod(target, name) {\n  if (!target) {\n    throw new Error('No target object provided.');\n  }\n\n  if (typeof target !== 'object' && typeof target !== 'function') {\n    throw new Error('Invalid target.');\n  }\n\n  if (!target[name]) {\n    throw new Error(`No original method ${name}.`);\n  }\n\n  if (typeof target[name] !== 'function') {\n    throw new Error(`Original method ${name} is not a function.`);\n  }\n}\n\nfunction assertFunction(target) {\n  if (!target) {\n    throw new Error('No function provided.');\n  }\n\n  if (typeof target !== 'function') {\n    throw new Error('Target is not a function.');\n  }\n}\n\nfunction assertNotClass(target) {\n  if (target.toString && target.toString().startsWith('class')) {\n    throw new Error('Target is a native class constructor and cannot be wrapped.');\n  }\n}\n\nmodule.exports = {\n  wrap,\n  massWrap,\n  unwrap,\n  massUnwrap\n};","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-shimmer/src/shimmer.js"],"names":["unwrappers","WeakMap","copyProperties","original","wrapped","Object","setPrototypeOf","props","getOwnPropertyDescriptors","keys","Reflect","ownKeys","key","defineProperty","wrapFn","delegate","assertFunction","assertNotClass","shim","apply","arguments","set","wrapMethod","target","name","wrapper","assertMethod","descriptor","getOwnPropertyDescriptor","configurable","writable","enumerable","value","wrap","unwrap","unwrapper","get","massWrap","targets","names","toArray","massUnwrap","maybeArray","Array","isArray","Error","toString","startsWith","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n// Use a weak map to avoid polluting the wrapped function/method.\nconst unwrappers = new WeakMap()\n\nfunction copyProperties (original, wrapped) {\n  Object.setPrototypeOf(wrapped, original)\n\n  const props = Object.getOwnPropertyDescriptors(original)\n  const keys = Reflect.ownKeys(props)\n\n  for (const key of keys) {\n    Object.defineProperty(wrapped, key, props[key])\n  }\n}\n\nfunction wrapFn (original, delegate) {\n  assertFunction(delegate)\n  assertNotClass(original) // TODO: support constructors of native classes\n\n  const shim = function shim () {\n    return delegate.apply(this, arguments)\n  }\n\n  unwrappers.set(shim, () => {\n    delegate = original\n  })\n\n  copyProperties(original, shim)\n\n  return shim\n}\n\nfunction wrapMethod (target, name, wrapper) {\n  assertMethod(target, name)\n  assertNotClass(target[name]) // TODO: support constructors of native classes\n  assertFunction(wrapper)\n\n  const original = target[name]\n  const wrapped = wrapper(original)\n  const descriptor = Object.getOwnPropertyDescriptor(target, name)\n\n  if (descriptor) {\n    unwrappers.set(wrapped, () => Object.defineProperty(target, name, descriptor))\n  } else { // no descriptor means original was on the prototype\n    unwrappers.set(wrapped, () => delete target[name])\n  }\n\n  Object.defineProperty(target, name, {\n    configurable: true,\n    writable: true,\n    enumerable: false,\n    ...descriptor,\n    value: wrapped\n  })\n\n  copyProperties(original, wrapped)\n\n  return target\n}\n\nfunction wrap (target, name, wrapper) {\n  return typeof name === 'function'\n    ? wrapFn(target, name)\n    : wrapMethod(target, name, wrapper)\n}\n\nfunction unwrap (target, name) {\n  if (!target) return target // no target to unwrap\n\n  const unwrapper = unwrappers.get(name ? target[name] : target)\n\n  if (!unwrapper) return target // target is already unwrapped or isn't wrapped\n\n  unwrapper()\n\n  return target\n}\n\nfunction massWrap (targets, names, wrapper) {\n  targets = toArray(targets)\n  names = toArray(names)\n\n  for (const target of targets) {\n    for (const name of names) {\n      wrap(target, name, wrapper)\n    }\n  }\n}\n\nfunction massUnwrap (targets, names) {\n  targets = toArray(targets)\n  names = toArray(names)\n\n  for (const target of targets) {\n    for (const name of names) {\n      unwrap(target, name)\n    }\n  }\n}\n\nfunction toArray (maybeArray) {\n  return Array.isArray(maybeArray) ? maybeArray : [maybeArray]\n}\n\nfunction assertMethod (target, name) {\n  if (!target) {\n    throw new Error('No target object provided.')\n  }\n\n  if (typeof target !== 'object' && typeof target !== 'function') {\n    throw new Error('Invalid target.')\n  }\n\n  if (!target[name]) {\n    throw new Error(`No original method ${name}.`)\n  }\n\n  if (typeof target[name] !== 'function') {\n    throw new Error(`Original method ${name} is not a function.`)\n  }\n}\n\nfunction assertFunction (target) {\n  if (!target) {\n    throw new Error('No function provided.')\n  }\n\n  if (typeof target !== 'function') {\n    throw new Error('Target is not a function.')\n  }\n}\n\nfunction assertNotClass (target) {\n  if (target.toString && target.toString().startsWith('class')) {\n    throw new Error('Target is a native class constructor and cannot be wrapped.')\n  }\n}\n\nmodule.exports = {\n  wrap,\n  massWrap,\n  unwrap,\n  massUnwrap\n}\n"]},"metadata":{},"sourceType":"script"}