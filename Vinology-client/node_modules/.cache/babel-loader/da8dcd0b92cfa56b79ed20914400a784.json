{"ast":null,"code":"const {\n  promisify\n} = require('util');\n\nconst {\n  SAMPLING_RULE_DECISION\n} = require('../../dd-trace/src/constants');\n\nconst {\n  SAMPLING_PRIORITY,\n  SPAN_TYPE,\n  RESOURCE_NAME\n} = require('../../../ext/tags');\n\nconst {\n  AUTO_KEEP\n} = require('../../../ext/priority');\n\nconst {\n  TEST_TYPE,\n  TEST_NAME,\n  TEST_SUITE,\n  TEST_STATUS,\n  TEST_PARAMETERS,\n  CI_APP_ORIGIN,\n  getTestEnvironmentMetadata,\n  getTestParametersString,\n  finishAllTraceSpans,\n  getTestParentSpan,\n  getTestSuitePath\n} = require('../../dd-trace/src/plugins/util/test');\n\nfunction getTestSpanMetadata(tracer, test, sourceRoot) {\n  const childOf = getTestParentSpan(tracer);\n  const {\n    file: testSuiteAbsolutePath\n  } = test;\n  const fullTestName = test.fullTitle();\n  const testSuite = getTestSuitePath(testSuiteAbsolutePath, sourceRoot);\n  return {\n    childOf,\n    resource: `${testSuite}.${fullTestName}`,\n    [TEST_TYPE]: 'test',\n    [TEST_NAME]: fullTestName,\n    [TEST_SUITE]: testSuite,\n    [SAMPLING_RULE_DECISION]: 1,\n    [SAMPLING_PRIORITY]: AUTO_KEEP\n  };\n}\n\nfunction createWrapRunTest(tracer, testEnvironmentMetadata, sourceRoot) {\n  return function wrapRunTest(runTest) {\n    return async function runTestWithTrace() {\n      // `runTest` is rerun when retries are configured through `this.retries` and the test fails.\n      // This clause prevents rewrapping `this.test.fn` when it has already been wrapped.\n      if (this.test._currentRetry !== undefined && this.test._currentRetry !== 0) {\n        return runTest.apply(this, arguments);\n      }\n\n      let specFunction = this.test.fn;\n\n      if (specFunction.length) {\n        specFunction = promisify(specFunction); // otherwise you have to explicitly call done()\n\n        this.test.async = 0;\n        this.test.sync = true;\n      }\n\n      const {\n        childOf,\n        resource,\n        ...testSpanMetadata\n      } = getTestSpanMetadata(tracer, this.test, sourceRoot);\n      const testParametersString = getTestParametersString(nameToParams, this.test.title);\n\n      if (testParametersString) {\n        testSpanMetadata[TEST_PARAMETERS] = testParametersString;\n      }\n\n      this.test.fn = tracer.wrap('mocha.test', {\n        type: 'test',\n        childOf,\n        resource,\n        tags: { ...testSpanMetadata,\n          ...testEnvironmentMetadata\n        }\n      }, async () => {\n        const activeSpan = tracer.scope().active();\n        activeSpan.context()._trace.origin = CI_APP_ORIGIN;\n        let result;\n\n        try {\n          const context = this.test.ctx;\n          result = await specFunction.call(context);\n\n          if (context.test.state !== 'failed' && !context.test.timedOut) {\n            activeSpan.setTag(TEST_STATUS, 'pass');\n          } else {\n            activeSpan.setTag(TEST_STATUS, 'fail');\n          }\n        } catch (error) {\n          // this.skip has been called\n          if (error.constructor.name === 'Pending' && !this.forbidPending) {\n            activeSpan.setTag(TEST_STATUS, 'skip');\n          } else {\n            activeSpan.setTag(TEST_STATUS, 'fail');\n            activeSpan.setTag('error', error);\n          }\n\n          throw error;\n        } finally {\n          finishAllTraceSpans(activeSpan);\n        }\n\n        return result;\n      });\n      return runTest.apply(this, arguments);\n    };\n  };\n}\n\nfunction getAllTestsInSuite(root) {\n  const tests = [];\n\n  function getTests(suiteOrTest) {\n    suiteOrTest.tests.forEach(test => {\n      tests.push(test);\n    });\n    suiteOrTest.suites.forEach(suite => {\n      getTests(suite);\n    });\n  }\n\n  getTests(root);\n  return tests;\n} // Necessary to get the skipped tests, that do not go through runTest\n\n\nfunction createWrapRunTests(tracer, testEnvironmentMetadata, sourceRoot) {\n  return function wrapRunTests(runTests) {\n    return function runTestsWithTrace() {\n      runTests.apply(this, arguments);\n      const suite = arguments[0];\n      const tests = getAllTestsInSuite(suite);\n      tests.forEach(test => {\n        const {\n          pending: isSkipped\n        } = test; // We call `getAllTestsInSuite` with the root suite so every skipped test\n        // should already have an associated test span.\n        // This function is called with every suite, so we need a way to mark\n        // the test as already accounted for. We do this through `__datadog_skipped`.\n        // If the test is already marked as skipped, we don't create an additional test span.\n\n        if (!isSkipped || test.__datadog_skipped) {\n          return;\n        }\n\n        test.__datadog_skipped = true;\n        const {\n          childOf,\n          resource,\n          ...testSpanMetadata\n        } = getTestSpanMetadata(tracer, test, sourceRoot);\n        const testSpan = tracer.startSpan('mocha.test', {\n          childOf,\n          tags: {\n            [SPAN_TYPE]: 'test',\n            [RESOURCE_NAME]: resource,\n            ...testSpanMetadata,\n            ...testEnvironmentMetadata,\n            [TEST_STATUS]: 'skip'\n          }\n        });\n        testSpan.context()._trace.origin = CI_APP_ORIGIN;\n        testSpan.finish();\n      });\n    };\n  };\n}\n\nconst nameToParams = {};\n\nfunction wrapMochaEach(mochaEach) {\n  return function mochaEachWithTrace() {\n    const [params] = arguments;\n    const {\n      it,\n      ...rest\n    } = mochaEach.apply(this, arguments);\n    return {\n      it: function (name) {\n        nameToParams[name] = params;\n        it.apply(this, arguments);\n      },\n      ...rest\n    };\n  };\n}\n\nfunction createWrapFail(tracer, testEnvironmentMetadata, sourceRoot) {\n  return function wrapFail(fail) {\n    return function failWithTrace(hook, err) {\n      if (hook.type !== 'hook') {\n        /**\n         * This clause is to cover errors that are uncaught, such as:\n         * it('will fail', done => {\n         *   setTimeout(() => {\n         *     // will throw but will not be caught by `runTestWithTrace`\n         *     expect(true).to.equal(false)\n         *     done()\n         *   }, 100)\n         * })\n         */\n        const testSpan = tracer.scope().active();\n\n        if (!testSpan) {\n          return fail.apply(this, arguments);\n        }\n\n        const {\n          [TEST_NAME]: testName,\n          [TEST_SUITE]: testSuite,\n          [TEST_STATUS]: testStatus\n        } = testSpan._spanContext._tags;\n        const isActiveSpanFailing = hook.fullTitle() === testName && hook.file.endsWith(testSuite);\n\n        if (isActiveSpanFailing && !testStatus) {\n          testSpan.setTag(TEST_STATUS, 'fail');\n          testSpan.setTag('error', err); // need to manually finish, as it will not be caught in `runTestWithTrace`\n\n          testSpan.finish();\n        }\n\n        return fail.apply(this, arguments);\n      }\n\n      if (err && hook.ctx && hook.ctx.currentTest) {\n        err.message = `${hook.title}: ${err.message}`;\n        const {\n          childOf,\n          resource,\n          ...testSpanMetadata\n        } = getTestSpanMetadata(tracer, hook.ctx.currentTest, sourceRoot);\n        const testSpan = tracer.startSpan('mocha.test', {\n          childOf,\n          tags: {\n            [SPAN_TYPE]: 'test',\n            [RESOURCE_NAME]: resource,\n            ...testSpanMetadata,\n            ...testEnvironmentMetadata,\n            [TEST_STATUS]: 'fail'\n          }\n        });\n        testSpan.setTag('error', err);\n        testSpan.context()._trace.origin = CI_APP_ORIGIN;\n        testSpan.finish();\n      }\n\n      return fail.apply(this, arguments);\n    };\n  };\n}\n\nmodule.exports = [{\n  name: 'mocha',\n  versions: ['>=5.2.0'],\n  file: 'lib/runner.js',\n\n  patch(Runner, tracer) {\n    const testEnvironmentMetadata = getTestEnvironmentMetadata('mocha');\n    const sourceRoot = process.cwd();\n    this.wrap(Runner.prototype, 'runTests', createWrapRunTests(tracer, testEnvironmentMetadata, sourceRoot));\n    this.wrap(Runner.prototype, 'runTest', createWrapRunTest(tracer, testEnvironmentMetadata, sourceRoot));\n    this.wrap(Runner.prototype, 'fail', createWrapFail(tracer, testEnvironmentMetadata, sourceRoot));\n  },\n\n  unpatch(Runner) {\n    this.unwrap(Runner.prototype, 'runTests');\n    this.unwrap(Runner.prototype, 'runTest');\n    this.unwrap(Runner.prototype, 'fail');\n  }\n\n}, {\n  name: 'mocha-each',\n  versions: ['>=2.0.1'],\n\n  patch(mochaEach) {\n    return this.wrapExport(mochaEach, wrapMochaEach(mochaEach));\n  },\n\n  unpatch(mochaEach) {\n    this.unwrapExport(mochaEach);\n  }\n\n}];","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-mocha/src/index.js"],"names":["promisify","require","SAMPLING_RULE_DECISION","SAMPLING_PRIORITY","SPAN_TYPE","RESOURCE_NAME","AUTO_KEEP","TEST_TYPE","TEST_NAME","TEST_SUITE","TEST_STATUS","TEST_PARAMETERS","CI_APP_ORIGIN","getTestEnvironmentMetadata","getTestParametersString","finishAllTraceSpans","getTestParentSpan","getTestSuitePath","getTestSpanMetadata","tracer","test","sourceRoot","childOf","file","testSuiteAbsolutePath","fullTestName","fullTitle","testSuite","resource","createWrapRunTest","testEnvironmentMetadata","wrapRunTest","runTest","runTestWithTrace","_currentRetry","undefined","apply","arguments","specFunction","fn","length","async","sync","testSpanMetadata","testParametersString","nameToParams","title","wrap","type","tags","activeSpan","scope","active","context","_trace","origin","result","ctx","call","state","timedOut","setTag","error","constructor","name","forbidPending","getAllTestsInSuite","root","tests","getTests","suiteOrTest","forEach","push","suites","suite","createWrapRunTests","wrapRunTests","runTests","runTestsWithTrace","pending","isSkipped","__datadog_skipped","testSpan","startSpan","finish","wrapMochaEach","mochaEach","mochaEachWithTrace","params","it","rest","createWrapFail","wrapFail","fail","failWithTrace","hook","err","testName","testStatus","_spanContext","_tags","isActiveSpanFailing","endsWith","currentTest","message","module","exports","versions","patch","Runner","process","cwd","prototype","unpatch","unwrap","wrapExport","unwrapExport"],"mappings":"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","sourcesContent":["const { promisify } = require('util')\n\nconst { SAMPLING_RULE_DECISION } = require('../../dd-trace/src/constants')\nconst { SAMPLING_PRIORITY, SPAN_TYPE, RESOURCE_NAME } = require('../../../ext/tags')\nconst { AUTO_KEEP } = require('../../../ext/priority')\nconst {\n  TEST_TYPE,\n  TEST_NAME,\n  TEST_SUITE,\n  TEST_STATUS,\n  TEST_PARAMETERS,\n  CI_APP_ORIGIN,\n  getTestEnvironmentMetadata,\n  getTestParametersString,\n  finishAllTraceSpans,\n  getTestParentSpan,\n  getTestSuitePath\n} = require('../../dd-trace/src/plugins/util/test')\n\nfunction getTestSpanMetadata (tracer, test, sourceRoot) {\n  const childOf = getTestParentSpan(tracer)\n\n  const { file: testSuiteAbsolutePath } = test\n  const fullTestName = test.fullTitle()\n  const testSuite = getTestSuitePath(testSuiteAbsolutePath, sourceRoot)\n\n  return {\n    childOf,\n    resource: `${testSuite}.${fullTestName}`,\n    [TEST_TYPE]: 'test',\n    [TEST_NAME]: fullTestName,\n    [TEST_SUITE]: testSuite,\n    [SAMPLING_RULE_DECISION]: 1,\n    [SAMPLING_PRIORITY]: AUTO_KEEP\n  }\n}\n\nfunction createWrapRunTest (tracer, testEnvironmentMetadata, sourceRoot) {\n  return function wrapRunTest (runTest) {\n    return async function runTestWithTrace () {\n      // `runTest` is rerun when retries are configured through `this.retries` and the test fails.\n      // This clause prevents rewrapping `this.test.fn` when it has already been wrapped.\n      if (this.test._currentRetry !== undefined && this.test._currentRetry !== 0) {\n        return runTest.apply(this, arguments)\n      }\n\n      let specFunction = this.test.fn\n      if (specFunction.length) {\n        specFunction = promisify(specFunction)\n        // otherwise you have to explicitly call done()\n        this.test.async = 0\n        this.test.sync = true\n      }\n\n      const { childOf, resource, ...testSpanMetadata } = getTestSpanMetadata(tracer, this.test, sourceRoot)\n\n      const testParametersString = getTestParametersString(nameToParams, this.test.title)\n      if (testParametersString) {\n        testSpanMetadata[TEST_PARAMETERS] = testParametersString\n      }\n\n      this.test.fn = tracer.wrap(\n        'mocha.test',\n        {\n          type: 'test',\n          childOf,\n          resource,\n          tags: {\n            ...testSpanMetadata,\n            ...testEnvironmentMetadata\n          }\n        },\n        async () => {\n          const activeSpan = tracer.scope().active()\n          activeSpan.context()._trace.origin = CI_APP_ORIGIN\n          let result\n          try {\n            const context = this.test.ctx\n            result = await specFunction.call(context)\n            if (context.test.state !== 'failed' && !context.test.timedOut) {\n              activeSpan.setTag(TEST_STATUS, 'pass')\n            } else {\n              activeSpan.setTag(TEST_STATUS, 'fail')\n            }\n          } catch (error) {\n            // this.skip has been called\n            if (error.constructor.name === 'Pending' && !this.forbidPending) {\n              activeSpan.setTag(TEST_STATUS, 'skip')\n            } else {\n              activeSpan.setTag(TEST_STATUS, 'fail')\n              activeSpan.setTag('error', error)\n            }\n            throw error\n          } finally {\n            finishAllTraceSpans(activeSpan)\n          }\n          return result\n        }\n      )\n      return runTest.apply(this, arguments)\n    }\n  }\n}\n\nfunction getAllTestsInSuite (root) {\n  const tests = []\n  function getTests (suiteOrTest) {\n    suiteOrTest.tests.forEach(test => {\n      tests.push(test)\n    })\n    suiteOrTest.suites.forEach(suite => {\n      getTests(suite)\n    })\n  }\n  getTests(root)\n  return tests\n}\n\n// Necessary to get the skipped tests, that do not go through runTest\nfunction createWrapRunTests (tracer, testEnvironmentMetadata, sourceRoot) {\n  return function wrapRunTests (runTests) {\n    return function runTestsWithTrace () {\n      runTests.apply(this, arguments)\n      const suite = arguments[0]\n      const tests = getAllTestsInSuite(suite)\n      tests.forEach(test => {\n        const { pending: isSkipped } = test\n        // We call `getAllTestsInSuite` with the root suite so every skipped test\n        // should already have an associated test span.\n        // This function is called with every suite, so we need a way to mark\n        // the test as already accounted for. We do this through `__datadog_skipped`.\n        // If the test is already marked as skipped, we don't create an additional test span.\n        if (!isSkipped || test.__datadog_skipped) {\n          return\n        }\n        test.__datadog_skipped = true\n        const { childOf, resource, ...testSpanMetadata } = getTestSpanMetadata(tracer, test, sourceRoot)\n\n        const testSpan = tracer\n          .startSpan('mocha.test', {\n            childOf,\n            tags: {\n              [SPAN_TYPE]: 'test',\n              [RESOURCE_NAME]: resource,\n              ...testSpanMetadata,\n              ...testEnvironmentMetadata,\n              [TEST_STATUS]: 'skip'\n            }\n          })\n        testSpan.context()._trace.origin = CI_APP_ORIGIN\n\n        testSpan.finish()\n      })\n    }\n  }\n}\n\nconst nameToParams = {}\n\nfunction wrapMochaEach (mochaEach) {\n  return function mochaEachWithTrace () {\n    const [params] = arguments\n    const { it, ...rest } = mochaEach.apply(this, arguments)\n    return {\n      it: function (name) {\n        nameToParams[name] = params\n        it.apply(this, arguments)\n      },\n      ...rest\n    }\n  }\n}\n\nfunction createWrapFail (tracer, testEnvironmentMetadata, sourceRoot) {\n  return function wrapFail (fail) {\n    return function failWithTrace (hook, err) {\n      if (hook.type !== 'hook') {\n        /**\n         * This clause is to cover errors that are uncaught, such as:\n         * it('will fail', done => {\n         *   setTimeout(() => {\n         *     // will throw but will not be caught by `runTestWithTrace`\n         *     expect(true).to.equal(false)\n         *     done()\n         *   }, 100)\n         * })\n         */\n        const testSpan = tracer.scope().active()\n        if (!testSpan) {\n          return fail.apply(this, arguments)\n        }\n        const {\n          [TEST_NAME]: testName,\n          [TEST_SUITE]: testSuite,\n          [TEST_STATUS]: testStatus\n        } = testSpan._spanContext._tags\n\n        const isActiveSpanFailing = hook.fullTitle() === testName && hook.file.endsWith(testSuite)\n\n        if (isActiveSpanFailing && !testStatus) {\n          testSpan.setTag(TEST_STATUS, 'fail')\n          testSpan.setTag('error', err)\n          // need to manually finish, as it will not be caught in `runTestWithTrace`\n          testSpan.finish()\n        }\n        return fail.apply(this, arguments)\n      }\n      if (err && hook.ctx && hook.ctx.currentTest) {\n        err.message = `${hook.title}: ${err.message}`\n        const {\n          childOf,\n          resource,\n          ...testSpanMetadata\n        } = getTestSpanMetadata(tracer, hook.ctx.currentTest, sourceRoot)\n        const testSpan = tracer\n          .startSpan('mocha.test', {\n            childOf,\n            tags: {\n              [SPAN_TYPE]: 'test',\n              [RESOURCE_NAME]: resource,\n              ...testSpanMetadata,\n              ...testEnvironmentMetadata,\n              [TEST_STATUS]: 'fail'\n            }\n          })\n        testSpan.setTag('error', err)\n        testSpan.context()._trace.origin = CI_APP_ORIGIN\n        testSpan.finish()\n      }\n      return fail.apply(this, arguments)\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'mocha',\n    versions: ['>=5.2.0'],\n    file: 'lib/runner.js',\n    patch (Runner, tracer) {\n      const testEnvironmentMetadata = getTestEnvironmentMetadata('mocha')\n      const sourceRoot = process.cwd()\n      this.wrap(Runner.prototype, 'runTests', createWrapRunTests(tracer, testEnvironmentMetadata, sourceRoot))\n      this.wrap(Runner.prototype, 'runTest', createWrapRunTest(tracer, testEnvironmentMetadata, sourceRoot))\n      this.wrap(Runner.prototype, 'fail', createWrapFail(tracer, testEnvironmentMetadata, sourceRoot))\n    },\n    unpatch (Runner) {\n      this.unwrap(Runner.prototype, 'runTests')\n      this.unwrap(Runner.prototype, 'runTest')\n      this.unwrap(Runner.prototype, 'fail')\n    }\n  },\n  {\n    name: 'mocha-each',\n    versions: ['>=2.0.1'],\n    patch (mochaEach) {\n      return this.wrapExport(mochaEach, wrapMochaEach(mochaEach))\n    },\n    unpatch (mochaEach) {\n      this.unwrapExport(mochaEach)\n    }\n  }\n]\n"]},"metadata":{},"sourceType":"script"}