{"ast":null,"code":"'use strict';\n\nclass Scope {\n  active() {\n    return this._active() || null;\n  }\n\n  activate(span, callback) {\n    if (typeof callback !== 'function') return callback;\n\n    try {\n      return this._activate(span, callback);\n    } catch (e) {\n      if (span && typeof span.setTag === 'function') {\n        span.setTag('error', e);\n      }\n\n      throw e;\n    }\n  }\n\n  bind(target, span) {\n    target = this._bindEmitter(target, span);\n    target = this._bindPromise(target, span);\n    target = this._bindFn(target, span);\n    return target;\n  }\n\n  unbind(target) {\n    target = this._unbindFn(target);\n    target = this._unbindPromise(target);\n    target = this._unbindEmitter(target);\n    return target;\n  }\n\n  _active() {\n    return null;\n  }\n\n  _activate(span, callback) {\n    return callback();\n  }\n\n  _bindFn(fn, span) {\n    if (typeof fn !== 'function') return fn;\n    const scope = this;\n\n    const spanOrActive = this._spanOrActive(span);\n\n    const bound = function () {\n      return scope.activate(spanOrActive, () => {\n        return fn.apply(this, arguments);\n      });\n    };\n\n    bound._datadog_unbound = fn;\n    return bound;\n  }\n\n  _unbindFn(fn) {\n    if (typeof fn !== 'function') return fn;\n    return fn._datadog_unbound || fn;\n  }\n\n  _bindEmitter(emitter, span) {\n    if (!this._isEmitter(emitter)) return emitter;\n\n    if (!emitter.__is_dd_emitter) {\n      Scope._wrapEmitter(emitter);\n    }\n\n    emitter.__dd_span = span;\n    emitter.__dd_scope = this;\n    return emitter;\n  } // Occasionally we want to wrap a prototype rather than emitter instances,\n  // so we're exposing this as a static method. This gives us a faster\n  // path for binding instances of known EventEmitter subclasses.\n\n\n  static _wrapEmitter(emitter) {\n    wrapMethod(emitter, 'addListener', wrapAddListener);\n    wrapMethod(emitter, 'prependListener', wrapAddListener);\n    wrapMethod(emitter, 'on', wrapAddListener);\n    wrapMethod(emitter, 'once', wrapAddListener);\n    wrapMethod(emitter, 'removeListener', wrapRemoveListener);\n    wrapMethod(emitter, 'off', wrapRemoveListener);\n    wrapMethod(emitter, 'removeAllListeners', wrapRemoveAllListeners);\n    emitter.__is_dd_emitter = true;\n  }\n\n  _unbindEmitter(emitter) {\n    if (!this._isEmitter(emitter)) return emitter;\n    delete emitter.__dd_scope;\n    delete emitter.__dd_span;\n    return emitter;\n  }\n\n  _bindPromise(promise, span) {\n    if (!this._isPromise(promise)) return promise;\n    wrapMethod(promise, 'then', wrapThen, this, span);\n    return promise;\n  }\n\n  _unbindPromise(promise) {\n    if (!this._isPromise(promise)) return promise;\n    promise.then = promise.then._datadog_unbound || promise.then;\n    return promise;\n  }\n\n  _spanOrActive(span) {\n    return span !== undefined ? span : this.active();\n  }\n\n  _isEmitter(emitter) {\n    return emitter && typeof emitter.emit === 'function' && typeof emitter.on === 'function' && typeof emitter.addListener === 'function' && typeof emitter.removeListener === 'function';\n  }\n\n  _isPromise(promise) {\n    return promise && typeof promise.then === 'function';\n  }\n\n}\n\nfunction wrapThen(then, scope, span) {\n  return function thenWithTrace(onFulfilled, onRejected) {\n    const args = new Array(arguments.length);\n\n    for (let i = 0, l = args.length; i < l; i++) {\n      args[i] = scope.bind(arguments[i], span);\n    }\n\n    return then.apply(this, args);\n  };\n}\n\nfunction wrapAddListener(addListener) {\n  return function addListenerWithTrace(eventName, listener) {\n    if (!this.__dd_scope || !listener || listener._datadog_unbound || listener.listener) {\n      return addListener.apply(this, arguments);\n    }\n\n    const scope = this.__dd_scope;\n    const span = this.__dd_span;\n    const bound = scope.bind(listener, scope._spanOrActive(span));\n    this._datadog_events = this._datadog_events || {};\n\n    if (!this._datadog_events[eventName]) {\n      this._datadog_events[eventName] = new WeakMap();\n    }\n\n    const events = this._datadog_events[eventName];\n\n    if (!events.has(listener)) {\n      events.set(listener, []);\n    }\n\n    events.get(listener).push(bound);\n    return addListener.call(this, eventName, bound);\n  };\n}\n\nfunction wrapRemoveListener(removeListener) {\n  return function removeListenerWithTrace(eventName, listener) {\n    if (!this.__dd_scope) {\n      return removeListener.apply(this, arguments);\n    }\n\n    const listeners = this._datadog_events && this._datadog_events[eventName];\n\n    if (!listener || !listeners || !listeners.has(listener)) {\n      return removeListener.apply(this, arguments);\n    }\n\n    for (const bound of listeners.get(listener)) {\n      removeListener.call(this, eventName, bound);\n    }\n\n    listeners.delete(listener);\n    return removeListener.apply(this, arguments);\n  };\n}\n\nfunction wrapRemoveAllListeners(removeAllListeners) {\n  return function removeAllListenersWithTrace(eventName) {\n    if (this.__dd_scope && this._datadog_events) {\n      if (eventName) {\n        delete this._datadog_events[eventName];\n      } else {\n        delete this._datadog_events;\n      }\n    }\n\n    return removeAllListeners.apply(this, arguments);\n  };\n}\n\nfunction wrapMethod(target, name, wrapper, ...args) {\n  if (!target[name] || target[name]._datadog_unbound) return;\n  const original = target[name];\n  target[name] = wrapper(target[name], ...args);\n  target[name]._datadog_unbound = original;\n}\n\nmodule.exports = Scope;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/scope/base.js"],"names":["Scope","active","_active","activate","span","callback","_activate","e","setTag","bind","target","_bindEmitter","_bindPromise","_bindFn","unbind","_unbindFn","_unbindPromise","_unbindEmitter","fn","scope","spanOrActive","_spanOrActive","bound","apply","arguments","_datadog_unbound","emitter","_isEmitter","__is_dd_emitter","_wrapEmitter","__dd_span","__dd_scope","wrapMethod","wrapAddListener","wrapRemoveListener","wrapRemoveAllListeners","promise","_isPromise","wrapThen","then","undefined","emit","on","addListener","removeListener","thenWithTrace","onFulfilled","onRejected","args","Array","length","i","l","addListenerWithTrace","eventName","listener","_datadog_events","WeakMap","events","has","set","get","push","call","removeListenerWithTrace","listeners","delete","removeAllListeners","removeAllListenersWithTrace","name","wrapper","original","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,KAAN,CAAY;AACVC,EAAAA,MAAM,GAAI;AACR,WAAO,KAAKC,OAAL,MAAkB,IAAzB;AACD;;AAEDC,EAAAA,QAAQ,CAAEC,IAAF,EAAQC,QAAR,EAAkB;AACxB,QAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC,OAAOA,QAAP;;AAEpC,QAAI;AACF,aAAO,KAAKC,SAAL,CAAeF,IAAf,EAAqBC,QAArB,CAAP;AACD,KAFD,CAEE,OAAOE,CAAP,EAAU;AACV,UAAIH,IAAI,IAAI,OAAOA,IAAI,CAACI,MAAZ,KAAuB,UAAnC,EAA+C;AAC7CJ,QAAAA,IAAI,CAACI,MAAL,CAAY,OAAZ,EAAqBD,CAArB;AACD;;AAED,YAAMA,CAAN;AACD;AACF;;AAEDE,EAAAA,IAAI,CAAEC,MAAF,EAAUN,IAAV,EAAgB;AAClBM,IAAAA,MAAM,GAAG,KAAKC,YAAL,CAAkBD,MAAlB,EAA0BN,IAA1B,CAAT;AACAM,IAAAA,MAAM,GAAG,KAAKE,YAAL,CAAkBF,MAAlB,EAA0BN,IAA1B,CAAT;AACAM,IAAAA,MAAM,GAAG,KAAKG,OAAL,CAAaH,MAAb,EAAqBN,IAArB,CAAT;AAEA,WAAOM,MAAP;AACD;;AAEDI,EAAAA,MAAM,CAAEJ,MAAF,EAAU;AACdA,IAAAA,MAAM,GAAG,KAAKK,SAAL,CAAeL,MAAf,CAAT;AACAA,IAAAA,MAAM,GAAG,KAAKM,cAAL,CAAoBN,MAApB,CAAT;AACAA,IAAAA,MAAM,GAAG,KAAKO,cAAL,CAAoBP,MAApB,CAAT;AAEA,WAAOA,MAAP;AACD;;AAEDR,EAAAA,OAAO,GAAI;AACT,WAAO,IAAP;AACD;;AAEDI,EAAAA,SAAS,CAAEF,IAAF,EAAQC,QAAR,EAAkB;AACzB,WAAOA,QAAQ,EAAf;AACD;;AAEDQ,EAAAA,OAAO,CAAEK,EAAF,EAAMd,IAAN,EAAY;AACjB,QAAI,OAAOc,EAAP,KAAc,UAAlB,EAA8B,OAAOA,EAAP;AAE9B,UAAMC,KAAK,GAAG,IAAd;;AACA,UAAMC,YAAY,GAAG,KAAKC,aAAL,CAAmBjB,IAAnB,CAArB;;AAEA,UAAMkB,KAAK,GAAG,YAAY;AACxB,aAAOH,KAAK,CAAChB,QAAN,CAAeiB,YAAf,EAA6B,MAAM;AACxC,eAAOF,EAAE,CAACK,KAAH,CAAS,IAAT,EAAeC,SAAf,CAAP;AACD,OAFM,CAAP;AAGD,KAJD;;AAMAF,IAAAA,KAAK,CAACG,gBAAN,GAAyBP,EAAzB;AAEA,WAAOI,KAAP;AACD;;AAEDP,EAAAA,SAAS,CAAEG,EAAF,EAAM;AACb,QAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8B,OAAOA,EAAP;AAE9B,WAAOA,EAAE,CAACO,gBAAH,IAAuBP,EAA9B;AACD;;AAEDP,EAAAA,YAAY,CAAEe,OAAF,EAAWtB,IAAX,EAAiB;AAC3B,QAAI,CAAC,KAAKuB,UAAL,CAAgBD,OAAhB,CAAL,EAA+B,OAAOA,OAAP;;AAC/B,QAAI,CAACA,OAAO,CAACE,eAAb,EAA8B;AAC5B5B,MAAAA,KAAK,CAAC6B,YAAN,CAAmBH,OAAnB;AACD;;AACDA,IAAAA,OAAO,CAACI,SAAR,GAAoB1B,IAApB;AACAsB,IAAAA,OAAO,CAACK,UAAR,GAAqB,IAArB;AACA,WAAOL,OAAP;AACD,GA1ES,CA4EV;AACA;AACA;;;AACmB,SAAZG,YAAY,CAAEH,OAAF,EAAW;AAC5BM,IAAAA,UAAU,CAACN,OAAD,EAAU,aAAV,EAAyBO,eAAzB,CAAV;AACAD,IAAAA,UAAU,CAACN,OAAD,EAAU,iBAAV,EAA6BO,eAA7B,CAAV;AACAD,IAAAA,UAAU,CAACN,OAAD,EAAU,IAAV,EAAgBO,eAAhB,CAAV;AACAD,IAAAA,UAAU,CAACN,OAAD,EAAU,MAAV,EAAkBO,eAAlB,CAAV;AACAD,IAAAA,UAAU,CAACN,OAAD,EAAU,gBAAV,EAA4BQ,kBAA5B,CAAV;AACAF,IAAAA,UAAU,CAACN,OAAD,EAAU,KAAV,EAAiBQ,kBAAjB,CAAV;AACAF,IAAAA,UAAU,CAACN,OAAD,EAAU,oBAAV,EAAgCS,sBAAhC,CAAV;AACAT,IAAAA,OAAO,CAACE,eAAR,GAA0B,IAA1B;AACD;;AAEDX,EAAAA,cAAc,CAAES,OAAF,EAAW;AACvB,QAAI,CAAC,KAAKC,UAAL,CAAgBD,OAAhB,CAAL,EAA+B,OAAOA,OAAP;AAC/B,WAAOA,OAAO,CAACK,UAAf;AACA,WAAOL,OAAO,CAACI,SAAf;AACA,WAAOJ,OAAP;AACD;;AAEDd,EAAAA,YAAY,CAAEwB,OAAF,EAAWhC,IAAX,EAAiB;AAC3B,QAAI,CAAC,KAAKiC,UAAL,CAAgBD,OAAhB,CAAL,EAA+B,OAAOA,OAAP;AAE/BJ,IAAAA,UAAU,CAACI,OAAD,EAAU,MAAV,EAAkBE,QAAlB,EAA4B,IAA5B,EAAkClC,IAAlC,CAAV;AAEA,WAAOgC,OAAP;AACD;;AAEDpB,EAAAA,cAAc,CAAEoB,OAAF,EAAW;AACvB,QAAI,CAAC,KAAKC,UAAL,CAAgBD,OAAhB,CAAL,EAA+B,OAAOA,OAAP;AAE/BA,IAAAA,OAAO,CAACG,IAAR,GAAeH,OAAO,CAACG,IAAR,CAAad,gBAAb,IAAiCW,OAAO,CAACG,IAAxD;AAEA,WAAOH,OAAP;AACD;;AAEDf,EAAAA,aAAa,CAAEjB,IAAF,EAAQ;AACnB,WAAOA,IAAI,KAAKoC,SAAT,GAAqBpC,IAArB,GAA4B,KAAKH,MAAL,EAAnC;AACD;;AAED0B,EAAAA,UAAU,CAAED,OAAF,EAAW;AACnB,WAAOA,OAAO,IACZ,OAAOA,OAAO,CAACe,IAAf,KAAwB,UADnB,IAEL,OAAOf,OAAO,CAACgB,EAAf,KAAsB,UAFjB,IAGL,OAAOhB,OAAO,CAACiB,WAAf,KAA+B,UAH1B,IAIL,OAAOjB,OAAO,CAACkB,cAAf,KAAkC,UAJpC;AAKD;;AAEDP,EAAAA,UAAU,CAAED,OAAF,EAAW;AACnB,WAAOA,OAAO,IAAI,OAAOA,OAAO,CAACG,IAAf,KAAwB,UAA1C;AACD;;AA/HS;;AAkIZ,SAASD,QAAT,CAAmBC,IAAnB,EAAyBpB,KAAzB,EAAgCf,IAAhC,EAAsC;AACpC,SAAO,SAASyC,aAAT,CAAwBC,WAAxB,EAAqCC,UAArC,EAAiD;AACtD,UAAMC,IAAI,GAAG,IAAIC,KAAJ,CAAUzB,SAAS,CAAC0B,MAApB,CAAb;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGJ,IAAI,CAACE,MAAzB,EAAiCC,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3CH,MAAAA,IAAI,CAACG,CAAD,CAAJ,GAAUhC,KAAK,CAACV,IAAN,CAAWe,SAAS,CAAC2B,CAAD,CAApB,EAAyB/C,IAAzB,CAAV;AACD;;AAED,WAAOmC,IAAI,CAAChB,KAAL,CAAW,IAAX,EAAiByB,IAAjB,CAAP;AACD,GARD;AASD;;AAED,SAASf,eAAT,CAA0BU,WAA1B,EAAuC;AACrC,SAAO,SAASU,oBAAT,CAA+BC,SAA/B,EAA0CC,QAA1C,EAAoD;AACzD,QAAI,CAAC,KAAKxB,UAAN,IAAoB,CAACwB,QAArB,IAAiCA,QAAQ,CAAC9B,gBAA1C,IAA8D8B,QAAQ,CAACA,QAA3E,EAAqF;AACnF,aAAOZ,WAAW,CAACpB,KAAZ,CAAkB,IAAlB,EAAwBC,SAAxB,CAAP;AACD;;AACD,UAAML,KAAK,GAAG,KAAKY,UAAnB;AACA,UAAM3B,IAAI,GAAG,KAAK0B,SAAlB;AAEA,UAAMR,KAAK,GAAGH,KAAK,CAACV,IAAN,CAAW8C,QAAX,EAAqBpC,KAAK,CAACE,aAAN,CAAoBjB,IAApB,CAArB,CAAd;AAEA,SAAKoD,eAAL,GAAuB,KAAKA,eAAL,IAAwB,EAA/C;;AAEA,QAAI,CAAC,KAAKA,eAAL,CAAqBF,SAArB,CAAL,EAAsC;AACpC,WAAKE,eAAL,CAAqBF,SAArB,IAAkC,IAAIG,OAAJ,EAAlC;AACD;;AAED,UAAMC,MAAM,GAAG,KAAKF,eAAL,CAAqBF,SAArB,CAAf;;AAEA,QAAI,CAACI,MAAM,CAACC,GAAP,CAAWJ,QAAX,CAAL,EAA2B;AACzBG,MAAAA,MAAM,CAACE,GAAP,CAAWL,QAAX,EAAqB,EAArB;AACD;;AAEDG,IAAAA,MAAM,CAACG,GAAP,CAAWN,QAAX,EAAqBO,IAArB,CAA0BxC,KAA1B;AAEA,WAAOqB,WAAW,CAACoB,IAAZ,CAAiB,IAAjB,EAAuBT,SAAvB,EAAkChC,KAAlC,CAAP;AACD,GAxBD;AAyBD;;AAED,SAASY,kBAAT,CAA6BU,cAA7B,EAA6C;AAC3C,SAAO,SAASoB,uBAAT,CAAkCV,SAAlC,EAA6CC,QAA7C,EAAuD;AAC5D,QAAI,CAAC,KAAKxB,UAAV,EAAsB;AACpB,aAAOa,cAAc,CAACrB,KAAf,CAAqB,IAArB,EAA2BC,SAA3B,CAAP;AACD;;AAED,UAAMyC,SAAS,GAAG,KAAKT,eAAL,IAAwB,KAAKA,eAAL,CAAqBF,SAArB,CAA1C;;AAEA,QAAI,CAACC,QAAD,IAAa,CAACU,SAAd,IAA2B,CAACA,SAAS,CAACN,GAAV,CAAcJ,QAAd,CAAhC,EAAyD;AACvD,aAAOX,cAAc,CAACrB,KAAf,CAAqB,IAArB,EAA2BC,SAA3B,CAAP;AACD;;AAED,SAAK,MAAMF,KAAX,IAAoB2C,SAAS,CAACJ,GAAV,CAAcN,QAAd,CAApB,EAA6C;AAC3CX,MAAAA,cAAc,CAACmB,IAAf,CAAoB,IAApB,EAA0BT,SAA1B,EAAqChC,KAArC;AACD;;AAED2C,IAAAA,SAAS,CAACC,MAAV,CAAiBX,QAAjB;AAEA,WAAOX,cAAc,CAACrB,KAAf,CAAqB,IAArB,EAA2BC,SAA3B,CAAP;AACD,GAlBD;AAmBD;;AAED,SAASW,sBAAT,CAAiCgC,kBAAjC,EAAqD;AACnD,SAAO,SAASC,2BAAT,CAAsCd,SAAtC,EAAiD;AACtD,QAAI,KAAKvB,UAAL,IAAmB,KAAKyB,eAA5B,EAA6C;AAC3C,UAAIF,SAAJ,EAAe;AACb,eAAO,KAAKE,eAAL,CAAqBF,SAArB,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAKE,eAAZ;AACD;AACF;;AAED,WAAOW,kBAAkB,CAAC5C,KAAnB,CAAyB,IAAzB,EAA+BC,SAA/B,CAAP;AACD,GAVD;AAWD;;AAED,SAASQ,UAAT,CAAqBtB,MAArB,EAA6B2D,IAA7B,EAAmCC,OAAnC,EAA4C,GAAGtB,IAA/C,EAAqD;AACnD,MAAI,CAACtC,MAAM,CAAC2D,IAAD,CAAP,IAAiB3D,MAAM,CAAC2D,IAAD,CAAN,CAAa5C,gBAAlC,EAAoD;AAEpD,QAAM8C,QAAQ,GAAG7D,MAAM,CAAC2D,IAAD,CAAvB;AAEA3D,EAAAA,MAAM,CAAC2D,IAAD,CAAN,GAAeC,OAAO,CAAC5D,MAAM,CAAC2D,IAAD,CAAP,EAAe,GAAGrB,IAAlB,CAAtB;AACAtC,EAAAA,MAAM,CAAC2D,IAAD,CAAN,CAAa5C,gBAAb,GAAgC8C,QAAhC;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiBzE,KAAjB","sourcesContent":["'use strict'\n\nclass Scope {\n  active () {\n    return this._active() || null\n  }\n\n  activate (span, callback) {\n    if (typeof callback !== 'function') return callback\n\n    try {\n      return this._activate(span, callback)\n    } catch (e) {\n      if (span && typeof span.setTag === 'function') {\n        span.setTag('error', e)\n      }\n\n      throw e\n    }\n  }\n\n  bind (target, span) {\n    target = this._bindEmitter(target, span)\n    target = this._bindPromise(target, span)\n    target = this._bindFn(target, span)\n\n    return target\n  }\n\n  unbind (target) {\n    target = this._unbindFn(target)\n    target = this._unbindPromise(target)\n    target = this._unbindEmitter(target)\n\n    return target\n  }\n\n  _active () {\n    return null\n  }\n\n  _activate (span, callback) {\n    return callback()\n  }\n\n  _bindFn (fn, span) {\n    if (typeof fn !== 'function') return fn\n\n    const scope = this\n    const spanOrActive = this._spanOrActive(span)\n\n    const bound = function () {\n      return scope.activate(spanOrActive, () => {\n        return fn.apply(this, arguments)\n      })\n    }\n\n    bound._datadog_unbound = fn\n\n    return bound\n  }\n\n  _unbindFn (fn) {\n    if (typeof fn !== 'function') return fn\n\n    return fn._datadog_unbound || fn\n  }\n\n  _bindEmitter (emitter, span) {\n    if (!this._isEmitter(emitter)) return emitter\n    if (!emitter.__is_dd_emitter) {\n      Scope._wrapEmitter(emitter)\n    }\n    emitter.__dd_span = span\n    emitter.__dd_scope = this\n    return emitter\n  }\n\n  // Occasionally we want to wrap a prototype rather than emitter instances,\n  // so we're exposing this as a static method. This gives us a faster\n  // path for binding instances of known EventEmitter subclasses.\n  static _wrapEmitter (emitter) {\n    wrapMethod(emitter, 'addListener', wrapAddListener)\n    wrapMethod(emitter, 'prependListener', wrapAddListener)\n    wrapMethod(emitter, 'on', wrapAddListener)\n    wrapMethod(emitter, 'once', wrapAddListener)\n    wrapMethod(emitter, 'removeListener', wrapRemoveListener)\n    wrapMethod(emitter, 'off', wrapRemoveListener)\n    wrapMethod(emitter, 'removeAllListeners', wrapRemoveAllListeners)\n    emitter.__is_dd_emitter = true\n  }\n\n  _unbindEmitter (emitter) {\n    if (!this._isEmitter(emitter)) return emitter\n    delete emitter.__dd_scope\n    delete emitter.__dd_span\n    return emitter\n  }\n\n  _bindPromise (promise, span) {\n    if (!this._isPromise(promise)) return promise\n\n    wrapMethod(promise, 'then', wrapThen, this, span)\n\n    return promise\n  }\n\n  _unbindPromise (promise) {\n    if (!this._isPromise(promise)) return promise\n\n    promise.then = promise.then._datadog_unbound || promise.then\n\n    return promise\n  }\n\n  _spanOrActive (span) {\n    return span !== undefined ? span : this.active()\n  }\n\n  _isEmitter (emitter) {\n    return emitter &&\n      typeof emitter.emit === 'function' &&\n      typeof emitter.on === 'function' &&\n      typeof emitter.addListener === 'function' &&\n      typeof emitter.removeListener === 'function'\n  }\n\n  _isPromise (promise) {\n    return promise && typeof promise.then === 'function'\n  }\n}\n\nfunction wrapThen (then, scope, span) {\n  return function thenWithTrace (onFulfilled, onRejected) {\n    const args = new Array(arguments.length)\n\n    for (let i = 0, l = args.length; i < l; i++) {\n      args[i] = scope.bind(arguments[i], span)\n    }\n\n    return then.apply(this, args)\n  }\n}\n\nfunction wrapAddListener (addListener) {\n  return function addListenerWithTrace (eventName, listener) {\n    if (!this.__dd_scope || !listener || listener._datadog_unbound || listener.listener) {\n      return addListener.apply(this, arguments)\n    }\n    const scope = this.__dd_scope\n    const span = this.__dd_span\n\n    const bound = scope.bind(listener, scope._spanOrActive(span))\n\n    this._datadog_events = this._datadog_events || {}\n\n    if (!this._datadog_events[eventName]) {\n      this._datadog_events[eventName] = new WeakMap()\n    }\n\n    const events = this._datadog_events[eventName]\n\n    if (!events.has(listener)) {\n      events.set(listener, [])\n    }\n\n    events.get(listener).push(bound)\n\n    return addListener.call(this, eventName, bound)\n  }\n}\n\nfunction wrapRemoveListener (removeListener) {\n  return function removeListenerWithTrace (eventName, listener) {\n    if (!this.__dd_scope) {\n      return removeListener.apply(this, arguments)\n    }\n\n    const listeners = this._datadog_events && this._datadog_events[eventName]\n\n    if (!listener || !listeners || !listeners.has(listener)) {\n      return removeListener.apply(this, arguments)\n    }\n\n    for (const bound of listeners.get(listener)) {\n      removeListener.call(this, eventName, bound)\n    }\n\n    listeners.delete(listener)\n\n    return removeListener.apply(this, arguments)\n  }\n}\n\nfunction wrapRemoveAllListeners (removeAllListeners) {\n  return function removeAllListenersWithTrace (eventName) {\n    if (this.__dd_scope && this._datadog_events) {\n      if (eventName) {\n        delete this._datadog_events[eventName]\n      } else {\n        delete this._datadog_events\n      }\n    }\n\n    return removeAllListeners.apply(this, arguments)\n  }\n}\n\nfunction wrapMethod (target, name, wrapper, ...args) {\n  if (!target[name] || target[name]._datadog_unbound) return\n\n  const original = target[name]\n\n  target[name] = wrapper(target[name], ...args)\n  target[name]._datadog_unbound = original\n}\n\nmodule.exports = Scope\n"]},"metadata":{},"sourceType":"script"}