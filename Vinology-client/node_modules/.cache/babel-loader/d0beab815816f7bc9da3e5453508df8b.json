{"ast":null,"code":"'use strict';\n\nconst log = require('../../log');\n\nconst TRACE_PREFIX = '{\"traces\":[[';\nconst TRACE_SUFFIX = ']]}\\n';\nconst TRACE_FORMAT_OVERHEAD = TRACE_PREFIX.length + TRACE_SUFFIX.length;\nconst MAX_SIZE = 64 * 1024; // 64kb\n\nclass LogExporter {\n  export(spans) {\n    log.debug(() => `Adding trace to queue: ${JSON.stringify(spans)}`);\n    let size = TRACE_FORMAT_OVERHEAD;\n    let queue = [];\n\n    for (const span of spans) {\n      const spanStr = JSON.stringify(span);\n\n      if (spanStr.length + TRACE_FORMAT_OVERHEAD > MAX_SIZE) {\n        log.debug('Span too large to send to logs, dropping');\n        continue;\n      }\n\n      if (spanStr.length + size > MAX_SIZE) {\n        this._printSpans(queue);\n\n        queue = [];\n        size = TRACE_FORMAT_OVERHEAD;\n      }\n\n      size += spanStr.length + 1; // includes length of ',' character\n\n      queue.push(spanStr);\n    }\n\n    if (queue.length > 0) {\n      this._printSpans(queue);\n    }\n  }\n\n  _printSpans(queue) {\n    let logLine = TRACE_PREFIX;\n    let firstTrace = true;\n\n    for (const spanStr of queue) {\n      if (firstTrace) {\n        firstTrace = false;\n        logLine += spanStr;\n      } else {\n        logLine += ',' + spanStr;\n      }\n    }\n\n    logLine += TRACE_SUFFIX;\n    process.stdout.write(logLine);\n  }\n\n}\n\nmodule.exports = LogExporter;","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/dd-trace/src/exporters/log/index.js"],"names":["log","require","TRACE_PREFIX","TRACE_SUFFIX","TRACE_FORMAT_OVERHEAD","length","MAX_SIZE","LogExporter","export","spans","debug","JSON","stringify","size","queue","span","spanStr","_printSpans","push","logLine","firstTrace","process","stdout","write","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAnB;;AAEA,MAAMC,YAAY,GAAG,cAArB;AACA,MAAMC,YAAY,GAAG,OAArB;AACA,MAAMC,qBAAqB,GAAGF,YAAY,CAACG,MAAb,GAAsBF,YAAY,CAACE,MAAjE;AACA,MAAMC,QAAQ,GAAG,KAAK,IAAtB,C,CAA2B;;AAE3B,MAAMC,WAAN,CAAkB;AAChBC,EAAAA,MAAM,CAAEC,KAAF,EAAS;AACbT,IAAAA,GAAG,CAACU,KAAJ,CAAU,MAAO,0BAAyBC,IAAI,CAACC,SAAL,CAAeH,KAAf,CAAsB,EAAhE;AAEA,QAAII,IAAI,GAAGT,qBAAX;AACA,QAAIU,KAAK,GAAG,EAAZ;;AAEA,SAAK,MAAMC,IAAX,IAAmBN,KAAnB,EAA0B;AACxB,YAAMO,OAAO,GAAGL,IAAI,CAACC,SAAL,CAAeG,IAAf,CAAhB;;AACA,UAAIC,OAAO,CAACX,MAAR,GAAiBD,qBAAjB,GAAyCE,QAA7C,EAAuD;AACrDN,QAAAA,GAAG,CAACU,KAAJ,CAAU,0CAAV;AACA;AACD;;AACD,UAAIM,OAAO,CAACX,MAAR,GAAiBQ,IAAjB,GAAwBP,QAA5B,EAAsC;AACpC,aAAKW,WAAL,CAAiBH,KAAjB;;AACAA,QAAAA,KAAK,GAAG,EAAR;AACAD,QAAAA,IAAI,GAAGT,qBAAP;AACD;;AACDS,MAAAA,IAAI,IAAIG,OAAO,CAACX,MAAR,GAAiB,CAAzB,CAXwB,CAWG;;AAC3BS,MAAAA,KAAK,CAACI,IAAN,CAAWF,OAAX;AACD;;AACD,QAAIF,KAAK,CAACT,MAAN,GAAe,CAAnB,EAAsB;AACpB,WAAKY,WAAL,CAAiBH,KAAjB;AACD;AACF;;AAEDG,EAAAA,WAAW,CAAEH,KAAF,EAAS;AAClB,QAAIK,OAAO,GAAGjB,YAAd;AACA,QAAIkB,UAAU,GAAG,IAAjB;;AACA,SAAK,MAAMJ,OAAX,IAAsBF,KAAtB,EAA6B;AAC3B,UAAIM,UAAJ,EAAgB;AACdA,QAAAA,UAAU,GAAG,KAAb;AACAD,QAAAA,OAAO,IAAIH,OAAX;AACD,OAHD,MAGO;AACLG,QAAAA,OAAO,IAAI,MAAMH,OAAjB;AACD;AACF;;AACDG,IAAAA,OAAO,IAAIhB,YAAX;AACAkB,IAAAA,OAAO,CAACC,MAAR,CAAeC,KAAf,CAAqBJ,OAArB;AACD;;AAvCe;;AA0ClBK,MAAM,CAACC,OAAP,GAAiBlB,WAAjB","sourcesContent":["'use strict'\n\nconst log = require('../../log')\n\nconst TRACE_PREFIX = '{\"traces\":[['\nconst TRACE_SUFFIX = ']]}\\n'\nconst TRACE_FORMAT_OVERHEAD = TRACE_PREFIX.length + TRACE_SUFFIX.length\nconst MAX_SIZE = 64 * 1024 // 64kb\n\nclass LogExporter {\n  export (spans) {\n    log.debug(() => `Adding trace to queue: ${JSON.stringify(spans)}`)\n\n    let size = TRACE_FORMAT_OVERHEAD\n    let queue = []\n\n    for (const span of spans) {\n      const spanStr = JSON.stringify(span)\n      if (spanStr.length + TRACE_FORMAT_OVERHEAD > MAX_SIZE) {\n        log.debug('Span too large to send to logs, dropping')\n        continue\n      }\n      if (spanStr.length + size > MAX_SIZE) {\n        this._printSpans(queue)\n        queue = []\n        size = TRACE_FORMAT_OVERHEAD\n      }\n      size += spanStr.length + 1 // includes length of ',' character\n      queue.push(spanStr)\n    }\n    if (queue.length > 0) {\n      this._printSpans(queue)\n    }\n  }\n\n  _printSpans (queue) {\n    let logLine = TRACE_PREFIX\n    let firstTrace = true\n    for (const spanStr of queue) {\n      if (firstTrace) {\n        firstTrace = false\n        logLine += spanStr\n      } else {\n        logLine += ',' + spanStr\n      }\n    }\n    logLine += TRACE_SUFFIX\n    process.stdout.write(logLine)\n  }\n}\n\nmodule.exports = LogExporter\n"]},"metadata":{},"sourceType":"script"}