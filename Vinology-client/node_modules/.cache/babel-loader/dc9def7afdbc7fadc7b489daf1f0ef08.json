{"ast":null,"code":"const assert = require('assert');\n\nconst dgram = require('dgram');\n\nconst net = require('net');\n\nconst dns = require('dns');\n\nconst {\n  PROTOCOL\n} = require('./constants'); // Imported below, only if needed\n\n\nlet unixDgram;\nconst UDS_PATH_DEFAULT = '/var/run/datadog/dsd.socket';\n\nconst addEol = buf => {\n  let msg = buf.toString();\n\n  if (msg.length > 0 && msg[msg.length - 1] !== '\\n') {\n    msg += '\\n';\n  }\n\n  return msg;\n}; // interface Transport {\n//   emit(name: string, payload: any):void;\n//   on(name: string, listener: Function):void;\n//   removeListener(name: string, listener: Function):void;\n//   send(buf: Buffer, callback: Function):void;\n//   close():void;\n//   unref(): void;\n// }\n\n\nconst createTcpTransport = args => {\n  const socket = net.connect(args.port, args.host);\n  socket.setKeepAlive(true); // do not block node from shutting down\n\n  socket.unref();\n  return {\n    emit: socket.emit.bind(socket),\n    on: socket.on.bind(socket),\n    removeListener: socket.removeListener.bind(socket),\n    send: (buf, callback) => {\n      socket.write(addEol(buf), 'ascii', callback);\n    },\n    close: () => socket.destroy(),\n    unref: socket.unref.bind(socket)\n  };\n};\n\nconst createUdpTransport = args => {\n  const socket = dgram.createSocket('udp4'); // do not block node from shutting down\n\n  socket.unref();\n  const dnsResolutionData = {\n    timestamp: new Date(0),\n    resolvedAddress: undefined\n  };\n\n  const sendUsingDnsCache = (callback, buf) => {\n    const now = Date.now();\n\n    if (dnsResolutionData.resolvedAddress === undefined || now - dnsResolutionData.timestamp > args.cacheDnsTtl) {\n      dns.lookup(args.host, (error, address) => {\n        if (error) {\n          callback(error);\n          return;\n        }\n\n        dnsResolutionData.resolvedAddress = address;\n        dnsResolutionData.timestamp = now;\n        socket.send(buf, 0, buf.length, args.port, dnsResolutionData.resolvedAddress, callback);\n      });\n    } else {\n      socket.send(buf, 0, buf.length, args.port, dnsResolutionData.resolvedAddress, callback);\n    }\n  };\n\n  return {\n    emit: socket.emit.bind(socket),\n    on: socket.on.bind(socket),\n    removeListener: socket.removeListener.bind(socket),\n    send: function (buf, callback) {\n      if (args.cacheDns) {\n        sendUsingDnsCache(callback, buf);\n      } else {\n        socket.send(buf, 0, buf.length, args.port, args.host, callback);\n      }\n    },\n    close: socket.close.bind(socket),\n    unref: socket.unref.bind(socket)\n  };\n};\n\nconst createUdsTransport = args => {\n  try {\n    // This will not always be available, as noted in the error message below\n    unixDgram = require('unix-dgram'); // eslint-disable-line global-require\n  } catch (err) {\n    throw new Error('The library `unix_dgram`, needed for the uds protocol to work, is not installed. ' + 'You need to pick another protocol to use hot-shots. ' + 'See the hot-shots README for additional details.');\n  }\n\n  const udsPath = args.path ? args.path : UDS_PATH_DEFAULT;\n  const socket = unixDgram.createSocket('unix_dgram');\n\n  try {\n    socket.connect(udsPath);\n  } catch (err) {\n    socket.close();\n    throw err;\n  }\n\n  return {\n    emit: socket.emit.bind(socket),\n    on: socket.on.bind(socket),\n    removeListener: socket.removeListener.bind(socket),\n    send: socket.send.bind(socket),\n    close: () => {\n      socket.close(); // close is synchronous, and the socket will not emit a\n      // close event, hence emulating standard behaviour by doing this:\n\n      socket.emit('close');\n    },\n    unref: () => {\n      throw new Error('unix-dgram does not implement unref for sockets');\n    }\n  };\n};\n\nconst createStreamTransport = args => {\n  const stream = args.stream;\n  assert(stream, '`stream` option required');\n  return {\n    emit: stream.emit.bind(stream),\n    on: stream.on.bind(stream),\n    removeListener: stream.removeListener.bind(stream),\n    send: (buf, callback) => stream.write(addEol(buf), callback),\n    close: () => {\n      stream.destroy(); // Node v8 doesn't fire `close` event on stream destroy.\n\n      if (process.version.split('.').shift() === 'v8') {\n        stream.emit('close');\n      }\n    },\n    unref: () => {\n      throw new Error('stream transport does not support unref');\n    }\n  };\n};\n\nmodule.exports = (instance, args) => {\n  let transport = null;\n  const protocol = args.protocol || PROTOCOL.UDP;\n\n  try {\n    if (protocol === PROTOCOL.TCP) {\n      transport = createTcpTransport(args);\n    } else if (protocol === PROTOCOL.UDS) {\n      transport = createUdsTransport(args);\n    } else if (protocol === PROTOCOL.UDP) {\n      transport = createUdpTransport(args);\n    } else if (protocol === PROTOCOL.STREAM) {\n      transport = createStreamTransport(args);\n    } else {\n      throw new Error(`Unsupported protocol '${protocol}'`);\n    }\n\n    transport.type = protocol;\n    transport.createdAt = Date.now();\n  } catch (e) {\n    if (instance.errorHandler) {\n      instance.errorHandler(e);\n    } else {\n      console.error(e);\n    }\n  }\n\n  return transport;\n};","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/hot-shots/lib/transport.js"],"names":["assert","require","dgram","net","dns","PROTOCOL","unixDgram","UDS_PATH_DEFAULT","addEol","buf","msg","toString","length","createTcpTransport","args","socket","connect","port","host","setKeepAlive","unref","emit","bind","on","removeListener","send","callback","write","close","destroy","createUdpTransport","createSocket","dnsResolutionData","timestamp","Date","resolvedAddress","undefined","sendUsingDnsCache","now","cacheDnsTtl","lookup","error","address","cacheDns","createUdsTransport","err","Error","udsPath","path","createStreamTransport","stream","process","version","split","shift","module","exports","instance","transport","protocol","UDP","TCP","UDS","STREAM","type","createdAt","e","errorHandler","console"],"mappings":"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","sourcesContent":["const assert = require('assert');\nconst dgram = require('dgram');\nconst net = require('net');\nconst dns = require('dns');\nconst { PROTOCOL } = require('./constants');\n\n// Imported below, only if needed\nlet unixDgram;\n\nconst UDS_PATH_DEFAULT = '/var/run/datadog/dsd.socket';\n\nconst addEol = (buf) => {\n  let msg = buf.toString();\n  if (msg.length > 0 && msg[msg.length - 1] !== '\\n') {\n    msg += '\\n';\n  }\n  return msg;\n};\n\n// interface Transport {\n//   emit(name: string, payload: any):void;\n//   on(name: string, listener: Function):void;\n//   removeListener(name: string, listener: Function):void;\n//   send(buf: Buffer, callback: Function):void;\n//   close():void;\n//   unref(): void;\n// }\nconst createTcpTransport = args => {\n  const socket = net.connect(args.port, args.host);\n  socket.setKeepAlive(true);\n  // do not block node from shutting down\n  socket.unref();\n  return {\n    emit: socket.emit.bind(socket),\n    on: socket.on.bind(socket),\n    removeListener: socket.removeListener.bind(socket),\n    send: (buf, callback) => {\n      socket.write(addEol(buf), 'ascii', callback);\n    },\n    close: () => socket.destroy(),\n    unref: socket.unref.bind(socket)\n\n  };\n};\n\nconst createUdpTransport = args => {\n  const socket = dgram.createSocket('udp4');\n  // do not block node from shutting down\n  socket.unref();\n\n  const dnsResolutionData = {\n    timestamp: new Date(0),\n    resolvedAddress: undefined\n  };\n\n  const sendUsingDnsCache = (callback, buf) => {\n    const now = Date.now();\n    if (dnsResolutionData.resolvedAddress === undefined || (now - dnsResolutionData.timestamp > args.cacheDnsTtl)) {\n      dns.lookup(args.host, (error, address) => {\n        if (error) {\n          callback(error);\n          return;\n        }\n        dnsResolutionData.resolvedAddress = address;\n        dnsResolutionData.timestamp = now;\n        socket.send(buf, 0, buf.length, args.port, dnsResolutionData.resolvedAddress, callback);\n      });\n    } else {\n      socket.send(buf, 0, buf.length, args.port, dnsResolutionData.resolvedAddress, callback);\n    }\n  };\n\n  return {\n    emit: socket.emit.bind(socket),\n    on: socket.on.bind(socket),\n    removeListener: socket.removeListener.bind(socket),\n    send: function (buf, callback) {\n      if (args.cacheDns) {\n        sendUsingDnsCache(callback, buf);\n      } else {\n        socket.send(buf, 0, buf.length, args.port, args.host, callback);\n      }\n    },\n    close: socket.close.bind(socket),\n    unref: socket.unref.bind(socket)\n  };\n};\n\nconst createUdsTransport = args => {\n  try {\n    // This will not always be available, as noted in the error message below\n    unixDgram = require('unix-dgram'); // eslint-disable-line global-require\n  } catch (err) {\n    throw new Error(\n      'The library `unix_dgram`, needed for the uds protocol to work, is not installed. ' +\n        'You need to pick another protocol to use hot-shots. ' +\n        'See the hot-shots README for additional details.'\n    );\n  }\n  const udsPath = args.path ? args.path : UDS_PATH_DEFAULT;\n  const socket = unixDgram.createSocket('unix_dgram');\n\n  try {\n    socket.connect(udsPath);\n  } catch (err) {\n    socket.close();\n    throw err;\n  }\n\n  return {\n    emit: socket.emit.bind(socket),\n    on: socket.on.bind(socket),\n    removeListener: socket.removeListener.bind(socket),\n    send: socket.send.bind(socket),\n    close: () => {\n      socket.close();\n      // close is synchronous, and the socket will not emit a\n      // close event, hence emulating standard behaviour by doing this:\n      socket.emit('close');\n    },\n    unref: () => {\n      throw new Error('unix-dgram does not implement unref for sockets');\n    }\n  };\n};\n\nconst createStreamTransport = (args) => {\n  const stream = args.stream;\n  assert(stream, '`stream` option required');\n\n  return {\n    emit: stream.emit.bind(stream),\n    on: stream.on.bind(stream),\n    removeListener: stream.removeListener.bind(stream),\n    send: (buf, callback) => stream.write(addEol(buf), callback),\n    close: () => {\n      stream.destroy();\n\n      // Node v8 doesn't fire `close` event on stream destroy.\n      if (process.version.split('.').shift() === 'v8') {\n        stream.emit('close');\n      }\n    },\n    unref: () => {\n      throw new Error('stream transport does not support unref');\n    }\n  };\n};\n\nmodule.exports = (instance, args) => {\n  let transport = null;\n  const protocol = args.protocol || PROTOCOL.UDP;\n\n  try {\n    if (protocol === PROTOCOL.TCP) {\n      transport = createTcpTransport(args);\n    } else if (protocol === PROTOCOL.UDS) {\n      transport = createUdsTransport(args);\n    } else if (protocol === PROTOCOL.UDP) {\n      transport = createUdpTransport(args);\n    } else if (protocol === PROTOCOL.STREAM) {\n      transport = createStreamTransport(args);\n    } else {\n      throw new Error(`Unsupported protocol '${protocol}'`);\n    }\n    transport.type = protocol;\n    transport.createdAt = Date.now();\n  } catch (e) {\n    if (instance.errorHandler) {\n      instance.errorHandler(e);\n    } else {\n      console.error(e);\n    }\n  }\n\n  return transport;\n};\n"]},"metadata":{},"sourceType":"script"}