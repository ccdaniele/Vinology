{"ast":null,"code":"const {\n  promisify\n} = require('util');\n\nconst {\n  RESOURCE_NAME\n} = require('../../../ext/tags');\n\nconst {\n  TEST_NAME,\n  TEST_SUITE,\n  TEST_STATUS,\n  CI_APP_ORIGIN,\n  getTestEnvironmentMetadata,\n  finishAllTraceSpans,\n  getTestSuitePath\n} = require('../../dd-trace/src/plugins/util/test');\n\nconst {\n  getTestSpanTags,\n  setSuppressedErrors\n} = require('./util');\n\nfunction createWrapIt(tracer, globalConfig, globalInput, testEnvironmentMetadata) {\n  return function wrapIt(it) {\n    return function itWithTrace(description, specFunction, timeout) {\n      let oldSpecFunction = specFunction;\n\n      if (specFunction.length) {\n        oldSpecFunction = promisify(oldSpecFunction);\n      }\n\n      const {\n        childOf,\n        commonSpanTags\n      } = getTestSpanTags(tracer, testEnvironmentMetadata);\n      const testSuite = getTestSuitePath(globalInput.jasmine.testPath, globalConfig.rootDir);\n      const newSpecFunction = tracer.wrap('jest.test', {\n        type: 'test',\n        childOf,\n        tags: { ...commonSpanTags,\n          [TEST_SUITE]: testSuite\n        }\n      }, async done => {\n        const testSpan = tracer.scope().active();\n        const {\n          currentTestName\n        } = globalInput.expect.getState();\n        const resource = `${testSuite}.${currentTestName}`;\n        testSpan.setTag(TEST_NAME, currentTestName);\n        testSpan.setTag(RESOURCE_NAME, resource);\n        testSpan.context()._trace.origin = CI_APP_ORIGIN;\n        let result;\n        globalInput.jasmine.testSpanByTestName[currentTestName] = testSpan;\n\n        try {\n          result = await oldSpecFunction();\n          const suppressedErrors = globalInput.expect.getState().suppressedErrors;\n          setSuppressedErrors(suppressedErrors, testSpan);\n\n          if (!testSpan._spanContext._tags[TEST_STATUS]) {\n            testSpan.setTag(TEST_STATUS, 'pass');\n          }\n        } catch (error) {\n          testSpan.setTag(TEST_STATUS, 'fail');\n          testSpan.setTag('error', error);\n\n          if (done) {\n            done(error);\n          }\n\n          throw error;\n        } finally {\n          finishAllTraceSpans(testSpan);\n        }\n\n        if (done) {\n          done(result);\n        }\n      });\n      return it(description, newSpecFunction, timeout);\n    };\n  };\n}\n\nfunction createWrapOnException(tracer, globalInput) {\n  return function wrapOnException(onException) {\n    return function onExceptionWithTrace(err) {\n      let activeTestSpan = tracer.scope().active();\n\n      if (!activeTestSpan) {\n        activeTestSpan = globalInput.jasmine.testSpanByTestName[this.getFullName()];\n      }\n\n      if (!activeTestSpan) {\n        return onException.apply(this, arguments);\n      }\n\n      const {\n        [TEST_NAME]: testName,\n        [TEST_SUITE]: testSuite,\n        [TEST_STATUS]: testStatus\n      } = activeTestSpan._spanContext._tags;\n      const isActiveSpanFailing = this.getFullName() === testName && this.result.testPath.endsWith(testSuite);\n\n      if (isActiveSpanFailing && !testStatus) {\n        activeTestSpan.setTag(TEST_STATUS, 'fail'); // If we don't do this, jest will show this file on its error message\n\n        const stackFrames = err.stack.split('\\n');\n        const filteredStackFrames = stackFrames.filter(frame => !frame.includes(__dirname)).join('\\n');\n        err.stack = filteredStackFrames;\n        activeTestSpan.setTag('error', err); // need to manually finish, as it will not be caught in `itWithTrace`\n\n        activeTestSpan.finish();\n      }\n\n      return onException.apply(this, arguments);\n    };\n  };\n}\n\nfunction createWrapItSkip(tracer, globalConfig, globalInput, testEnvironmentMetadata) {\n  return function wrapItSkip(it) {\n    return function itSkipWithTrace() {\n      const {\n        childOf,\n        commonSpanTags\n      } = getTestSpanTags(tracer, testEnvironmentMetadata);\n      const testSuite = getTestSuitePath(globalInput.jasmine.testPath, globalConfig.rootDir);\n      const spec = it.apply(this, arguments);\n      const testName = spec.getFullName();\n      const resource = `${testSuite}.${testName}`;\n      const testSpan = tracer.startSpan('jest.test', {\n        childOf,\n        tags: { ...commonSpanTags,\n          [RESOURCE_NAME]: resource,\n          [TEST_NAME]: testName,\n          [TEST_SUITE]: testSuite,\n          [TEST_STATUS]: 'skip'\n        }\n      });\n      testSpan.context()._trace.origin = CI_APP_ORIGIN;\n      testSpan.finish();\n      return spec;\n    };\n  };\n}\n\nfunction createWrapJasmineAsyncInstall(tracer, instrumenter, testEnvironmentMetadata) {\n  return function jasmineAsyncInstallWithTrace(jasmineAsyncInstall) {\n    return function (globalConfig, globalInput) {\n      globalInput.jasmine.testSpanByTestName = {};\n      instrumenter.wrap(globalInput.jasmine.Spec.prototype, 'onException', createWrapOnException(tracer, globalInput));\n      instrumenter.wrap(globalInput, 'it', createWrapIt(tracer, globalConfig, globalInput, testEnvironmentMetadata)); // instruments 'it.only'\n\n      instrumenter.wrap(globalInput, 'fit', createWrapIt(tracer, globalConfig, globalInput, testEnvironmentMetadata)); // instruments 'it.skip'\n\n      instrumenter.wrap(globalInput, 'xit', createWrapItSkip(tracer, globalConfig, globalInput, testEnvironmentMetadata));\n      return jasmineAsyncInstall(globalConfig, globalInput);\n    };\n  };\n}\n\nmodule.exports = [{\n  name: 'jest-jasmine2',\n  versions: ['>=24.8.0'],\n  file: 'build/jasmineAsyncInstall.js',\n  patch: function (jasmineAsyncInstallExport, tracer) {\n    const testEnvironmentMetadata = getTestEnvironmentMetadata('jest');\n    return this.wrapExport(jasmineAsyncInstallExport.default, createWrapJasmineAsyncInstall(tracer, this, testEnvironmentMetadata)(jasmineAsyncInstallExport.default));\n  },\n  unpatch: function (jasmineAsyncInstallExport) {\n    this.unwrapExport(jasmineAsyncInstallExport.default);\n  }\n}];","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/dd-trace/packages/datadog-plugin-jest/src/jest-jasmine2.js"],"names":["promisify","require","RESOURCE_NAME","TEST_NAME","TEST_SUITE","TEST_STATUS","CI_APP_ORIGIN","getTestEnvironmentMetadata","finishAllTraceSpans","getTestSuitePath","getTestSpanTags","setSuppressedErrors","createWrapIt","tracer","globalConfig","globalInput","testEnvironmentMetadata","wrapIt","it","itWithTrace","description","specFunction","timeout","oldSpecFunction","length","childOf","commonSpanTags","testSuite","jasmine","testPath","rootDir","newSpecFunction","wrap","type","tags","done","testSpan","scope","active","currentTestName","expect","getState","resource","setTag","context","_trace","origin","result","testSpanByTestName","suppressedErrors","_spanContext","_tags","error","createWrapOnException","wrapOnException","onException","onExceptionWithTrace","err","activeTestSpan","getFullName","apply","arguments","testName","testStatus","isActiveSpanFailing","endsWith","stackFrames","stack","split","filteredStackFrames","filter","frame","includes","__dirname","join","finish","createWrapItSkip","wrapItSkip","itSkipWithTrace","spec","startSpan","createWrapJasmineAsyncInstall","instrumenter","jasmineAsyncInstallWithTrace","jasmineAsyncInstall","Spec","prototype","module","exports","name","versions","file","patch","jasmineAsyncInstallExport","wrapExport","default","unpatch","unwrapExport"],"mappings":"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","sourcesContent":["const { promisify } = require('util')\n\nconst { RESOURCE_NAME } = require('../../../ext/tags')\nconst {\n  TEST_NAME,\n  TEST_SUITE,\n  TEST_STATUS,\n  CI_APP_ORIGIN,\n  getTestEnvironmentMetadata,\n  finishAllTraceSpans,\n  getTestSuitePath\n} = require('../../dd-trace/src/plugins/util/test')\nconst { getTestSpanTags, setSuppressedErrors } = require('./util')\n\nfunction createWrapIt (tracer, globalConfig, globalInput, testEnvironmentMetadata) {\n  return function wrapIt (it) {\n    return function itWithTrace (description, specFunction, timeout) {\n      let oldSpecFunction = specFunction\n      if (specFunction.length) {\n        oldSpecFunction = promisify(oldSpecFunction)\n      }\n\n      const { childOf, commonSpanTags } = getTestSpanTags(tracer, testEnvironmentMetadata)\n\n      const testSuite = getTestSuitePath(globalInput.jasmine.testPath, globalConfig.rootDir)\n\n      const newSpecFunction = tracer.wrap(\n        'jest.test',\n        {\n          type: 'test',\n          childOf,\n          tags: { ...commonSpanTags, [TEST_SUITE]: testSuite }\n        },\n        async (done) => {\n          const testSpan = tracer.scope().active()\n          const { currentTestName } = globalInput.expect.getState()\n          const resource = `${testSuite}.${currentTestName}`\n          testSpan.setTag(TEST_NAME, currentTestName)\n          testSpan.setTag(RESOURCE_NAME, resource)\n          testSpan.context()._trace.origin = CI_APP_ORIGIN\n          let result\n          globalInput.jasmine.testSpanByTestName[currentTestName] = testSpan\n\n          try {\n            result = await oldSpecFunction()\n            const suppressedErrors = globalInput.expect.getState().suppressedErrors\n            setSuppressedErrors(suppressedErrors, testSpan)\n            if (!testSpan._spanContext._tags[TEST_STATUS]) {\n              testSpan.setTag(TEST_STATUS, 'pass')\n            }\n          } catch (error) {\n            testSpan.setTag(TEST_STATUS, 'fail')\n            testSpan.setTag('error', error)\n            if (done) {\n              done(error)\n            }\n            throw error\n          } finally {\n            finishAllTraceSpans(testSpan)\n          }\n          if (done) {\n            done(result)\n          }\n        }\n      )\n      return it(description, newSpecFunction, timeout)\n    }\n  }\n}\n\nfunction createWrapOnException (tracer, globalInput) {\n  return function wrapOnException (onException) {\n    return function onExceptionWithTrace (err) {\n      let activeTestSpan = tracer.scope().active()\n      if (!activeTestSpan) {\n        activeTestSpan = globalInput.jasmine.testSpanByTestName[this.getFullName()]\n      }\n      if (!activeTestSpan) {\n        return onException.apply(this, arguments)\n      }\n      const {\n        [TEST_NAME]: testName,\n        [TEST_SUITE]: testSuite,\n        [TEST_STATUS]: testStatus\n      } = activeTestSpan._spanContext._tags\n\n      const isActiveSpanFailing = this.getFullName() === testName &&\n        this.result.testPath.endsWith(testSuite)\n\n      if (isActiveSpanFailing && !testStatus) {\n        activeTestSpan.setTag(TEST_STATUS, 'fail')\n        // If we don't do this, jest will show this file on its error message\n        const stackFrames = err.stack.split('\\n')\n        const filteredStackFrames = stackFrames.filter(frame => !frame.includes(__dirname)).join('\\n')\n        err.stack = filteredStackFrames\n        activeTestSpan.setTag('error', err)\n        // need to manually finish, as it will not be caught in `itWithTrace`\n        activeTestSpan.finish()\n      }\n\n      return onException.apply(this, arguments)\n    }\n  }\n}\n\nfunction createWrapItSkip (tracer, globalConfig, globalInput, testEnvironmentMetadata) {\n  return function wrapItSkip (it) {\n    return function itSkipWithTrace () {\n      const { childOf, commonSpanTags } = getTestSpanTags(tracer, testEnvironmentMetadata)\n\n      const testSuite = getTestSuitePath(globalInput.jasmine.testPath, globalConfig.rootDir)\n\n      const spec = it.apply(this, arguments)\n\n      const testName = spec.getFullName()\n      const resource = `${testSuite}.${testName}`\n\n      const testSpan = tracer.startSpan(\n        'jest.test',\n        {\n          childOf,\n          tags: {\n            ...commonSpanTags,\n            [RESOURCE_NAME]: resource,\n            [TEST_NAME]: testName,\n            [TEST_SUITE]: testSuite,\n            [TEST_STATUS]: 'skip'\n          }\n        }\n      )\n      testSpan.context()._trace.origin = CI_APP_ORIGIN\n      testSpan.finish()\n\n      return spec\n    }\n  }\n}\n\nfunction createWrapJasmineAsyncInstall (tracer, instrumenter, testEnvironmentMetadata) {\n  return function jasmineAsyncInstallWithTrace (jasmineAsyncInstall) {\n    return function (globalConfig, globalInput) {\n      globalInput.jasmine.testSpanByTestName = {}\n      instrumenter.wrap(globalInput.jasmine.Spec.prototype, 'onException', createWrapOnException(tracer, globalInput))\n      instrumenter.wrap(globalInput, 'it', createWrapIt(tracer, globalConfig, globalInput, testEnvironmentMetadata))\n      // instruments 'it.only'\n      instrumenter.wrap(globalInput, 'fit', createWrapIt(tracer, globalConfig, globalInput, testEnvironmentMetadata))\n      // instruments 'it.skip'\n      instrumenter.wrap(\n        globalInput,\n        'xit',\n        createWrapItSkip(tracer, globalConfig, globalInput, testEnvironmentMetadata)\n      )\n      return jasmineAsyncInstall(globalConfig, globalInput)\n    }\n  }\n}\n\nmodule.exports = [\n  {\n    name: 'jest-jasmine2',\n    versions: ['>=24.8.0'],\n    file: 'build/jasmineAsyncInstall.js',\n    patch: function (jasmineAsyncInstallExport, tracer) {\n      const testEnvironmentMetadata = getTestEnvironmentMetadata('jest')\n      return this.wrapExport(\n        jasmineAsyncInstallExport.default,\n        createWrapJasmineAsyncInstall(tracer, this, testEnvironmentMetadata)(jasmineAsyncInstallExport.default)\n      )\n    },\n    unpatch: function (jasmineAsyncInstallExport) {\n      this.unwrapExport(jasmineAsyncInstallExport.default)\n    }\n  }\n]\n"]},"metadata":{},"sourceType":"script"}