{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nmodule.exports = findit;\n\nfunction findit(basedir, opts) {\n  opts = opts || {};\n  var followSymlinks = !!opts.followSymlinks;\n  var myFs = opts.fs || fs;\n  var emitter = new EventEmitter();\n  var stopped = false;\n  var pending = 0;\n  var seen = {};\n  emitter.stop = stop;\n  walkPath(basedir);\n  return emitter;\n\n  function recursiveReadDir(basedir, linkPath) {\n    pendStart();\n    myFs.readdir(basedir, function (err, entries) {\n      if (stopped) return;\n\n      if (err) {\n        handleError(err, basedir);\n        pendEnd();\n        return;\n      }\n\n      entries.forEach(function (entry) {\n        var fullPath = path.join(basedir, entry);\n        var fullLinkPath = linkPath && path.join(linkPath, entry);\n        walkPath(fullPath, fullLinkPath);\n      });\n      pendEnd();\n    });\n  }\n\n  function walkPath(fullPath, linkPath) {\n    pendStart();\n    myFs.lstat(fullPath, function (err, stats) {\n      if (stopped) return;\n\n      if (err) {\n        handleError(err, fullPath);\n        pendEnd();\n        return;\n      }\n\n      emitter.emit('path', fullPath, stats, linkPath);\n      var dirStopped = false;\n\n      if (stats.isDirectory()) {\n        if (seen[fullPath]) {\n          err = new Error(\"file system loop detected\");\n          err.code = 'ELOOP';\n          handleError(err, fullPath);\n          pendEnd();\n          return;\n        }\n\n        seen[fullPath] = true;\n        emitter.emit('directory', fullPath, stats, stopDir, linkPath);\n        if (!dirStopped) recursiveReadDir(fullPath, linkPath);\n      } else if (stats.isFile()) {\n        if (!seen[fullPath]) {\n          seen[fullPath] = true;\n          emitter.emit('file', fullPath, stats, linkPath);\n        }\n      } else if (stats.isSymbolicLink()) {\n        emitter.emit('link', fullPath, stats, linkPath);\n        if (followSymlinks) recursiveReadLink(fullPath);\n      }\n\n      pendEnd();\n\n      function stopDir() {\n        dirStopped = true;\n      }\n    });\n  }\n\n  function recursiveReadLink(linkPath) {\n    pendStart();\n    myFs.readlink(linkPath, function (err, linkString) {\n      if (stopped) return;\n\n      if (err) {\n        handleError(err, linkPath);\n        pendEnd();\n        return;\n      }\n\n      var fullPath = path.resolve(path.dirname(linkPath), linkString);\n      emitter.emit('readlink', linkPath, fullPath);\n      walkPath(fullPath, linkPath);\n      pendEnd();\n    });\n  }\n\n  function stop() {\n    if (stopped) return;\n    stopped = true;\n    emitter.emit('stop');\n  }\n\n  function handleError(err, errPath) {\n    if (!err || stopped) return;\n    err.path = errPath;\n    emitter.emit('error', err);\n  }\n\n  function pendStart() {\n    pending += 1;\n  }\n\n  function pendEnd() {\n    if (stopped) return;\n    pending -= 1;\n\n    if (pending === 0) {\n      emitter.emit('end');\n    } else if (pending < 0) {\n      // this should never happen; if this gets thrown we need to debug findit\n      // and this stack trace will help.\n      throw new Error(\"pendEnd called too many times\");\n    }\n  }\n}","map":{"version":3,"sources":["/Users/danielcalderon/vinology/Vinology-client/node_modules/findit2/index.js"],"names":["EventEmitter","require","fs","path","module","exports","findit","basedir","opts","followSymlinks","myFs","emitter","stopped","pending","seen","stop","walkPath","recursiveReadDir","linkPath","pendStart","readdir","err","entries","handleError","pendEnd","forEach","entry","fullPath","join","fullLinkPath","lstat","stats","emit","dirStopped","isDirectory","Error","code","stopDir","isFile","isSymbolicLink","recursiveReadLink","readlink","linkString","resolve","dirname","errPath"],"mappings":"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","sourcesContent":["var EventEmitter = require('events').EventEmitter;\nvar fs = require('fs');\nvar path = require('path');\n\nmodule.exports = findit;\n\nfunction findit(basedir, opts) {\n  opts = opts || {};\n  var followSymlinks = !!opts.followSymlinks;\n  var myFs = opts.fs || fs;\n  var emitter = new EventEmitter();\n  var stopped = false;\n  var pending = 0;\n  var seen = {};\n\n  emitter.stop = stop;\n  walkPath(basedir);\n  return emitter;\n\n  function recursiveReadDir(basedir, linkPath) {\n    pendStart();\n    myFs.readdir(basedir, function(err, entries) {\n      if (stopped) return;\n      if (err) {\n        handleError(err, basedir);\n        pendEnd();\n        return;\n      }\n      entries.forEach(function(entry) {\n        var fullPath = path.join(basedir, entry);\n        var fullLinkPath = linkPath && path.join(linkPath, entry);\n        walkPath(fullPath, fullLinkPath);\n      });\n      pendEnd();\n    });\n  }\n\n  function walkPath(fullPath, linkPath) {\n    pendStart();\n    myFs.lstat(fullPath, function(err, stats) {\n      if (stopped) return;\n      if (err) {\n        handleError(err, fullPath);\n        pendEnd();\n        return;\n      }\n      emitter.emit('path', fullPath, stats, linkPath);\n      var dirStopped = false;\n      if (stats.isDirectory()) {\n        if (seen[fullPath]) {\n          err = new Error(\"file system loop detected\");\n          err.code = 'ELOOP';\n          handleError(err, fullPath);\n          pendEnd();\n          return;\n        }\n        seen[fullPath] = true;\n\n        emitter.emit('directory', fullPath, stats, stopDir, linkPath);\n        if (!dirStopped) recursiveReadDir(fullPath, linkPath);\n      } else if (stats.isFile()) {\n        if (!seen[fullPath]) {\n          seen[fullPath] = true;\n          emitter.emit('file', fullPath, stats, linkPath);\n        }\n      } else if (stats.isSymbolicLink()) {\n        emitter.emit('link', fullPath, stats, linkPath);\n        if (followSymlinks) recursiveReadLink(fullPath);\n      }\n      pendEnd();\n\n      function stopDir() {\n        dirStopped = true;\n      }\n    });\n  }\n\n  function recursiveReadLink(linkPath) {\n    pendStart();\n    myFs.readlink(linkPath, function(err, linkString) {\n      if (stopped) return;\n      if (err) {\n        handleError(err, linkPath);\n        pendEnd();\n        return;\n      }\n      var fullPath = path.resolve(path.dirname(linkPath), linkString);\n      emitter.emit('readlink', linkPath, fullPath);\n      walkPath(fullPath, linkPath);\n      pendEnd();\n    });\n  }\n\n  function stop() {\n    if (stopped) return;\n    stopped = true;\n    emitter.emit('stop');\n  }\n\n  function handleError(err, errPath) {\n    if (!err || stopped) return;\n    err.path = errPath;\n    emitter.emit('error', err);\n  }\n\n  function pendStart() {\n    pending += 1;\n  }\n\n  function pendEnd() {\n    if (stopped) return;\n    pending -= 1;\n    if (pending === 0) {\n      emitter.emit('end');\n    } else if (pending < 0) {\n      // this should never happen; if this gets thrown we need to debug findit\n      // and this stack trace will help.\n      throw new Error(\"pendEnd called too many times\");\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}